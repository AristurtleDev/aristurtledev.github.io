<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-12-collision-detection">Chapter 12: Collision Detection</h1>
<p class="text-secondary">Learn how to implement collision detection between game objects and handle collision responses like blocking, triggering events, and bouncing.</p>
<p>In <a href="../11_input_management/index.html">Chapter 11</a>, you learned how to manage player input to control game objects. However, for objects in your game to interact with each other, collecting items, hitting obstacles, or triggering events, you need to detect when these objects come into contact. This is accomplished through collision detection.</p>
<p>In this chapter you will:</p>
<ul>
<li>Understand different collision shapes and their use cases.</li>
<li>Implement rectangle-based collision detection.</li>
<li>Create circle-based collision detection.</li>
<li>Learn how to handle object overlap and response.</li>
<li>Build a reusable collision system for your game.</li>
</ul>
<p>Let's start by understanding the basics of collision detection and the different approaches we can use.</p>
<h2 id="understanding-collision-detection">Understanding Collision Detection</h2>
<p>Before we start implementing collision detection, let's discuss what collision detection actually is. In 2D games, collision detection involves checking if two objects interact with each other in some way. There are several approaches to detecting collisions, ranging from simple to complex:</p>
<h3 id="proximity-collision-detection">Proximity Collision Detection</h3>
<p>The simplest form is checking if objects are within a certain range of each other.  This is useful when you only need to know if objects are &quot;near&quot; each other like detecting if an enemy is close enough to chase a player or if two objects are close enough to perform a more complex collision check.</p>
<h3 id="simple-shape-based-collision-detection">Simple Shape Based Collision Detection</h3>
<p>Shaped based collision detection checks if two shapes overlap.  The most common and simple shapes used are circles and rectangles:</p>
<h4 id="circle-collision-detection">Circle Collision Detection</h4>
<p>Circle collision detection is computationally a simpler check than that rectangles.  There are also no special considerations if the circles are rotated, which makes them easier to use.  To determine if two circle shapes are overlapping, we only need to check if the square of the sum of the radii between the two circles is less than the squared distance between the two circles with the following formula:</p>
<p>Two find the distance between two circles, imagine drawing a line from the center of one circle to the center of the other.  This length of this line is the distance, but we could also calculate it by first walking up or down and then walking left or right from the center of one circle to another, forming a right triangle.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/circle-distance-right-triangle.svg" alt="Figure 12-1: Showing the distance between the center of two circles forms a right triange"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 12-1: Showing the distance between the center of two circles forms a right triange</strong></td>
</tr>
</tbody>
</table>
<p>In the Figure 12-1 above</p>
<ul>
<li><span class="math">\(a\)</span> is the distance between the center of the two on the x-axis (horizontal).</li>
<li><span class="math">\(b\)</span> is the distance between the center of the two circles on the y-axis (vertical).</li>
<li><span class="math">\(c\)</span> is the total distance between the center of the two circles.</li>
</ul>
<p>Since this forms a right triangle, to calculate the squared distance, we can use Pythagorean's Theorem:</p>
<p><span class="math">\(c^2 = a^2 + b^2\)</span></p>
<p>Then we just check if the squared sum of the radii of the two circles is less than the squared distance:</p>
<p><span class="math">\((radius_{circle1} + radius_{circle2})^2 &lt; c^2\)</span></p>
<p>If it is less, then the circles are overlapping; otherwise, they are not.</p>
<p>To calculate the squared distance between to points, MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Vector2.DistanceSquared(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)"><strong>Vector2.DistanceSquared</strong></a> method:</p>
<pre><code class="lang-csharp">Vector2 circle1Position = new Vector2(8, 10);
Vector2 circle2Position = new Vector2(5, 6);

float circle1Radius = 5;
float circle2Radius = 5;

// c^2 = (8 - 5)^2 + (10 - 6)^2
// c^2 = 3^2 + 4^2
// c^2 = 9 + 16
// c^2 = 25
float distanceSquared = Vector2.DistanceSquared(circle1Position, circle2Position); 

// r^2 = (5 + 5)^2
// r^2 = (10)^2
// r^2 = 100
int radiiSquared = (circle1Radius + circle2Radius) * (circle1Radius + circle2Radius)

// They do not overlap since 100 is not less than 25
if(radii &lt; distanceSquared)
{
    
}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>MonoGame also provides a distance calculation method with <a href="xref:Microsoft.Xna.Framework.Vector2.Distance(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)"><strong>Vector2.Distance</strong></a> which returns the distance by providing the square root of the distance squared.  So why don't we use this instead?</p>
<p>Square root operations are more computationally complex for a CPU.  So instead of getting the normal distance, which would require the square root operation, it's more efficient for the cpu to multiply the sum of the radii by itself to get the squared sum and use that for comparison instead.</p>
</div>
<h4 id="rectangle-collision-detection">Rectangle Collision Detection</h4>
<p>Rectangles, often called <em>bounding boxes</em>, typically uses what's called <em>Axis-Aligned Bounding Box</em> (AABB) collision detection to determine if two rectangle shapes overlap.  Unlike circles, to perform AABB collision detection, the x- and y-axes of both rectangles must be aligned with the x- and y-axes of the screen.  This is just another way of saying that the rectangles cannot be rotated.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/aabb-vs-non-aabb.svg" alt="Figure 12-2: The rectangle on the left is axis-aligned since both the axes are aligned with the screen axes. The rectangle on the right is non axis-aligned sine it is rotated and the axes do not align with the screen axe."></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 12-2: The rectangle on the left is axis-aligned since both the axes are aligned with the screen axes. The rectangle on the right is non axis-aligned sine it is rotated and the axes do not align with the screen axes</strong></td>
</tr>
</tbody>
</table>
<p>MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a> struct which represents a rectangle by its position (X,Y) and size (Width,Height). The following table shows some of the properties of the <a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a> struct:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Rectangle.Bottom"><strong>Bottom</strong></a></td>
<td><code>int</code></td>
<td>Returns the y-coordinate location of the bottom edge of the rectangle.  This is equal to <a href="xref:Microsoft.Xna.Framework.Rectangle.Y"><strong>Rectangle.Y</strong></a> plus the height of the rectangle.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Rectangle.Left"><strong>Left</strong></a></td>
<td><code>int</code></td>
<td>Returns the x-coordinate location of the left edge of the rectangle.  This is equal to <a href="xref:Microsoft.Xna.Framework.Rectangle.X"><strong>Rectangle.X</strong></a>.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Rectangle.Right"><strong>Right</strong></a></td>
<td><code>int</code></td>
<td>Returns the x-coordinate location of the right edge of the rectangle.  This is equal to <a href="xref:Microsoft.Xna.Framework.Rectangle.X"><strong>Rectangle.X</strong></a> plus the width of the rectangle.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Rectangle.Top"><strong>Top</strong></a></td>
<td><code>int</code></td>
<td>Returns the y-coordinate location of the top edge of the rectangle. This is equal to <a href="xref:Microsoft.Xna.Framework.Rectangle.Y"><strong>Rectangle.Y</strong></a>.</td>
</tr>
</tbody>
</table>
<p>To determine if two rectangles overlap using AABB collision detection, there are four conditions that need to be checked, and all four conditions must be true.  Given two rectangles <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, these conditions are:</p>
<ol>
<li><span class="math">\(A_{Left}\)</span> must be less than <span class="math">\(B_{Right}\)</span>.</li>
<li><span class="math">\(A_{Right}\)</span> must be greater than <span class="math">\(B_{Left}\)</span>.</li>
<li><span class="math">\(A_{Top}\)</span> must be less than <span class="math">\(B_{Bottom}\)</span>.</li>
<li><span class="math">\(A_{Bottom}\)</span> must be greater than <span class="math">\(B_{Top}\)</span>.</li>
</ol>
<p>If even a single one of these conditions is false, then the rectangles are not overlapping and thus not colliding.</p>
<p>MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Rectangle.Intersects(Microsoft.Xna.Framework.Rectangle)"><strong>Rectangle.Intersects</strong></a> method which will perform an AABB collision check for us:</p>
<pre><code class="lang-csharp">// Rectangle 1
//                Top: 0
//          ----------------
//         |                |
//         |                |
// Left: 0 |                |  Right: 32
//         |                |
//         |                |
//          ----------------
//              Bottom: 32
Rectangle rect1 = new Rectangle(0, 0, 32, 32);

// Rectangle 2
//                Top: 16
//           ----------------
//          |                |
//          |                |
// Left: 16 |                |  Right: 48
//          |                |
//          |                |
//           ----------------
//              Bottom: 48
Rectangle rect2 = new Rectangle (16, 16, 32, 32);

// rect1.Left (0)  &lt; rect2.Right (48) = true
// rect1.Right (32) &gt; rect3.Left (16) = true
// rect1.Top (0) &lt; rect2.Bottom (48) = true
// rect1.Bottom (32) &gt; rect2.Top (16) = true
bool isColliding = rect1.Intersects(rect2); // returns true
</code></pre>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/aabb-collision-example.svg" alt="Figure 12-3: The rectangle on the left is overlapping the rectangle on the right based on the conditions required for the Axis-Aligned Bounding Box collision check"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 12-3: The rectangle on the left is overlapping the rectangle on the right based on the conditions required for the Axis-Aligned Bounding Box collision check</strong></td>
</tr>
</tbody>
</table>
<h4 id="complex-polygon-collision-detection">Complex Polygon Collision Detection</h4>
<p>Complex polygon collision detection uses a method called <em>Separating Axis Theorem</em> (SAT) to determine if two polygon shapes overlap.  SAT uses more complex calculations that can determine if any ploygon shape overlaps another polygon shape, including if they are rotated. There are performance considerations to consider when using SAT.</p>
<p>Implementing SAT is out-of-scope for this tutorial. If you are interested in further reading about this, please see the following articles as a good starting point:</p>
<ul>
<li><a href="https://www.sevenson.com.au/actionscript/sat/">Separating Axis Theorem (SAT) Explanation</a>.</li>
<li><a href="https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169">Collision Detection Using the Separating Axis Theorem</a> by Kah Shiu Chong.</li>
<li><a href="http://www.metanetsoftware.com/technique/tutorialA.html">N Tutorial A - Collision Detection and Response</a>.</li>
</ul>
<h4 id="choosing-a-collision-detection-method">Choosing a Collision Detection Method</h4>
<p>When determining which collision detection method to use, you should start with the simplest one that meets the needs of your game.  If distance checks work for your game mechanic, there's no need to implement more complex shape based detections.  Similarly, if a circle can represent the bounding area of a game object, start with that before moving onto rectangles.</p>
<p>Some other points to consider are</p>
<ul>
<li>Circles:
<ul>
<li>Better for round objects like balls and coins.</li>
<li>More accurate for rotating objects.</li>
<li>Simpler check for overlap than rectangles.</li>
</ul>
</li>
<li>Rectangles:
<ul>
<li>Great for walls, platforms, and most game objects.</li>
<li>Easy to visualize and debug.</li>
<li>Works well with tile-based games.</li>
</ul>
</li>
</ul>
<h3 id="collision-detection-vs-collision-response">Collision Detection vs Collision Response</h3>
<p>Often times when talking about collision detection, the term is used to mean both the detection of overlapping shapes and what to do once a positive check has occurred.  What you do after a positive collision check has occurred is called the <em>collision response</em>.  Some of the common responses are:</p>
<h4 id="blocking-collision-response">Blocking Collision Response</h4>
<p>A blocking collision response is the most basic response which just prevents the two objects from overlapping.  This is commonly used for walls, platforms and other solid objects.  To perform a blocking collision response:</p>
<ol>
<li>Store the location of an object calculating the new location to move it to.</li>
<li>Check if it is overlapping an object at the new location:</li>
</ol>
<ul>
<li>If it is overlapping, then set the position to the the position before it was moved.</li>
<li>If it is not overlapping, set the position to the new calculated position.</li>
</ul>
<p>For example:</p>
<pre><code class="lang-csharp">// Store the current location
Vector2 previousLocation = _spriteLocation;

// Calculate a new location
Vector2 newLocation = _spriteLocation + new Vector2(10, 0);

// Create a bounding box for the sprite object
Rectangle spriteBounds = new Rectangle(
    (int)newLocation.X,
    (int)newLocation.Y,
    (int)_sprite.Width,
    (int)_sprite.Height
);

// Create a bounding box for the blocking object
Rectangle blockingBounds = new Rectangle(
    (int)_blockingLocation_.X,
    (int)_blockingLocation_.Y,
    (int)_blockingSprite_.Width,
    (int)_blockingSprite_.Height
);

// Detect if they are colliding
if(spriteBounds.Intersects(blockingBounds)) 
{
    // Respond by not allowing the sprite to move by setting
    // the location back to the previous location.
    newLocation = previousLocation;
}

_spriteLocation = newLocation;
</code></pre>
<p>Sometimes, instead of preventing an object from moving onto another object, we want to ensure an object remains contained within a certain bounding area. MonoGame also provides the <a href="xref:Microsoft.Xna.Framework.Rectangle.Contains(Microsoft.Xna.Framework.Rectangle)"><strong>Rectangle.Contains</strong></a> method that we can use to determine this.  <a href="xref:Microsoft.Xna.Framework.Rectangle.Contains(Microsoft.Xna.Framework.Rectangle)"><strong>Rectangle.Contains</strong></a> can check if any of the following are completely contained within the bounds of the rectangle;</p>
<ul>
<li><a href="xref:Microsoft.Xna.Framework.Point"><strong>Point</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></li>
</ul>
<p>For example, if we wanted to perform a blocking collision response that ensure a sprite remained contained within the bounds of the game screen:</p>
<pre><code class="lang-csharp">// Store the current location
Vector2 previousLocation = _spriteLocation;

// Calculate a new location
Vector2 newLocation = _spriteLocation + new Vector2(10, 0);

// Create a bounding box for the sprite object
Rectangle spriteBounds = new Rectangle(
    (int)newLocation.X,
    (int)newLocation.Y,
    (int)_sprite.Width,
    (int)_sprite.Height
);

// Get the bounds of the screen as a rectangle
Rectangle screenBounds = new Rectangle(
    0,
    0,
    GraphicsDevice.PresentationParameters.BackBufferWidth,
    GraphicsDevice.PresentationParameters.BackBufferHeight
);

// Detect if the sprite is contained within the bounds of the screen
if(!screenBounds.Contains(spriteBounds)) 
{
    // Respond by not allowing the sprite to move to move outside the screen
    // bounds by setting the location back to the previous location.
    newLocation = previousLocation;
}

_spriteLocation = newLocation;
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>Use <a href="xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice.PresentationParameters"><strong>GraphicsDevice.PresentationParameters</strong></a> to get the actual screen dimensions instead of <a href="xref:Microsoft.Xna.Framework.GraphicsDeviceManager.PreferredBackBufferWidth"><strong>GraphicsDeviceManager.PreferredBackBufferWidth</strong></a> and <a href="xref:Microsoft.Xna.Framework.GraphicsDeviceManager.PreferredBackBufferHeight"><strong>GraphicsDeviceManager.PreferredBackBufferHeight</strong></a>.  The preferred values are only hints and may not reflect the actual back buffer size.</p>
</div>
<h4 id="trigger-collision-response">Trigger Collision Response</h4>
<p>Sometimes you want to trigger an event, rather than block movement, when a collision occurs.  Common examples include</p>
<ul>
<li>Collecting items.</li>
<li>Activating switches.</li>
<li>Entering zones or areas.</li>
<li>Triggering cutscenes.</li>
</ul>
<p>Performing a trigger collision response is just simply checking if the game object is overlapping with the bounding area of the trigger zone, and if so trigger the event.</p>
<p>For example:</p>
<pre><code class="lang-csharp">// Create a bounding box for the sprite object
Rectangle spriteBounds = new Rectangle(
    (int)_spriteLocation.X,
    (int)_spriteLocation.Y,
    (int)_sprite.Width,
    (int)_sprite.Height
);

// Detect if the sprite object is within the trigger zone
if(_spriteBounds.Intersects(_triggerBounds))
{
    // Perform some event
    CollectItem();
}
</code></pre><h4 id="bounce-collision-response">Bounce Collision Response</h4>
<p>For games that need objects to bonce off each other (like a the ball in a Pong game), we need to calculate how their velocity should change after the collision.  MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Vector2.Reflect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)"><strong>Vector2.Reflect</strong></a> method to handle this calculation for us. The method needs two pieces of information:</p>
<ol>
<li>The incoming vector (the direction something is moving).</li>
<li>The normal vector (the direction perpendicular to the surface).</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/reflection-diagram.svg" alt="Figure 12-4: A diagram showing how an incoming vector reflects off of a surface base around the normal vector of the surface"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 12-4: A diagram showing how an incoming vector reflects off of a surface base around the normal vector of the surface</strong></td>
</tr>
</tbody>
</table>
<p>As shown in the diagram above, when an incoming vector hits a surface, it reflects at the same angle (<span class="math">\(\theta\)</span>) relative to the normal vector.</p>
<div class="TIP">
<h5>Tip</h5>
<p>Think of the normal vector like the line you'd draw perpendicular to a mirror's surface. The angle between your incoming path and this line will be the same as the angle between your reflection and this line.</p>
</div>
<p>For example, if we had a ball moving around the screen and wanted it to bounce off the edges of the screen:</p>
<pre><code class="lang-csharp">// Calculate the new position of the ball based on the velocity
Vector2 newPosition = _ballPosition + _ballVelocity;

// Get the bounds of the ball as a rectangle
Rectangle ballBounds = new Rectangle(
    (int)_ballPosition.X,
    (int)_ballPosition.Y,
    (int)_ball.Width,
    (int)_ball.Height
);

// Get the bounds of the screen as a rectangle
Rectangle screenBounds = new Rectangle(
    0,
    0,
    GraphicsDevice.PresentationParameters.BackBufferWidth,
    GraphicsDevice.PresentationParameters.BackBufferHeight
);

// Detect if the ball object is within the screen bounds
if(!screenBounds.Contains(ballBounds))
{
    // Ball would move outside the screen
    // First find the distance from the edge of the ball to each edge of the screen.
    float distanceLeft = Math.Abs(screenBounds.Left - ballBounds.Left);
    float distanceRight = Math.Abs(screenBounds.Right - ballBounds.Right);
    float distanceTop = Math.Abs(screenBounds.Top - ballBounds.Top);
    float distanceBottom = Math.Abs(screenBounds.Bottom - ballBounds.Bottom);

    // Determine which screen edge is the closest
    float minDistance = Math.Min(
        Math.Min(distanceLeft, distanceRight),
        Math.Min(distanceTop, distanceBottom)
    );

    // Determine the normal vector based on which screen edge is the closest
    Vector2 normal;
    if (minDistance == distanceLeft)
    {
        // Closest to the left edge
        normal = Vector2.UnitX;
        newPosition.X = 0;
    }
    else if (minDistance == distanceRight)
    {
        // Closest to the right edge
        normal = -Vector2.UnitX;
        newPosition.X = screenBounds.Right - _ball.Width;
    }
    else if (minDistance == distanceTop)
    {
        // Closest to the top edge
        normal = Vector2.UnitY;
        newPosition.Y = 0;
    }
    else
    {
        // Closest to the bottom edge
        normal = -Vector2.UnitY;
        newPosition.Y = screenBounds.Bottom - _ball.Height;
    }

    // Reflect the velocity about the normal
    _ballVelocity = Vector2.Reflect(_ballVelocity, normal); 
}

// Set the new position of the ball
_ballVelocity = newPosition;
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p><a href="xref:Microsoft.Xna.Framework.Vector2.UnitX"><strong>Vector2.UnitX</strong></a> is <span class="math">\((1, 0)\)</span> and <a href="xref:Microsoft.Xna.Framework.Vector2.UnitY"><strong>Vector2.UnitY</strong></a> is <span class="math">\((0, 1)\)</span>.  We use these to get the screen edge normal since the edges of the screen are not at an angle.  For more complex surfaces, you would need to calculate the appropriate normal vector based on the surface angle</p>
</div>
<h3 id="optimizing-collision-performance">Optimizing Collision Performance</h3>
<p>When checking for collisions between multiple objects, testing every object against every other object (often called brute force checking) becomes inefficient as your game grows. Brute force checking can be calculated as <span class="math">\((n * (n - 1)) / 2\)</span> where <span class="math">\(n\)</span> is the total number of objects.  For example, if you have 100 objects in your game, that's <span class="math">\((100 * 99) / 2 = 4950\)</span> collision checks every frame.  To improve performance, we can use a two-phase approach:</p>
<ol>
<li>Broad Phase: A quick, simple check to rule out objects that definitely aren't colliding.</li>
<li>Narrow Phase: A more precise check only performed on objects that passed the broad phase.</li>
</ol>
<p>For our simple game with just two objects, this optimization isn't necessary. However, as you develop more complex games, implementing a broad-phase check can significantly improve performance.  Later in this tutorial series we will implement an algorithm called spatial hashing to perform broad phase checks.</p>
<h2 id="the-circle-struct">The Circle Struct</h2>
<p>For our game, we are going to implement circle based collision detection.   MonoGame does not have a <code>Circle</code> struct to represent a circle like it does with <a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a>.  Before we can perform circle collision, we will need to create our own.</p>
<p>In the <em>MonoGameLibrary</em> project, add a new file named <em>Circle.cs</em>.  Add the following code as the foundation of the <code>Circle</code> struct:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;

namespace MonoGameLibrary;

public readonly struct Circle : IEquatable&lt;Circle&gt; { }
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Notice that the struct will implement <a href="https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1"><code>IEquatable&lt;T&gt;</code></a>.  When creating value types like this, it is recommended to implement <code>IEquatable&lt;T&gt;</code> because it has better performance and can help avoid boxing.</p>
<p>For more information on recommended design guidelines for structs, see <a href="https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/struct">Struct Design - Framework Design Guidelines | Microsoft Learn</a></p>
</div>
<h3 id="circle-fields">Circle Fields</h3>
<p>The <code>Circle</code> struct uses both private and public fields to store its state.</p>
<p>First, add the following private static field that stores a reusable empty circle:</p>
<pre><code class="lang-csharp">private static readonly Circle s_empty = new Circle();
</code></pre>
<p>Next, add the following public fields that define the circle's position and size:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// The x-coordinate of the center of this circle.
/// &lt;/summary&gt;
public readonly int X;

/// &lt;summary&gt;
/// The y-coordinate of the center of this circle.
/// &lt;/summary&gt;
public readonly int Y;

/// &lt;summary&gt;
/// The length, in pixels, from the center of this circle to the edge.
/// &lt;/summary&gt;
public readonly int Radius;
</code></pre>
<p>These public fields store the fundamental properties of the circle:</p>
<ul>
<li><code>X</code> and <code>Y</code> define the center point location.</li>
<li><code>Radius</code> defines how far the circle extends from its center.</li>
</ul>
<h3 id="circle-properties">Circle Properties</h3>
<p>The <code>Circle</code> struct provides properties to access its location, state, and its boundaries.</p>
<p>Add the following property to get the location of the circle as a <a href="xref:Microsoft.Xna.Framework.Point"><strong>Point</strong></a> value:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the location of the center of this circle.
/// &lt;/summary&gt;
public readonly Point Location =&gt; new Point(X, Y);
</code></pre>
<p>Add the following properties to track empty circles:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets a circle with X=0, Y=0, and Radius=0.
/// &lt;/summary&gt;
public static Circle Empty =&gt; s_empty;

/// &lt;summary&gt;
/// Gets a value that indicates whether this circle has a radius of 0 and a location of (0, 0).
/// &lt;/summary&gt;
public readonly bool IsEmpty =&gt; X == 0 &amp;&amp; Y == 0 &amp;&amp; Radius == 0;
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>Empty</code> property returns a reusable instance of an empty circle stored in the private static field <code>s_empty</code>. This is more efficient than creating new empty circles each time one is needed, as it reuses the same instance in memory.</p>
</div>
<p>Add the following properties for getting the circle's boundaries:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the y-coordinate of the highest point on this circle.
/// &lt;/summary&gt;
public readonly int Top =&gt; Y - Radius;

/// &lt;summary&gt;
/// Gets the y-coordinate of the lowest point on this circle.
/// &lt;/summary&gt;
public readonly int Bottom =&gt; Y + Radius;

/// &lt;summary&gt;
/// Gets the x-coordinate of the leftmost point on this circle.
/// &lt;/summary&gt;
public readonly int Left =&gt; X - Radius;

/// &lt;summary&gt;
/// Gets the x-coordinate of the rightmost point on this circle.
/// &lt;/summary&gt;
public readonly int Right =&gt; X + Radius;
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>These boundary properties are particularly useful when you need to know the extent of a circle in screen space, such as determining if a circle is visible on screen or creating a bounding box around the circle.</p>
</div>
<h3 id="circle-constructors">Circle Constructors</h3>
<p>The <code>Circle</code> struct provides two ways to create a new circle:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new circle with the specified position and radius.
/// &lt;/summary&gt;
/// &lt;param name=&quot;x&quot;&gt;The x-coordinate of the center of the circle.&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;The y-coordinate of the center of the circle..&lt;/param&gt;
/// &lt;param name=&quot;radius&quot;&gt;The length from the center of the circle to an edge.&lt;/param&gt;
public Circle(int x, int y, int radius)
{
    X = x;
    Y = y;
    Radius = radius;
}

/// &lt;summary&gt;
/// Creates a new circle with the specified position and radius.
/// &lt;/summary&gt;
/// &lt;param name=&quot;location&quot;&gt;The center of the circle.&lt;/param&gt;
/// &lt;param name=&quot;radius&quot;&gt;The length from the center of the circle to an edge.&lt;/param&gt;
public Circle(Point location, int radius)
{
    X = location.X;
    Y = location.Y;
    Radius = radius;
}
</code></pre>
<p>The first constructor accepts individual x and y coordinates for the circle's center, while the second accepts a <a href="xref:Microsoft.Xna.Framework.Point"><strong>Point</strong></a> struct that combines both coordinates. Both constructors require a radius value that defines the circle's size.</p>
<h3 id="circle-methods">Circle Methods</h3>
<p>The <code>Circle</code> struct implements several methods to support equality comparison between circles. These methods allow us to check if two circles are identical (have the same center position and radius).</p>
<p>First, add the following method that will check if two circles are overlapping with each other:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates whether the specified circle intersects with this circle.
/// &lt;/summary&gt;
/// &lt;param name=&quot;other&quot;&gt;The other circle to check.&lt;/param&gt;
/// &lt;returns&gt;true if the other circle intersects with this circle; otherwise, false.&lt;/returns&gt;
public bool Intersects(Circle other)
{
    int radiiSquared = (this.Radius + other.Radius) * (this.Radius + other.Radius);
    float distanceSquared = Vector2.DistanceSquared(this.Location.ToVector2(), other.Location.ToVector2());
    return distanceSquared &lt; radiiSquared;
}
</code></pre>
<p>Next, add the following methods for comparing a circle with another object:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates whether this circle and the specified object are equal
/// &lt;/summary&gt;
/// &lt;param name=&quot;obj&quot;&gt;The object to compare with this circle.&lt;/param&gt;
/// &lt;returns&gt;true if this circle and the specified object are equal; otherwise, false.&lt;/returns&gt;
public override readonly bool Equals(object obj) =&gt; obj is Circle other &amp;&amp; Equals(other);

/// &lt;summary&gt;
/// Returns a value that indicates whether this circle and the specified circle are equal.
/// &lt;/summary&gt;
/// &lt;param name=&quot;other&quot;&gt;The circle to compare with this circle.&lt;/param&gt;
/// &lt;returns&gt;true if this circle and the specified circle are equal; otherwise, false.&lt;/returns&gt;
public readonly bool Equals(Circle other) =&gt; this.X == other.X &amp;&amp;
                                                this.Y == other.Y &amp;&amp;
                                                this.Radius == other.Radius;
</code></pre>
<p>Next, add the following override for <code>GetHashCode</code> to support using circles in hash-based collections:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns the hash code for this circle.
/// &lt;/summary&gt;
/// &lt;returns&gt;The hash code for this circle as a 32-bit signed integer.&lt;/returns&gt;
public override readonly int GetHashCode() =&gt; HashCode.Combine(X, Y, Radius);
</code></pre>
<p>Finally, add the following  operator overloads to support using == and != with circles:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates if the circle on the left hand side of the equality operator is equal to the
/// circle on the right hand side of the equality operator.
/// &lt;/summary&gt;
/// &lt;param name=&quot;lhs&quot;&gt;The circle on the left hand side of the equality operator.&lt;/param&gt;
/// &lt;param name=&quot;rhs&quot;&gt;The circle on the right hand side of the equality operator.&lt;/param&gt;
/// &lt;returns&gt;true if the two circles are equal; otherwise, false.&lt;/returns&gt;
public static bool operator ==(Circle lhs, Circle rhs) =&gt; lhs.Equals(rhs);

/// &lt;summary&gt;
/// Returns a value that indicates if the circle on the left hand side of the inequality operator is not equal to the
/// circle on the right hand side of the inequality operator.
/// &lt;/summary&gt;
/// &lt;param name=&quot;lhs&quot;&gt;The circle on the left hand side of the inequality operator.&lt;/param&gt;
/// &lt;param name=&quot;rhs&quot;&gt;The circle on the right hand side fo the inequality operator.&lt;/param&gt;
/// &lt;returns&gt;true if the two circle are not equal; otherwise, false.&lt;/returns&gt;
public static bool operator !=(Circle lhs, Circle rhs) =&gt; !lhs.Equals(rhs);
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>The operator overloads allow you to compare circles using familiar syntax:</p>
<pre><code class="lang-csharp">Circle circle1 = new Circle(0, 0, 5);
Circle circle2 = new Circle(0, 0, 5);
bool areEqual = circle1 == circle2;    // Returns true
</code></pre></div>
<p>Now that we have a struct to represent a circle and check for overlapping, let's update our game to implement collision detection and responses.</p>
<h2 id="adding-collision-to-our-game">Adding Collision To Our Game</h2>
<p>If you run the game right now and move the slime around, you'll notice a few issues that can be fixed by adding collision detection and response:</p>
<ol>
<li>You can move the slime outside the bounds of the screen.</li>
<li>Nothing occurs when the slime collides with the bat.</li>
<li>The bat doesn't move, providing no challenge in the game.</li>
</ol>
<p>Let's update our game to implement these changes using collision detection and response. Open <em>Game1.cs</em> and make the following changes:</p>
<pre><code class="lang-csharp" highlight-lines="1,5,25-29,40-45,81-181,186-198,298-299">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    // Tracks the position of the bat.
    private Vector2 _batPosition;

    // Tracks the velocity of the bat.
    private Vector2 _batVelocity;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        base.Initialize();

        // Set the initial position of the bat to be 10px
        // to the right of the slime.
        _batPosition = new Vector2(_slime.Width + 10, 0);

        // Assign the initial random velocity to the bat.
        AssignRandomBatVelocity();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);

        base.LoadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        // Create a bounding rectangle for the screen
        Rectangle screenBounds = new Rectangle(
            0,
            0,
            GraphicsDevice.PresentationParameters.BackBufferWidth,
            GraphicsDevice.PresentationParameters.BackBufferHeight
        );

        // Creating a bounding circle for the slime
        Circle slimeBounds = new Circle(
            (int)(_slimePosition.X + (_slime.Width * 0.5f)),
            (int)(_slimePosition.Y + (_slime.Height * 0.5f)),
            (int)(_slime.Width * 0.5f)
        );

        // Use distance based checks to determine if the slime is within the
        // bounds of the game screen, and if it's outside that screen edge,
        // move it back inside.
        if (slimeBounds.Left &lt; screenBounds.Left)
        {
            _slimePosition.X = screenBounds.Left;
        }
        else if (slimeBounds.Right &gt; screenBounds.Right)
        {
            _slimePosition.X = screenBounds.Right - _slime.Width;
        }

        if (slimeBounds.Top &lt; screenBounds.Top)
        {
            _slimePosition.Y = screenBounds.Top;
        }
        else if (slimeBounds.Bottom &gt; screenBounds.Bottom)
        {
            _slimePosition.Y = screenBounds.Bottom - _slime.Height;
        }

        // Calculate the new position of the bat based on the velocity
        Vector2 newBatPosition = _batPosition + _batVelocity;

        // Create a bounding circle for the bat
        Circle batBounds = new Circle(
            (int)(newBatPosition.X + (_bat.Width * 0.5f)),
            (int)(newBatPosition.Y + (_bat.Height * 0.5f)),
            (int)(_bat.Width * 0.5f)
        );

        Vector2 normal = Vector2.Zero;

        // Use distance based checks to determine if the bat is within the
        // bounds of the game screen, and if it's outside that screen edge,
        // reflect it about the screen edge normal
        if (batBounds.Left &lt; screenBounds.Left)
        {
            normal.X = Vector2.UnitX.X;
            newBatPosition.X = screenBounds.Left;
        }
        else if (batBounds.Right &gt; screenBounds.Right)
        {
            normal.X = -Vector2.UnitX.X;
            newBatPosition.X = screenBounds.Right - _bat.Width;
        }

        if (batBounds.Top &lt; screenBounds.Top)
        {
            normal.Y = Vector2.UnitY.Y;
            newBatPosition.Y = screenBounds.Top;
        }
        else if (batBounds.Bottom &gt; screenBounds.Bottom)
        {
            normal.Y = -Vector2.UnitY.Y;
            newBatPosition.Y = screenBounds.Bottom - _bat.Height;
        }

        // If the normal is anything but Vector2.Zero, this means the bat had
        // moved outside the screen edge so we should reflect it about the
        // normal.
        if (normal != Vector2.Zero)
        {
            _batVelocity = Vector2.Reflect(_batVelocity, normal);
        }

        _batPosition = newBatPosition;

        if (slimeBounds.Intersects(batBounds))
        {
            // Divide the width  and height of the screen into equal columns and
            // rows based on the width and height of the bat.
            int totalColumns = GraphicsDevice.PresentationParameters.BackBufferWidth / (int)_bat.Width;
            int totalRows = GraphicsDevice.PresentationParameters.BackBufferHeight / (int)_bat.Height;

            // Choose a random row and column based on the total number of each
            int column = Random.Shared.Next(0, totalColumns);
            int row = Random.Shared.Next(0, totalRows);

            // Change the bat position by setting the x and y values equal to
            // the column and row multiplied by the width and height.
            _batPosition = new Vector2(column * _bat.Width, row * _bat.Height);

            // Assign a new random velocity to the bat
            AssignRandomBatVelocity();
        }

        base.Update(gameTime);
    }

    private void AssignRandomBatVelocity()
    {
        // Generate a random angle
        float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2);

        // Convert angle to a direction vector
        float x = (float)Math.Cos(angle);
        float y = (float)Math.Sin(angle);
        Vector2 direction = new Vector2(x, y);

        // Multiply the direction vector by the movement speed
        _batVelocity = direction * MOVEMENT_SPEED;
    }

    private void CheckKeyboardInput()
    {
        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (Input.Keyboard.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }
    }

    private void CheckGamePadInput()
    {
        GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One];

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadOne.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
        }
        else
        {
            GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadOne.LeftThumbStick != Vector2.Zero)
        {
            _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
            _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, _slimePosition);

        // Draw the bat sprite.
        _bat.Draw(SpriteBatch, _batPosition);

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes made here are:</p>
<ol>
<li>The <code>using MonoGameLibrary</code> using directive was added so we can use the new <code>Circle</code> struct.</li>
<li>The field <code>_batPosition</code> was added to track the position of the bat.</li>
<li>The field <code>_batVelocity</code> was added to track the velocity of the bat.</li>
<li>The <code>AssignRandomBatVelocity()</code> method was added which calculates a random x and y velocity for the bat to move at when called.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a>, the initial position of the bat is set and <code>AssignRandomVelocity</code> is called to assign the initial velocity for the bat.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>, collision detection and response logic was added to perform the following in order:
<ol>
<li>A <a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a> bound is created to represent the bounds of the screen.</li>
<li>A <code>Circle</code> bound is created to represent the bounds of the slime.</li>
<li>Distance based checks are performed to ensure that the slime cannot move outside of the screen, the resolution of which is to perform a blocking response.</li>
<li>A new position for the bat is calculated based on the current velocity of the bat.</li>
<li>A <code>Circle</code> bound is created to represent the bounds of the bat.</li>
<li>Distance based checks are performed to ensure the bat cannot move outside of the screen, the resolution of which is to perform a bounce response.</li>
<li>A collision check is made to determine if the slime and bat are colliding (bat &quot;eating&quot; the slime).  If so, the bat is assigned a new random position within the screen and assigned a new random velocity.</li>
</ol>
</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a>, the bat is now drawn using the <code>_batPosition</code> value.</li>
</ol>
<p>Running the game now</p>
<ul>
<li>The bat will start moving with a random velocity and bounce off the edges of the screen</li>
<li>You can move the slime around, but cannot leave the bounds of the screen with the slime.</li>
<li>If you move the slime to collide (&quot;eat&quot;) the bat, the bat will respawn at a new location with a new velocity.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 12-5: When the slime collides (&quot;eats&quot;) the bat, the bat respawns in a new location on the screen with a random velocity assigned</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>Let's review what you accomplished in this chapter:</p>
<ul>
<li>Learned about different approaches to collision detection:
<ul>
<li>Distance-based checks for simple proximity detection.</li>
<li>Shape-based checks using circles and rectangles.</li>
<li>Complex polygon checks using SAT.</li>
</ul>
</li>
<li>Understood when to use different collision shapes:
<ul>
<li>Circles for round objects and rotation.</li>
<li>Rectangles for walls and platforms.</li>
</ul>
</li>
<li>Explored different types of collision responses:
<ul>
<li>Blocking to prevent objects from overlapping.</li>
<li>Triggering to cause events when objects collide.</li>
<li>Bouncing to reflect objects off surfaces.</li>
</ul>
</li>
<li>Created reusable components:
<ul>
<li>Implemented a Circle struct for circle-based collision.</li>
<li>Added methods to detect circle intersection.</li>
</ul>
</li>
<li>Applied collision concepts to our game:
<ul>
<li>Added screen boundary collision for the slime.</li>
<li>Implemented bouncing behavior for the bat.</li>
<li>Created a trigger response when the slime &quot;eats&quot; the bat.</li>
</ul>
</li>
</ul>
<p>In the next chapter, we'll explore using tilesets and tilemaps to create tile based environments for our game.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is the difference between collision detection and collision response?</p>
<div class="question-answer"><p>Collision detection is determining when two objects overlap or intersect, while collision response is what happens after a collision is detected (like blocking movement, triggering events, or bouncing objects off each other).</p>
</div>
</li>
<li><p>When using Rectangle.Intersects for AABB collision, what four conditions must all be true for a collision to occur?</p>
<div class="question-answer"><p>For two rectangles A and B to collide:</p>
<ol>
<li>A's left edge must be less than B's right edge</li>
<li>A's right edge must be greater than B's left edge</li>
<li>A's top edge must be less than B's bottom edge</li>
<li>A's bottom edge must be greater than B's top edge</li>
</ol>
</div>
</li>
<li><p>When implementing circle collision, why do we compare the distance between centers to the sum of the radii?</p>
<div class="question-answer"><p>Two circles are colliding if the distance between their centers is less than the sum of their radii. If the distance is greater, they are separate. If the distance equals the sum of radii, they are just touching at one point.</p>
</div>
</li>
<li><p>When implementing bounce collision response, what two pieces of information does <a href="xref:Microsoft.Xna.Framework.Vector2.Reflect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)"><strong>Vector2.Reflect</strong></a> need?</p>
<div class="question-answer"><p><a href="xref:Microsoft.Xna.Framework.Vector2.Reflect(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)"><strong>Vector2.Reflect</strong></a> needs:</p>
<ol>
<li>The incoming vector (direction the object is moving)</li>
<li>The normal vector (direction perpendicular to the surface being hit)</li>
</ol>
</div>
</li>
<li><p>Why might you choose to use circle collision over rectangle collision for certain objects?</p>
<div class="question-answer"><p>Circle collision might be chosen because:</p>
<ul>
<li>It's more accurate for round objects</li>
<li>It handles rotating objects better</li>
<li>It's simpler for continuous collision detection</li>
<li>It's natural for radius-based interactions</li>
</ul>
</div>
</li>
<li><p>In the blocking collision response example, why do we store the previous position before handling input?</p>
<div class="question-answer"><p>We store the previous position so that if a collision occurs after movement, we can reset the object back to its last valid position. This prevents objects from moving through each other by undoing any movement that would cause overlap.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
