<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-19-user-interface">Chapter 19: User Interface</h1>
<p class="text-secondary">Learn how to implement a user interface system in MonoGame, including creating reusable UI components and building interactive game menus</p>
<p>A critical component of any game is the user interface (UI) that allows players to interact with the game beyond just controlling the the character.  UI elements include menus, buttons, panels, labels, and various other interactive components that provide information and control options to the player.</p>
<p>In this chapter you will</p>
<ul>
<li>Learn the basics of user interface design in games.</li>
<li>Understand the parent-child relationship for UI elements.</li>
<li>Create reusable UI components for the MonoGameLibrary.</li>
<li>Implement a device-agnostic input system for UI navigation.</li>
<li>Build complete game menus including title, options, and pause screens.</li>
<li>Implement a UI component hierarchy for flexible layouts.</li>
<li>Learn about accessibility considerations in game UI development.</li>
</ul>
<p>Let's start by understanding what a user interface is and how it functions in game development.</p>
<h2 id="understanding-game-user-interfaces">Understanding Game User Interfaces</h2>
<p>A user interface in games serves as the bridge between the player and the game's systems.  Well designed UIs help players navigate the games's mechanics, understand their current status, and make informed decisions. For new game developers, understanding UI principles is crucial because even the most mechanically sound game can fail if players can't effectively interact with it.</p>
<p>Game UIs consist of various visual elements that serve different purposes:</p>
<ol>
<li><strong>Information Display</strong>: Elements like health bars, score counters, or minimap displays provide players with game state information.  These elements help players understand their progress, resources, and current status without interrupting gameplay.</li>
<li><strong>Interactive Controls</strong>: Buttons, sliders, checkboxes, and other interactive elements allow players to make choices, adjust settings, or navigate through different sections of the game.  These elements should provide clear visual feedback when interacted with to confirm the player's actions.</li>
<li><strong>Feedback Mechanisms</strong>: Visual effects like highlighting, color changes, or animations that respond to player actions help confirm that input was received.  This feedback loop creates an intuitive and responsive feel for the UI in your game.</li>
</ol>
<p>User interfaces for games can be categorized into two main types, each with its own design considerations</p>
<ul>
<li><strong>Diegetic UI</strong>: These elements exist within the game world itself and are often part of the narrative.  Examples include a health meter integrated into a character's suit, ammunition displayed on a weapon's holographic sight, or the dashboard instruments in the cockpit of a racing game.  A Diegetic UI can enhance immersion by making interface elements feel like natural parts of the game world.</li>
<li><strong>Non-diegetic UI</strong>: These elements exist outside the game world, overlaid on top of the gameplay.  Traditional menus, health bars in the corner of the screen, and score displays are common examples.  While less immersive than a diegetic UI, non-diegetic elements are often clearer and easier to read.</li>
</ul>
<p>For our game project, we'll focus on creating non-diegetic UI elements, specifically menu screens that allow players to navigate between different parts of the game and adjust settings.  This approach provides a solid foundation for understanding UI concepts that you can later expand upon in more complex games.</p>
<h3 id="ui-layout-systems">UI Layout Systems</h3>
<p>When designing and implementing game UI systems, developers must decide how UI elements will be positioned on the screen. Two primary approaches exist, each with distinct advantages and trade-offs;</p>
<ol>
<li><p><strong>Absolute Positioning</strong>:  In this approach, each UI element is placed at specific coordinates on the screen.  Elements are positioned using exact locations, which gives precise control over the layout.  This approach is straightforward to implement and works well for static layouts where elements don't need to adjust based on screen size or content changes.  The main disadvantage of absolute positioning is its lack of flexibility.  If the screen resolution changes or if an element's size changes, manual adjustments to positions are often necessary to maintain the desired layout.</p>
</li>
<li><p><strong>Layout engines</strong>: These system position UI elements relative to one another using rules and constraints.  Elements might be positioned using concepts like &quot;center&quot;, &quot;align to parent&quot;, or &quot;flow horizontally with spacing&quot;.  Layout engines add complexity but provide flexibility.  The advantage of layout engines is adaptability to different screen sizes and content changes.  However, they require more initial setup and can be more complex to implement from scratch.</p>
</li>
</ol>
<p>For our implementation we'll take a middle ground approach.  We'll primarily use absolute positioning for simplicity but will build a parent-child relationship system that provides some of the flexibility found in layout engines.  This hybrid approach gives us reasonable control without adding a lot of complexity.</p>
<p>Child elements will be positioned relative to their parent's position, forming a hierarchial structure.  When a parent element moves, all its children move with it, maintaining their relative positions.  This approach simplifies the management of grouped elements without requiring a full layout engine.</p>
<h3 id="parent-child-relationships">Parent-Child Relationships</h3>
<p>Parent-child relationships are part of many UI system, including the one we'll build in this chapter.  In this model, UI elements can contain other UI elements, creating a tree-like structure. This hierarchial approach mirrors how interface elements naturally group together in designs.</p>
<p>For example, a settings panel might contain multiple buttons, labels, and sliders.  By making these elements children of the panel, they can be managed as a cohesive unit.  This organizational structure provides several significant advantages:</p>
<ul>
<li><strong>Inheritance of Properties</strong>: Child elements can automatically inherit certain properties from their parents.  For instance, if a parent element is hidden or disabled, all its children can be hidden or disabled as well. This cascading behavior simplifies state management across complex interfaces.</li>
<li><strong>Relative Positioning</strong>: Child elements can be positioned relative to their parents rather than relative to the screen.  This means you can place elements within a contain and then move the entire container as a unit without having to update ach child's position individually.</li>
<li><strong>Simplified State Management</strong>:  Actions on parent elements can automatically propagate to their children.  For example, disabling a menu panel can automatically disable all buttons within it, preventing interaction with elements that should be active.</li>
<li><strong>Batch Operations</strong>: Operations like drawing and updating can be performed on a parent element and automatically cascade to all children, reducing the need for repetitive code.</li>
<li><strong>Logical Grouping</strong>: The hierarchy naturally models the conceptual grouping of UI elements, making the code structure more intuitive and easier to maintain.</li>
</ul>
<h2 id="creating-a-ui-system">Creating a UI System</h2>
<p>With an understanding of the core concepts behind game user interfaces, let's build our own UI system for MonoGame.  We'll implement a set of reusable classes that can be extended and combined to create various UI elements for our game.</p>
<p>Our UI system will consist of the following key components:</p>
<ol>
<li><code>UIElement</code>: The base class that handles the parent-child relationship, positioning, visibility, and enabled states.</li>
<li><code>UISprite</code>: Extends the <code>UIElement</code> to include visual representation using our existing <code>Sprite</code> class.</li>
<li><code>UIButton</code>: Extends <code>UIElement</code> to provide interactive buttons with different visual states for normal and selected.</li>
<li><code>UISlider</code>: Extends <code>UIElement</code> to implement adjustable controls for values like volume.</li>
<li><code>IUIElementController</code>: An interface for handling UI navigation through different input devices.</li>
</ol>
<p>This hierarchical design allows each class to focus on a specific aspect of UI functionality while building on the capabilities of its parent class.</p>
<h3 id="the-uielement-class">The UIElement Class</h3>
<p>In this section, we'll create the <code>UIElement</code> class, which will be the foundation of our UI system.  This class will handle the core functionality that all UI components need, including:</p>
<ul>
<li><strong>Parent-Child Relationships</strong>: UI elements can be nested, allowing for logical grouping and relative positioning.</li>
<li><strong>Positioning</strong>: Elements track their relative and absolute positions, enabling flexibility in layout design.</li>
<li><strong>Visibility and Interaction States</strong>: Elements can be enabled, disabled, shown, or hidden, with state inheritance from parent elements.</li>
<li><strong>Navigation Handling</strong>: Actions for directional input (up, down, left, right) and menu commands (confirm, cancel) allow for structured UI navigation.</li>
</ul>
<h4 id="creating-the-uielementcs-file">Creating the <code>UIElement.cs</code> File</h4>
<p>First, in the <em>MonoGameLibrary</em> project, create a new directory named <em>UI</em>, then create a new class file named <em>UIElement.cs</em> inside that directory.  We'll use this <em>UI</em> directory to keep our UI-related classes organized.</p>
<p>Open the the <em>UIElement.cs</em> class file you just created and and add the following code:</p>
<pre><code class="lang-csharp">using System;
using System.Collections;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameLibrary.UI;

/// &lt;summary&gt;
/// Base class for all UI elements, providing hierarchy, input handling, and common properties.
/// UIElement can contain child elements to create complex UI structures.
/// &lt;/summary&gt;
public class UIElement : IEnumerable&lt;UIElement&gt;
{
    private List&lt;UIElement&gt; _children;
    private bool _isEnabled;
    private bool _isVisible;
    private bool _isSelected;
    private bool _wasSelectedThisFrame;
    private Color _enabledColor;
    private Color _disabledColor;

    /// &lt;summary&gt;
    /// Gets the parent element of this UI element, if one exists.
    /// &lt;/summary&gt;
    public UIElement Parent { get; private set; }

    /// &lt;summary&gt;
    /// Gets or sets the position of this element relative to its parent.
    /// &lt;/summary&gt;
    public Vector2 Position { get; set; }

    /// &lt;summary&gt;
    /// Gets the absolute position of this element in screen space,
    /// calculated by combining this element's position with its parent's absolute position.
    /// &lt;/summary&gt;
    public Vector2 AbsolutePosition
    {
        get
        {
            if (Parent is UIElement parent)
            {
                return parent.AbsolutePosition + Position;
            }

            return Position;
        }
    }

    /// &lt;summary&gt;
    /// Gets or sets whether this element can receive input and perform actions.
    /// An element is only enabled if both it and all its parents are enabled.
    /// &lt;/summary&gt;
    public bool IsEnabled
    {
        get
        {
            if (Parent is UIElement parent &amp;&amp; !parent.IsEnabled)
            {
                return false;
            }

            return _isEnabled;

        }
        set =&gt; _isEnabled = value;
    }

    /// &lt;summary&gt;
    /// Gets or sets whether this element is visible.
    /// An element is only visible if both it and all its parents are visible.
    /// &lt;/summary&gt;
    public bool IsVisible
    {
        get
        {
            if (Parent is UIElement parent &amp;&amp; !parent.IsVisible)
            {
                return false;
            }

            return _isVisible;
        }
        set =&gt; _isVisible = value;
    }

    /// &lt;summary&gt;
    /// Gets or sets whether this element is currently selected to receive input.
    /// &lt;/summary&gt;
    public bool IsSelected
    {
        get =&gt; _isSelected;
        set
        {
            _isSelected = value;
            _wasSelectedThisFrame = value;
        }
    }

    /// &lt;summary&gt;
    /// Gets or sets the color used when the element is enabled.
    /// If not explicitly set, inherits from parent element.
    /// &lt;/summary&gt;
    public Color EnabledColor
    {
        get
        {
            if (Parent is UIElement parent)
            {
                return parent.EnabledColor;
            }

            return _enabledColor;
        }
        set =&gt; _enabledColor = value;
    }

    /// &lt;summary&gt;
    /// Gets or sets the color used when the element is disabled.
    /// If not explicitly set, inherits from parent element.
    /// &lt;/summary&gt;
    public Color DisabledColor
    {
        get
        {
            if (Parent is UIElement parent)
            {
                return parent.DisabledColor;
            }

            return _disabledColor;
        }
        set =&gt; _disabledColor = value;
    }

    /// &lt;summary&gt;
    /// Gets or sets the controller that handles navigation input for this element.
    /// &lt;/summary&gt;
    public IUIElementController Controller { get; set; }

    /// &lt;summary&gt;
    /// Action performed when navigating up from this element.
    /// &lt;/summary&gt;
    public Action UpAction { get; set; }

    /// &lt;summary&gt;
    /// Action performed when navigating down from this element.
    /// &lt;/summary&gt;
    public Action DownAction { get; set; }

    /// &lt;summary&gt;
    /// Action performed when navigating left from this element.
    /// &lt;/summary&gt;
    public Action LeftAction { get; set; }

    /// &lt;summary&gt;
    /// Action performed when navigating right from this element.
    /// &lt;/summary&gt;
    public Action RightAction { get; set; }

    /// &lt;summary&gt;
    /// Action performed when confirming a selection on this element.
    /// &lt;/summary&gt;
    public Action ConfirmAction { get; set; }

    /// &lt;summary&gt;
    /// Action performed when canceling from this element.
    /// &lt;/summary&gt;
    public Action CancelAction { get; set; }

    /// &lt;summary&gt;
    /// Initializes a new instance of the UIElement class.
    /// &lt;/summary&gt;
    public UIElement()
    {
        _children = new List&lt;UIElement&gt;();
        IsEnabled = true;
        IsVisible = true;
        EnabledColor = Color.White;
        DisabledColor = Color.White;
    }

    /// &lt;summary&gt;
    /// Creates and adds a child UI element of the specified type.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;Type of UI element to create, must derive from UIElement.&lt;/typeparam&gt;
    /// &lt;returns&gt;The newly created child element.&lt;/returns&gt;
    public T CreateChild&lt;T&gt;() where T : UIElement, new()
    {
        T child = new T();
        _children.Add(child);
        child.Parent = this;
        return child;
    }

    /// &lt;summary&gt;
    /// Updates this element and all its children.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;gameTime&quot;&gt;Time elapsed since the last update.&lt;/param&gt;
    public virtual void Update(GameTime gameTime)
    {
        if (!IsEnabled)
        {
            return;
        }

        // Handle navigation only if the element is selected but wasn't just selected this frame
        if (IsSelected &amp;&amp; Controller != null &amp;&amp; !_wasSelectedThisFrame)
        {
            HandleNavigation();
        }

        _wasSelectedThisFrame = false;

        // Update all child elements
        foreach (UIElement child in _children)
        {
            child.Update(gameTime);
        }
    }

    /// &lt;summary&gt;
    /// Processes navigation input and invokes appropriate actions.
    /// &lt;/summary&gt;
    private void HandleNavigation()
    {
        if (Controller.NavigateUp() &amp;&amp; UpAction != null)
        {
            UpAction();
        }
        else if (Controller.NavigateDown() &amp;&amp; DownAction != null)
        {
            DownAction();
        }
        else if (Controller.NavigateLeft() &amp;&amp; LeftAction != null)
        {
            LeftAction();
        }
        else if (Controller.NavigateRight() &amp;&amp; RightAction != null)
        {
            RightAction();
        }
        else if (Controller.Confirm() &amp;&amp; ConfirmAction != null)
        {
            ConfirmAction();
        }
        else if (Controller.Cancel() &amp;&amp; CancelAction != null)
        {
            CancelAction();
        }
    }

    /// &lt;summary&gt;
    /// Draws this element and all its children.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
    public virtual void Draw(SpriteBatch spriteBatch)
    {
        foreach (UIElement child in _children)
        {
            child.Draw(spriteBatch);
        }
    }

    /// &lt;summary&gt;
    /// Returns an enumerator that iterates through the child elements.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;An enumerator of child UI elements.&lt;/returns&gt;
    public IEnumerator&lt;UIElement&gt; GetEnumerator() =&gt; _children.GetEnumerator();

    /// &lt;summary&gt;
    /// Implements the non-generic IEnumerable interface.
    /// &lt;/summary&gt;
    IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>UIElement</code> class implements the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=net-9.0"><code>IEnumerable&lt;T&gt;</code></a> interface.  Using this interface provides an enumerator for the <code>UIElement</code> class that we can use to iterate each of the child elements without directly exposing the internal collection.</p>
</div>
<h4 id="understanding-the-uielement-class">Understanding the UIElement Class</h4>
<p>Let's break down each part of the class so that it is clear how everything works.</p>
<h5 id="fields">Fields</h5>
<p>The following fields store the internal state of the UI element</p>
<pre><code class="lang-csharp">private List&lt;UIElement&gt; _children;
private bool _isEnabled;
private bool _isVisible;
private bool _isSelected;
private bool _wasSelectedThisFrame;
private Color _enabledColor;
private Color _disabledColor;
</code></pre>
<ul>
<li><code>_isEnabled</code> determines whether the element should be updated.</li>
<li><code>_isVisible</code> determines whether the element should be drawn to the screen.</li>
<li><code>_isSelected</code> tracks whether the element is currently selected.</li>
<li><code>_wasSelectedThisFrame</code> tracks whether the element was just selected during the current update frame.  This is to help with input debouncing.</li>
<li><code>_enabledColor</code> is the color tint that should be applied when the element is drawn while it is enabled.</li>
<li><code>_disabledColor</code> is the color tint that should be applied when the element is drawn while it is disabled.</li>
</ul>
<h5 id="properties">Properties</h5>
<p>The first property is the <code>Parent</code> property.  This stores a reference to the parent UI element, if there is one.</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the parent element of this UI element, if one exists.
/// &lt;/summary&gt;
public UIElement Parent { get; private set; }
</code></pre>
<p>Next are the positioning properties</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or sets the position of this element relative to its parent.
/// &lt;/summary&gt;
public Vector2 Position { get; set; }

/// &lt;summary&gt;
/// Gets the absolute position of this element in screen space,
/// calculated by combining this element's position with its parent's absolute position.
/// &lt;/summary&gt;
public Vector2 AbsolutePosition
{
    get
    {
        if (Parent is UIElement parent)
        {
            return parent.AbsolutePosition + Position;
        }

        return Position;
    }
}
</code></pre>
<ul>
<li><code>Position</code> is the local position of the UI element relative to its parent.  If it has no parent, then this is the position relative to the screen.</li>
<li><code>AbsolutePosition</code> calculates the absolute position of the UI element to be drawn at by adding the absolute position of the parent element to the relative position of the element.</li>
</ul>
<p>Following these are the state tracking properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or sets whether this element can receive input and perform actions.
/// An element is only enabled if both it and all its parents are enabled.
/// &lt;/summary&gt;
public bool IsEnabled
{
    get
    {
        if (Parent is UIElement parent &amp;&amp; !parent.IsEnabled)
        {
            return false;
        }

        return _isEnabled;

    }
    set =&gt; _isEnabled = value;
}

/// &lt;summary&gt;
/// Gets or sets whether this element is visible.
/// An element is only visible if both it and all its parents are visible.
/// &lt;/summary&gt;
public bool IsVisible
{
    get
    {
        if (Parent is UIElement parent &amp;&amp; !parent.IsVisible)
        {
            return false;
        }

        return _isVisible;
    }
    set =&gt; _isVisible = value;
}

/// &lt;summary&gt;
/// Gets or sets whether this element is currently selected to receive input.
/// &lt;/summary&gt;
public bool IsSelected
{
    get =&gt; _isSelected;
    set
    {
        _isSelected = value;
        _wasSelectedThisFrame = value;
    }
}
</code></pre>
<ul>
<li><code>IsEnabled</code> first checks to see if the element has a parent element.  If it does, and that parent element is disabled, then the element is automatically considered disabled.  Otherwise, it just returns back the internal <code>_isEnabled</code> state of the element.</li>
<li><code>IsVisible</code> performs the same check that <code>IsEnabled</code> does to determine if the element is visible.</li>
<li><code>IsSelected</code> simply returns the internal <code>_isSelected</code> state of the element, however when setting the value, the <code>_wasSelectedThisFrame</code> field is flipped to true.</li>
</ul>
<p>Up next are the color properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or sets the color used when the element is enabled.
/// If not explicitly set, inherits from parent element.
/// &lt;/summary&gt;
public Color EnabledColor
{
    get
    {
        if (Parent is UIElement parent)
        {
            return parent.EnabledColor;
        }

        return _enabledColor;
    }
    set =&gt; _enabledColor = value;
}

/// &lt;summary&gt;
/// Gets or sets the color used when the element is disabled.
/// If not explicitly set, inherits from parent element.
/// &lt;/summary&gt;
public Color DisabledColor
{
    get
    {
        if (Parent is UIElement parent)
        {
            return parent.DisabledColor;
        }

        return _disabledColor;
    }
    set =&gt; _disabledColor = value;
}
</code></pre>
<ul>
<li><code>EnabledColor</code> first checks to see if the element has a parent element.  If it does, it returns back the enabled color of the parent element in order to maintain visual consistency with grouped elements.  If it does not, then the elements internal <code>_enabledColor</code> is returned.</li>
<li><code>DisabledColor</code> performs the the same check that <code>EnabledColor</code> does for the disabled color of the element.</li>
</ul>
<p>Finally there is the navigation properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or sets the controller that handles navigation input for this element.
/// &lt;/summary&gt;
public IUIElementController Controller { get; set; }

/// &lt;summary&gt;
/// Action performed when navigating up from this element.
/// &lt;/summary&gt;
public Action UpAction { get; set; }

/// &lt;summary&gt;
/// Action performed when navigating down from this element.
/// &lt;/summary&gt;
public Action DownAction { get; set; }

/// &lt;summary&gt;
/// Action performed when navigating left from this element.
/// &lt;/summary&gt;
public Action LeftAction { get; set; }

/// &lt;summary&gt;
/// Action performed when navigating right from this element.
/// &lt;/summary&gt;
public Action RightAction { get; set; }

/// &lt;summary&gt;
/// Action performed when confirming a selection on this element.
/// &lt;/summary&gt;
public Action ConfirmAction { get; set; }

/// &lt;summary&gt;
/// Action performed when canceling from this element.
/// &lt;/summary&gt;
public Action CancelAction { get; set; }
</code></pre>
<ul>
<li><code>Controller</code> stores a reference to the <code>IUIElementController</code> instance that is used to determine when actions are performed on this element such as navigating up, down, left, or right, or performing a confirm or cancel action.  By using this interface, which we'll create in a moment, it allows us to create an device agnostic method of navigation for UI elements.</li>
<li><code>UpAction</code>, <code>DownAction</code>, <code>LeftAction</code>, <code>RightAction</code>, <code>ConfirmAction</code>, and <code>CancelAction</code> actions that are invoked when the element is selected and the controller detects that one of those actions has occurred.  We can use these to provide navigational logic to the elements when they are created.</li>
</ul>
<h5 id="constructor">Constructor</h5>
<p>The constructor simply creates a new instance of the UI element and sets the defaults for the properties</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Initializes a new instance of the UIElement class.
/// &lt;/summary&gt;
public UIElement()
{
    _children = new List&lt;UIElement&gt;();
    IsEnabled = true;
    IsVisible = true;
    EnabledColor = Color.White;
    DisabledColor = Color.White;
}
</code></pre><h5 id="methods">Methods</h5>
<p>First is the <code>CreateChild&lt;T&gt;</code> method method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates and adds a child UI element of the specified type.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;Type of UI element to create, must derive from UIElement.&lt;/typeparam&gt;
/// &lt;returns&gt;The newly created child element.&lt;/returns&gt;
public T CreateChild&lt;T&gt;() where T : UIElement, new()
{
    T child = new T();
    _children.Add(child);
    child.Parent = this;
    return child;
}
</code></pre>
<p>This is a generic method where the type <code>T</code> has to be defined when it is called and has a constraint that the type of <code>T</code> must be a <code>UIElement</code> and also must contain a default parameterless constructor.  It then creates a new instance of that type, adds it to the child collection of the UI element, sets the parent of the child to the UI element, then returns the child created back so that further configurations can be done on it.</p>
<p>Next is the <code>Update</code> and <code>HandleNavigation</code> methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates this element and all its children.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;Time elapsed since the last update.&lt;/param&gt;
public virtual void Update(GameTime gameTime)
{
    if (!IsEnabled)
    {
        return;
    }

    // Handle navigation only if the element is selected but wasn't just selected this frame
    if (IsSelected &amp;&amp; Controller != null &amp;&amp; !_wasSelectedThisFrame)
    {
        HandleNavigation();
    }

    _wasSelectedThisFrame = false;

    // Update all child elements
    foreach (UIElement child in _children)
    {
        child.Update(gameTime);
    }
}

/// &lt;summary&gt;
/// Processes navigation input and invokes appropriate actions.
/// &lt;/summary&gt;
private void HandleNavigation()
{
    if (Controller.NavigateUp() &amp;&amp; UpAction != null)
    {
        UpAction();
    }
    else if (Controller.NavigateDown() &amp;&amp; DownAction != null)
    {
        DownAction();
    }
    else if (Controller.NavigateLeft() &amp;&amp; LeftAction != null)
    {
        LeftAction();
    }
    else if (Controller.NavigateRight() &amp;&amp; RightAction != null)
    {
        RightAction();
    }
    else if (Controller.Confirm() &amp;&amp; ConfirmAction != null)
    {
        ConfirmAction();
    }
    else if (Controller.Cancel() &amp;&amp; CancelAction != null)
    {
        CancelAction();
    }
}
</code></pre>
<p>The <code>Update</code> method:</p>
<ol>
<li>First checks to see if the element is enabled.  If it is not, it short circuits the method and returns back early since a disabled element should not be updated.</li>
<li>Next, it determines if the element is selected, has a controller, and was not just selected on the current frame. If this is all true, then <code>HandleNavigation</code> is called.</li>
<li>Finally, it iterates through all child elements and calls <code>Update</code> on them.</li>
</ol>
<p>The <code>HandleNavigation</code> method makes a check for each of the controller navigation methods, and if they are true, invokes the appropriate action.</p>
<p>After these is the <code>Draw</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Draws this element and all its children.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
public virtual void Draw(SpriteBatch spriteBatch)
{
    foreach (UIElement child in _children)
    {
        child.Draw(spriteBatch);
    }
}
</code></pre>
<p>Similar to <code>Update</code>, the <code>Draw</code> method first makes a check to see if the element is visible. If it is not, it short circuits the method and returns back early since non-visible elements should not be drawn.  After this, it iterates through each of the child elements and calls <code>Draw</code> on them.</p>
<p>Finally, are the methods for implementing the <code>IEnumerable&lt;T&gt;</code> interface:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns an enumerator that iterates through the child elements.
/// &lt;/summary&gt;
/// &lt;returns&gt;An enumerator of child UI elements.&lt;/returns&gt;
public IEnumerator&lt;UIElement&gt; GetEnumerator() =&gt; _children.GetEnumerator();

/// &lt;summary&gt;
/// Implements the non-generic IEnumerable interface.
/// &lt;/summary&gt;
IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
</code></pre>
<p>These methods just return the enumerator for the internal list of children for the element.</p>
<h3 id="the-iuielementcontroller-interface">The IUIElementController Interface</h3>
<p>Before we move on to creating implementations of the <code>UIElement</code> class, we need to create the <code>IUIElementController</code> interface that is used.  This interface provides a device agnostic method of creating navigational controls for the UI elements which we'll explore more in moment when we start implementing the UI in our game.  For now, in the <em>UI</em> directory of the <em>MonoGameLibrary</em> project, create a new file named <em>IUIElementController.cs</em> and add the following code:</p>
<pre><code class="lang-csharp">namespace MonoGameLibrary.UI;

/// &lt;summary&gt;
/// Interface for handling UI element navigation through various input sources.
/// Implement this to create custom controllers for keyboard, gamepad, or other input methods.
/// &lt;/summary&gt;
public interface IUIElementController
{
    /// &lt;summary&gt;
    /// Determines if the user has attempted to navigate upward in the UI.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;True if upward navigation was triggered; otherwise, false.&lt;/returns&gt;
    bool NavigateUp();

    /// &lt;summary&gt;
    /// Determines if the user has attempted to navigate downward in the UI.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;True if downward navigation was triggered; otherwise, false.&lt;/returns&gt;
    bool NavigateDown();

    /// &lt;summary&gt;
    /// Determines if the user has attempted to navigate left in the UI.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;True if leftward navigation was triggered; otherwise, false.&lt;/returns&gt;
    bool NavigateLeft();

    /// &lt;summary&gt;
    /// Determines if the user has attempted to navigate right in the UI.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;True if rightward navigation was triggered; otherwise, false.&lt;/returns&gt;
    bool NavigateRight();

    /// &lt;summary&gt;
    /// Determines if the user has triggered a confirmation action on the current UI element.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;True if confirmation was triggered; otherwise, false.&lt;/returns&gt;
    bool Confirm();

    /// &lt;summary&gt;
    /// Determines if the user has triggered a cancellation action on the current UI element.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;True if cancellation was triggered; otherwise, false.&lt;/returns&gt;
    bool Cancel();
}
</code></pre>
<p>The interface defines the following methods:</p>
<ul>
<li><code>NavigateUp</code>:</li>
<li><code>NavigateDown</code>:</li>
<li><code>NavigateLeft</code>:</li>
<li><code>NavigateRight:</code></li>
<li><code>Confirm</code>:</li>
<li><code>Cancel</code>:</li>
</ul>
<p>For example, if we wanted to implement a controller that uses the arrow keys on the keyboard for directional navigation, the enter key for confirm, and the escape key for cancel, it would look something like the following:`</p>
<pre><code class="lang-cs">public class UIElementController : IUIElementController
{
    private KeyboardInfo _keyboard;

    public UIElementController() =&gt; _keyboard = Core.Input.Keyboard;

    public bool NavigateUp() =&gt; _keyboard.WasKeyJustPressed(Keys.Up);
    public bool NavigateDown() =&gt; _keyboard.WasKeyJustPressed(Keys.Down);
    public bool NavigateLeft() =&gt; _keyboard.WasKeyJustPressed(Keys.Left);
    public bool NavigateRight() =&gt; _keyboard.WasKeyJustPressed(Keys.Right);
    public bool Confirm() =&gt; _keyboard.WasKeyJustPressed(Keys.Enter);
    public bool Cancel() =&gt; _keyboard.WasKeyJustPressed(Keys.Escape);
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>This is just an example, we'll create a more complete implementation of this for our game later in this chapter.</p>
</div>
<h3 id="the-uisprite-class">The UISprite Class</h3>
<p>With the base <code>UIElement</code> class and the <code>IUIElementController</code> interface, we can start implementing types that extend the <code>UIElement</code> class to provide specific functionality.  In this section we'll create the <code>UISprite</code> class.  This class is a UI element that draw an image to the screen using the <code>Sprite</code> class we created earlier.  This can be used for various UI element such as labels, panels, and even text.</p>
<p>This can be used for various UI elements such as labels, panels, and even static text.</p>
<div class="TIP">
<h5>Tip</h5>
<p>For text that never changes in your UI (like menu titles or button labels), consider &quot;baking&quot; it into your texture atlas rather than rendering it with the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> and a <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a>. As we learned in <a href="../16_working_with_spritefonts/index.html#understanding-spritefonts">Chapter 16</a>, MonoGame converts fonts into texture atlases. When drawing text with a <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a>, the renderer must switch from your texture atlas to the font texture atlas, causing a texture swap as explained in <a href="../07_optimizing_texture_rendering/index.html#texture-swapping">Chapter 07</a>. Including static text directly in your texture atlas eliminates these swaps, improving rendering performance.</p>
<p>Of course, this approach only works for fixed text. For dynamic content like scores or timer displays, you'll still need to use <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteFont"><strong>SpriteFont</strong></a> for rendering.</p>
</div>
<p>The first one we'll create is the <code>UISprite</code> class. This class will be a UI element that draws an image to the screen using the <code>Sprite</code> class we created in <a href="../08_the_sprite_class/index.html#the-sprite-class">Chapter 08</a>.</p>
<h4 id="creating-the-uispritecs-file">Creating the <code>UISprite.cs</code> File</h4>
<p>In the <em>UI</em> directory of the <em>MonoGameLibrary</em> project, create a new class file named <em>UISprite.cs</em>.  Open the <em>UISprite.cs</em> file you just created and add the following code:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MonoGameLibrary.Graphics;

namespace MonoGameLibrary.UI;

/// &lt;summary&gt;
/// A simple UI element that displays a sprite.
/// Useful for static elements like icons, backgrounds, and decorations.
/// &lt;/summary&gt;
public class UISprite : UIElement
{
    /// &lt;summary&gt;
    /// Gets or sets the sprite to display.
    /// &lt;/summary&gt;
    public Sprite Sprite { get; set; }

    /// &lt;summary&gt;
    /// Updates the sprite, handling animation if the sprite is animated.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;gameTime&quot;&gt;Time elapsed since the last update.&lt;/param&gt;
    public override void Update(GameTime gameTime)
    {
        if (!IsEnabled)
        {
            return;
        }

        // Update animation if the sprite is an animated sprite
        if (Sprite is AnimatedSprite animatedSprite)
        {
            animatedSprite.Update(gameTime);
        }

        base.Update(gameTime);
    }

    /// &lt;summary&gt;
    /// Draws the sprite with the appropriate color based on enabled state.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
    public override void Draw(SpriteBatch spriteBatch)
    {
        if (!IsVisible)
        {
            return;
        }

        if (Sprite != null)
        {
            // Apply enabled/disabled color to the sprite
            Sprite.Color = IsEnabled ? EnabledColor : DisabledColor;
            Sprite.Draw(spriteBatch, AbsolutePosition);
        }

        base.Draw(spriteBatch);
    }
}
</code></pre><h4 id="understanding-the-uisprite-class">Understanding the UISprite Class</h4>
<p>Let's examine how this class works by breaking down its main components.</p>
<h5 id="properties-1">Properties</h5>
<p>The <code>UISprite</code> class has a single property:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or sets the sprite to display.
/// &lt;/summary&gt;
public Sprite Sprite { get; set; }
</code></pre>
<p>This property stores a reference to the <code>Sprite</code> that is drawn when this element is draw to visually represent it.</p>
<h5 id="methods-1">Methods</h5>
<p>The <code>UISprite</code> class overrides both the <code>Update</code> and the <code>Draw</code> methods from the base <code>UIElement</code> class.</p>
<p>First, the <code>Update</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the sprite, handling animation if the sprite is animated.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;Time elapsed since the last update.&lt;/param&gt;
public override void Update(GameTime gameTime)
{
    if (!IsEnabled)
    {
        return;
    }

    // Update animation if the sprite is an animated sprite
    if (Sprite is AnimatedSprite animatedSprite)
    {
        animatedSprite.Update(gameTime);
    }

    base.Update(gameTime);
}

/// &lt;summary&gt;
/// Draws the sprite with the appropriate color based on enabled state.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
public override void Draw(SpriteBatch spriteBatch)
{
    if (!IsVisible)
    {
        return;
    }

    if (Sprite != null)
    {
        // Apply enabled/disabled color to the sprite
        Sprite.Color = IsEnabled ? EnabledColor : DisabledColor;
        Sprite.Draw(spriteBatch, AbsolutePosition);
    }

    base.Draw(spriteBatch);
}
</code></pre>
<p>The <code>Update</code> method:</p>
<ol>
<li>First checks if the element is enabled.  If not, it returns early without performing any updates.</li>
<li>Checks if the <code>Sprite</code> to draw is actually an <code>AnimatedSprite</code> instance, and if so, updates it.</li>
<li>Finally, it calls the base <code>Update</code> method to handle updating for navigation and updating any child elements.</li>
</ol>
<p>Next, the <code>Draw</code> method:</p>
<ol>
<li>First checks if the element is visible.  If not, it returns early without drawing anything.</li>
<li>If the element has a sprite assigned, it sets the sprite's <code>Color</code> property value based on whether the element is enabled or disabled.</li>
<li>It then draws the sprite at the elements <code>AbsolutePosition</code>.</li>
<li>Finally, it calls the base <code>Draw</code> method to draw any child elements.</li>
</ol>
<h3 id="the-uibutton-class">The UIButton Class</h3>
<p>Next up is the <code>UIButton</code> class.  Unlike the <code>UISprite</code> class that has only one visual representation, the <code>UIButton</code> class maintains two different sprites:</p>
<ol>
<li>One for when the button is in its normal, unselected state.</li>
<li>Another for when the button is selected (focused by the user).</li>
</ol>
<p>This visual feedback helps players understand which button is currently selected in the menu navigation, creating a more intuitive user experience.</p>
<h4 id="creating-the-uibuttoncs-file">Creating the <code>UIButton.cs</code> File</h4>
<p>In the <em>UI</em> directory of the <em>MonoGameLibrary</em> project, create a new class file named <em>UIButton.cs</em>. Open this file and add the following code:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MonoGameLibrary.Graphics;

namespace MonoGameLibrary.UI;

/// &lt;summary&gt;
/// A UI element that represents a button with different visual states
/// for selected and non-selected states.
/// &lt;/summary&gt;
public class UIButton : UIElement
{
    /// &lt;summary&gt;
    /// Gets or sets the sprite used when the button is not selected.
    /// &lt;/summary&gt;
    public Sprite NotSelectedSprite { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the sprite used when the button is selected.
    /// &lt;/summary&gt;
    public Sprite SelectedSprite { get; set; }

    /// &lt;summary&gt;
    /// Updates the button's state and animations.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;gameTime&quot;&gt;Time elapsed since the last update.&lt;/param&gt;
    public override void Update(GameTime gameTime)
    {
        // Update animations if sprites are animated
        if (NotSelectedSprite is AnimatedSprite notSelectedSprite)
        {
            notSelectedSprite.Update(gameTime);
        }

        if (SelectedSprite is AnimatedSprite selectedSprite)
        {
            selectedSprite.Update(gameTime);
        }

        base.Update(gameTime);
    }

    /// &lt;summary&gt;
    /// Draws the appropriate button sprite based on selection state.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
    public override void Draw(SpriteBatch spriteBatch)
    {
        if (!IsVisible)
        {
            return;
        }

        // Draw different sprites based on selection state
        if (IsSelected)
        {
            SelectedSprite.Color = IsEnabled ? EnabledColor : DisabledColor;
            SelectedSprite.Draw(spriteBatch, AbsolutePosition);
        }
        else
        {
            NotSelectedSprite.Color = IsEnabled ? EnabledColor : DisabledColor;
            NotSelectedSprite.Draw(spriteBatch, AbsolutePosition);
        }

        base.Draw(spriteBatch);
    }
}
</code></pre><h4 id="understanding-the-uibutton-class">Understanding the UIButton Class</h4>
<p>Let's break down how this class works to better understand its functionality.</p>
<h5 id="properties-2">Properties</h5>
<p>The <code>UIButton</code> class has two important properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or sets the sprite used when the button is not selected.
/// &lt;/summary&gt;
public Sprite NotSelectedSprite { get; set; }

/// &lt;summary&gt;
/// Gets or sets the sprite used when the button is selected.
/// &lt;/summary&gt;
public Sprite SelectedSprite { get; set; }
</code></pre>
<ul>
<li><code>NotSelectedSprite</code>: The sprite to display when the button is not selected (the button's default appearance).</li>
<li><code>SelectedSprite</code>: The sprite to display when the button is selected (the highlighted appearance when the button has focus).</li>
</ul>
<h5 id="methods-2">Methods</h5>
<p>The <code>UIButton</code> class overrides the <code>Update</code> and <code>Draw</code> methods from the base <code>UIElement</code> class.</p>
<p>First, let's look at the <code>Update</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the button's state and animations.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;Time elapsed since the last update.&lt;/param&gt;
public override void Update(GameTime gameTime)
{
    // Update animations if sprites are animated
    if (NotSelectedSprite is AnimatedSprite notSelectedSprite)
    {
        notSelectedSprite.Update(gameTime);
    }

    if (SelectedSprite is AnimatedSprite selectedSprite)
    {
        selectedSprite.Update(gameTime);
    }

    base.Update(gameTime);
}

/// &lt;summary&gt;
/// Draws the appropriate button sprite based on selection state.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
public override void Draw(SpriteBatch spriteBatch)
{
    if (!IsVisible)
    {
        return;
    }

    // Draw different sprites based on selection state
    if (IsSelected)
    {
        SelectedSprite.Color = IsEnabled ? EnabledColor : DisabledColor;
        SelectedSprite.Draw(spriteBatch, AbsolutePosition);
    }
    else
    {
        NotSelectedSprite.Color = IsEnabled ? EnabledColor : DisabledColor;
        NotSelectedSprite.Draw(spriteBatch, AbsolutePosition);
    }

    base.Draw(spriteBatch);
}
</code></pre>
<p>The <code>Update</code> method handles both sprites:</p>
<ol>
<li>It checks if the <code>NotSelectedSprite</code> is an <code>AnimatedSprite</code>, and if so, updates its animation.</li>
<li>Similarly, it checks if the <code>SelectedSprite</code> is an <code>AnimatedSprite</code>, and updates it as well.</li>
<li>Finally, it calls the base <code>Update</code> method to update any child elements.</li>
</ol>
<p>This ensures that both sprites continue to animate when appropriate, regardless of which one is currently being displayed.</p>
<p>Next, let's examine the <code>Draw</code> method:</p>
<pre><code class="lang-csharp">public override void Update(GameTime gameTime)
{
    // Update animations if sprites are animated
    if (NotSelectedSprite is AnimatedSprite notSelectedSprite)
    {
        notSelectedSprite.Update(gameTime);
    }

    if (SelectedSprite is AnimatedSprite selectedSprite)
    {
        selectedSprite.Update(gameTime);
    }

    base.Update(gameTime);
}

/// &lt;summary&gt;
/// Draws the appropriate button sprite based on selection state.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
</code></pre>
<p>The <code>Draw</code> method:</p>
<ol>
<li>First checks if the button is visible. If not, it returns early without drawing anything.</li>
<li>If the button is selected (has focus), it:
<ul>
<li>Sets the <code>SelectedSprite</code> color based on whether the button is enabled or disabled.</li>
<li>Draws the <code>SelectedSprite</code> at the button's absolute position.</li>
</ul>
</li>
<li>If the button is not selected, it:
<ul>
<li>Sets the <code>NotSelectedSprite</code> color based on whether the button is enabled or disabled.</li>
<li>Draws the <code>NotSelectedSprite</code> at the button's absolute position.</li>
</ul>
</li>
<li>Finally, it calls the base <code>Draw</code> method to draw any child elements.</li>
</ol>
<p>The <code>UIButton</code> class is particularly useful for menu systems where players need to navigate between options. By leveraging the action properties from the <code>UIElement</code> base class (like <code>ConfirmAction</code>), buttons can react to player input in a consistent way across different input devices.</p>
<p>For example, a button might change the current scene when selected and confirmed:</p>
<pre><code class="lang-cs">UIButton startButton = menuElement.CreateChild&lt;UIButton&gt;();

// When this button is selected and the confirm action is triggered,
// change to the game scene
menu.ConfirmAction = () =&gt;
{
    if (startButton.IsSelected)
    {
        Core.ChangeScene(new GameScene());
    }
};
</code></pre>
<h3 id="the-uislider-class">The UISlider Class</h3>
<p>The next component in our UI system is the <code>UISlider</code> class. Unlike buttons that are either selected or not, sliders represent a continuous range of values that can be adjusted. These are perfect for volume controls, brightness settings, or any parameter that needs gradual adjustment.</p>
<h4 id="creating-the-uislidercs-file">Creating the <code>UISlider.cs</code> File</h4>
<p>In the <em>UI</em> directory of the <em>MonoGameLibrary</em> project, create a new class file named <em>UISlider.cs</em>. Open this file and add the following code:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MonoGameLibrary.Graphics;

namespace MonoGameLibrary.UI;

/// &lt;summary&gt;
/// A UI element that represents a slider control with adjustable value
/// that can be increased or decreased in steps.
/// &lt;/summary&gt;
public class UISlider : UIElement
{
    /// &lt;summary&gt;
    /// Gets or sets the background sprite for the slider.
    /// &lt;/summary&gt;
    public Sprite SliderSprite { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the sprite used for the fill bar that represents the current value.
    /// &lt;/summary&gt;
    public Sprite FillSprite { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the rectangle that defines the position and size of the fill area
    /// relative to the slider's position.
    /// &lt;/summary&gt;
    public Rectangle FillBounds { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the minimum value of the slider.
    /// &lt;/summary&gt;
    public float MinValue { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the maximum value of the slider.
    /// &lt;/summary&gt;
    public float MaxValue { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the current value of the slider.
    /// &lt;/summary&gt;
    public float Value { get; set; }

    /// &lt;summary&gt;
    /// Gets or sets the amount to change the value by when stepping up or down.
    /// &lt;/summary&gt;
    public float Step { get; set; }

    /// &lt;summary&gt;
    /// Increases the slider value by one step, clamped to the maximum.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;The new value after stepping up.&lt;/returns&gt;
    public float StepUp()
    {
        Value = Math.Clamp(Value + Step, MinValue, MaxValue);
        return Value;
    }

    /// &lt;summary&gt;
    /// Decreases the slider value by one step, clamped to the minimum.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;The new value after stepping down.&lt;/returns&gt;
    public float StepDown()
    {
        Value = Math.Clamp(Value - Step, MinValue, MaxValue);
        return Value;
    }

    /// &lt;summary&gt;
    /// Draws the slider with the fill representing the current value.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
    public override void Draw(SpriteBatch spriteBatch)
    {
        // Calculate the position of the fill sprite relative to the slider
        Vector2 fillSpritePosition = AbsolutePosition + FillBounds.Location.ToVector2();

        // Calculate the fill percentage based on the current value
        float percentage = (Value - MinValue) / (MaxValue - MinValue);
        // Scale the fill sprite width according to the current value percentage
        FillSprite.Scale = new Vector2(FillBounds.Width * percentage, FillBounds.Height);

        // Draw the fill bar with appropriate color
        FillSprite.Color = IsEnabled ? EnabledColor : DisabledColor;
        FillSprite.Draw(spriteBatch, fillSpritePosition);

        // Draw the slider background with appropriate color
        SliderSprite.Color = IsEnabled ? EnabledColor : DisabledColor;
        SliderSprite.Draw(spriteBatch, AbsolutePosition);

        base.Draw(spriteBatch);
    }
}
</code></pre><h4 id="understanding-the-uislider-class">Understanding the UISlider Class</h4>
<p>Let's explore the key components of the <code>UISlider</code> class to understand how it works.</p>
<h5 id="properties-3">Properties</h5>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or sets the background sprite for the slider.
/// &lt;/summary&gt;
public Sprite SliderSprite { get; set; }

/// &lt;summary&gt;
/// Gets or sets the sprite used for the fill bar that represents the current value.
/// &lt;/summary&gt;
public Sprite FillSprite { get; set; }

/// &lt;summary&gt;
/// Gets or sets the rectangle that defines the position and size of the fill area
/// relative to the slider's position.
/// &lt;/summary&gt;
public Rectangle FillBounds { get; set; }

/// &lt;summary&gt;
/// Gets or sets the minimum value of the slider.
/// &lt;/summary&gt;
public float MinValue { get; set; }

/// &lt;summary&gt;
/// Gets or sets the maximum value of the slider.
/// &lt;/summary&gt;
public float MaxValue { get; set; }

/// &lt;summary&gt;
/// Gets or sets the current value of the slider.
/// &lt;/summary&gt;
public float Value { get; set; }

/// &lt;summary&gt;
/// Gets or sets the amount to change the value by when stepping up or down.
/// &lt;/summary&gt;
public float Step { get; set; }
</code></pre>
<ul>
<li><code>SliderSprite</code>: The background sprite that represents the entire slider track.</li>
<li><code>FillSprite</code>: The sprite that shows how much of the value range is currently selected (the filled portion).</li>
<li><code>FillBounds</code>: A rectangle defining where within the slider the fill should appear.</li>
<li><code>MinValue</code>: The minimum value the slider can represent.</li>
<li><code>MaxValue</code>: The maximum value the slider can represent.</li>
<li><code>Value</code>: The current value selected on the slider.</li>
<li><code>Step</code>: How much the value changes with each adjustment.</li>
</ul>
<h5 id="methods-3">Methods</h5>
<p>The <code>UISlider</code> class includes methods for adjusting the value and keeping it within bounds:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Increases the slider value by one step, clamped to the maximum.
/// &lt;/summary&gt;
/// &lt;returns&gt;The new value after stepping up.&lt;/returns&gt;
public float StepUp()
{
    Value = Math.Clamp(Value + Step, MinValue, MaxValue);
    return Value;
}

/// &lt;summary&gt;
/// Decreases the slider value by one step, clamped to the minimum.
/// &lt;/summary&gt;
/// &lt;returns&gt;The new value after stepping down.&lt;/returns&gt;
public float StepDown()
{
    Value = Math.Clamp(Value - Step, MinValue, MaxValue);
    return Value;
}
</code></pre>
<ul>
<li><code>StepUp</code>: Increases the current value by the step amount and ensures it stays within bounds.</li>
<li><code>StepDown</code>: Decreases the current value by the step amount and ensures it stays within bounds.</li>
</ul>
<p>Finally, the class overrides the <code>Draw</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Draws the slider with the fill representing the current value.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The sprite batch to use for drawing.&lt;/param&gt;
public override void Draw(SpriteBatch spriteBatch)
{
    // Calculate the position of the fill sprite relative to the slider
    Vector2 fillSpritePosition = AbsolutePosition + FillBounds.Location.ToVector2();

    // Calculate the fill percentage based on the current value
    float percentage = (Value - MinValue) / (MaxValue - MinValue);
    // Scale the fill sprite width according to the current value percentage
    FillSprite.Scale = new Vector2(FillBounds.Width * percentage, FillBounds.Height);

    // Draw the fill bar with appropriate color
    FillSprite.Color = IsEnabled ? EnabledColor : DisabledColor;
    FillSprite.Draw(spriteBatch, fillSpritePosition);

    // Draw the slider background with appropriate color
    SliderSprite.Color = IsEnabled ? EnabledColor : DisabledColor;
    SliderSprite.Draw(spriteBatch, AbsolutePosition);

    base.Draw(spriteBatch);
}
</code></pre>
<p>The <code>Draw</code> method:</p>
<ol>
<li>Calculates the position where the fill sprite should be rendered (based on the slider's absolute position and the fill bounds).</li>
<li>Converts the current value, minimum, and maximum to float values to calculate the percentage of the slider that should be filled.</li>
<li>Scales the fill sprite horizontally based on this percentage, creating a visual representation of the current value.</li>
<li>Applies the appropriate color to both sprites based on whether the slider is enabled or disabled.</li>
<li>Draws both the fill sprite and the slider background sprite.</li>
<li>Calls the base <code>Draw</code> method to render any child elements.</li>
</ol>
<p>This implementation creates a horizontal slider where the filled portion grows from left to right as the value increases, providing an intuitive visual representation of the selected value.</p>
<h2 id="implementing-a-ui-system-in-our-game">Implementing a UI System In Our Game</h2>
<p>Now that we have the foundation for our UI system with the base classes and components, let's implement them in our game to create menus.  We will create a UI controller that translates player input into UI navigation actions, then build menus for the title screen and gameplay screen.</p>
<h3 id="creating-a-ui-controller">Creating a UI Controller</h3>
<p>The first step in implementing the UI system is to create a controller that translates player input into navigation actions for the UI elements.  This controller will implement the <code>IUIElementController</code> interface defined earlier.</p>
<p>In the game project, create a new directory named <em>UI</em>, then create a new file named <em>UIElementController.cs</em> with the following code:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Input;
using MonoGameLibrary.UI;

namespace DungeonSlime.UI;

/// &lt;summary&gt;
/// UIElement controller that translates keyboard and gamepad input into UI commands.
/// &lt;/summary&gt;
public class UIElementController : IUIElementController
{
    private KeyboardInfo _keyboard;
    private GamePadInfo _gamePad;

    /// &lt;summary&gt;
    /// Initializes a new instance of the UIElementController class.
    /// &lt;/summary&gt;
    public UIElementController()
    {
        _keyboard = Core.Input.Keyboard;
        _gamePad = Core.Input.GamePads[0];
    }

    /// &lt;summary&gt;
    /// Determines if an upward navigation command has been triggered.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// True if the up arrow key, DPad up, or left thumbstick up was just pressed; otherwise, false.
    /// &lt;/returns&gt;
    public bool NavigateUp()
    {
        return _keyboard.WasKeyJustPressed(Keys.Up) ||
               _gamePad.WasButtonJustPressed(Buttons.DPadUp) ||
               _gamePad.WasButtonJustPressed(Buttons.LeftThumbstickUp);
    }

    /// &lt;summary&gt;
    /// Determines if a downward navigation command has been triggered.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// True if the down arrow key, DPad down, or left thumbstick down was just pressed; otherwise, false.
    /// &lt;/returns&gt;
    public bool NavigateDown()
    {
        return _keyboard.WasKeyJustPressed(Keys.Down) ||
               _gamePad.WasButtonJustPressed(Buttons.DPadDown) ||
               _gamePad.WasButtonJustPressed(Buttons.LeftThumbstickDown);
    }

    /// &lt;summary&gt;
    /// Determines if a leftward navigation command has been triggered.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// True if the left arrow key, DPad left, or left thumbstick left was just pressed; otherwise, false.
    /// &lt;/returns&gt;
    public bool NavigateLeft()
    {
        return _keyboard.WasKeyJustPressed(Keys.Left) ||
               _gamePad.WasButtonJustPressed(Buttons.DPadLeft) ||
               _gamePad.WasButtonJustPressed(Buttons.LeftThumbstickLeft);
    }

    /// &lt;summary&gt;
    /// Determines if a rightward navigation command has been triggered.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// True if the right arrow key, DPad right, or left thumbstick right was just pressed; otherwise, false.
    /// &lt;/returns&gt;
    public bool NavigateRight()
    {
        return _keyboard.WasKeyJustPressed(Keys.Right) ||
               _gamePad.WasButtonJustPressed(Buttons.DPadRight) ||
               _gamePad.WasButtonJustPressed(Buttons.LeftThumbstickRight);
    }

    /// &lt;summary&gt;
    /// Determines if a confirm command has been triggered.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// True if the Enter key or gamepad A button was just pressed; otherwise, false.
    /// &lt;/returns&gt;
    public bool Confirm()
    {
        return _keyboard.WasKeyJustPressed(Keys.Enter) ||
               _gamePad.WasButtonJustPressed(Buttons.A);
    }

    /// &lt;summary&gt;
    /// Determines if a cancel command has been triggered.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// True if the Escape key or gamepad B button was just pressed; otherwise, false.
    /// &lt;/returns&gt;
    public bool Cancel()
    {
        return _keyboard.WasKeyJustPressed(Keys.Escape) ||
               _gamePad.WasButtonJustPressed(Buttons.B);
    }
}
</code></pre>
<p>This controller implementation bridges the gap between the input management system from <a href="../11_input_management/index.html#implementing-the-inputmanager-class">Chapter 11</a> and the UI navigation system. It detects:</p>
<ul>
<li>Navigation in four direction (up, down, left, and right) using either arrow keys, WASD keys, or gamepad controls.</li>
<li>Confirmation action (Enter key or gamepad A button).</li>
<li>Cancellation action (Escape key or gamepad B button).</li>
</ul>
<h4 id="updating-the-texture-atlas">Updating the Texture Atlas</h4>
<p>Before we can create the menus, we need visual assets for the UI elements, including buttons, panels, and labels.  Let's update the texture atlas asset for our game to include these.  Download the new texture atlas below by right-clicking the following image and saving it as <em>atlas.png</em> in the <em>Content/images</em> directory of the game project, overwriting the existing one.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/atlas.png" alt="Figure 19-1: The texture atlas for our game updated to include the graphical assets for the UI"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 19-1: The texture atlas for our game updated to include the graphical assets for the UI</strong></td>
</tr>
</tbody>
</table>
<p>Since the texture atlas image has been updated, we also need to update the atlas configuration file.  Open the <em>atlas-definition.xml</em> configuration file and update it to the following:</p>
<pre><code class="lang-xml" highlight-lines="10-42">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextureAtlas&gt;
  &lt;Texture&gt;images/atlas&lt;/Texture&gt;
  &lt;Regions&gt;
    &lt;Region name=&quot;slime-1&quot; x=&quot;320&quot; y=&quot;0&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
    &lt;Region name=&quot;slime-2&quot; x=&quot;320&quot; y=&quot;80&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
    &lt;Region name=&quot;bat-1&quot; x=&quot;320&quot; y=&quot;160&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
    &lt;Region name=&quot;bat-2&quot; x=&quot;320&quot; y=&quot;240&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
    &lt;Region name=&quot;bat-3&quot; x=&quot;400&quot; y=&quot;0&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
    &lt;Region name=&quot;start-button&quot; x=&quot;480&quot; y=&quot;0&quot; width=&quot;208&quot; height=&quot;44&quot; /&gt;
    &lt;Region name=&quot;options-button&quot; x=&quot;480&quot; y=&quot;44&quot; width=&quot;208&quot; height=&quot;44&quot; /&gt;
    &lt;Region name=&quot;accept-button&quot; x=&quot;480&quot; y=&quot;88&quot; width=&quot;208&quot; height=&quot;44&quot; /&gt;
    &lt;Region name=&quot;cancel-button&quot; x=&quot;480&quot; y=&quot;132&quot; width=&quot;208&quot; height=&quot;44&quot; /&gt;
    &lt;Region name=&quot;resume-button&quot; x=&quot;480&quot; y=&quot;176&quot; width=&quot;208&quot; height=&quot;44&quot; /&gt;
    &lt;Region name=&quot;retry-button&quot; x=&quot;480&quot; y=&quot;220&quot; width=&quot;208&quot; height=&quot;44&quot; /&gt;
    &lt;Region name=&quot;quit-button&quot; x=&quot;480&quot; y=&quot;264&quot; width=&quot;208&quot; height=&quot;44&quot; /&gt;
    &lt;Region name=&quot;start-button-selected-1&quot; x=&quot;697&quot; y=&quot;0&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;options-button-selected-1&quot; x=&quot;697&quot; y=&quot;52&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;accept-button-selected-1&quot; x=&quot;697&quot; y=&quot;104&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;cancel-button-selected-1&quot; x=&quot;697&quot; y=&quot;156&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;resume-button-selected-1&quot; x=&quot;697&quot; y=&quot;208&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;retry-button-selected-1&quot; x=&quot;697&quot; y=&quot;260&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;quit-button-selected-1&quot; x=&quot;697&quot; y=&quot;312&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;start-button-selected-2&quot; x=&quot;0&quot; y=&quot;320&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;options-button-selected-2&quot; x=&quot;256&quot; y=&quot;320&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;accept-button-selected-2&quot; x=&quot;0&quot; y=&quot;372&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;cancel-button-selected-2&quot; x=&quot;256&quot; y=&quot;372&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;resume-button-selected-2&quot; x=&quot;512&quot; y=&quot;364&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;retry-button-selected-2&quot; x=&quot;768&quot; y=&quot;364&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;quit-button-selected-2&quot; x=&quot;768&quot; y=&quot;416&quot; width=&quot;256&quot; height=&quot;52&quot; /&gt;
    &lt;Region name=&quot;options-label&quot; x=&quot;0&quot; y=&quot;424&quot; width=&quot;315&quot; height=&quot;72&quot; /&gt;
    &lt;Region name=&quot;escape-label&quot; x=&quot;790&quot; y=&quot;480&quot; width=&quot;219&quot; height=&quot;28&quot; /&gt;
    &lt;Region name=&quot;enter-label&quot; x=&quot;790&quot; y=&quot;508&quot; width=&quot;149&quot; height=&quot;28&quot; /&gt;
    &lt;Region name=&quot;music-label&quot; x=&quot;320&quot; y=&quot;448&quot; width=&quot;178&quot; height=&quot;35&quot; /&gt;
    &lt;Region name=&quot;paused-label&quot; x=&quot;498&quot; y=&quot;448&quot; width=&quot;232&quot; height=&quot;35&quot; /&gt;
    &lt;Region name=&quot;sound-effect-label&quot; x=&quot;320&quot; y=&quot;483&quot; width=&quot;114&quot; height=&quot;35&quot; /&gt;
    &lt;Region name=&quot;game-over-label&quot; x=&quot;434&quot; y=&quot;483&quot; width=&quot;346&quot; height=&quot;35&quot; /&gt;
    &lt;Region name=&quot;slider&quot; x=&quot;0&quot; y=&quot;519&quot; width=&quot;782&quot; height=&quot;44&quot; /&gt;
    &lt;Region name=&quot;title&quot; x=&quot;0&quot; y=&quot;563&quot; width=&quot;751&quot; height=&quot;240&quot; /&gt;
    &lt;Region name=&quot;panel&quot; x=&quot;0&quot; y=&quot;803&quot; width=&quot;849&quot; height=&quot;221&quot; /&gt;
    &lt;Region name=&quot;white-pixel&quot; x=&quot;12&quot; y=&quot;0&quot; width=&quot;1&quot; height=&quot;1&quot; /&gt;
    &lt;Region name=&quot;overlay-pixel&quot; x=&quot;28&quot; y=&quot;488&quot; width=&quot;1&quot; height=&quot;1&quot; /&gt;
  &lt;/Regions&gt;
  &lt;Animations&gt;
    &lt;Animation name=&quot;slime-animation&quot; delay=&quot;200&quot;&gt;
      &lt;Frame region=&quot;slime-1&quot; /&gt;
      &lt;Frame region=&quot;slime-2&quot; /&gt;
    &lt;/Animation&gt;
    &lt;Animation name=&quot;bat-animation&quot; delay=&quot;200&quot;&gt;
      &lt;Frame region=&quot;bat-1&quot; /&gt;
      &lt;Frame region=&quot;bat-2&quot; /&gt;
      &lt;Frame region=&quot;bat-1&quot; /&gt;
      &lt;Frame region=&quot;bat-3&quot; /&gt;
    &lt;/Animation&gt;
    &lt;Animation name=&quot;start-button-selected&quot; delay=&quot;300&quot;&gt;
      &lt;Frame region=&quot;start-button-selected-1&quot; /&gt;
      &lt;Frame region=&quot;start-button-selected-2&quot; /&gt;
    &lt;/Animation&gt;
    &lt;Animation name=&quot;options-button-selected&quot; delay=&quot;300&quot;&gt;
      &lt;Frame region=&quot;options-button-selected-1&quot; /&gt;
      &lt;Frame region=&quot;options-button-selected-2&quot; /&gt;
    &lt;/Animation&gt;
    &lt;Animation name=&quot;accept-button-selected&quot; delay=&quot;300&quot;&gt;
      &lt;Frame region=&quot;accept-button-selected-1&quot; /&gt;
      &lt;Frame region=&quot;accept-button-selected-2&quot; /&gt;
    &lt;/Animation&gt;
    &lt;Animation name=&quot;cancel-button-selected&quot; delay=&quot;300&quot;&gt;
      &lt;Frame region=&quot;cancel-button-selected-1&quot; /&gt;
      &lt;Frame region=&quot;cancel-button-selected-2&quot; /&gt;
    &lt;/Animation&gt;
    &lt;Animation name=&quot;resume-button-selected&quot; delay=&quot;300&quot;&gt;
      &lt;Frame region=&quot;resume-button-selected-1&quot; /&gt;
      &lt;Frame region=&quot;resume-button-selected-2&quot; /&gt;
    &lt;/Animation&gt;
    &lt;Animation name=&quot;retry-button-selected&quot; delay=&quot;300&quot;&gt;
      &lt;Frame region=&quot;retry-button-selected-1&quot; /&gt;
      &lt;Frame region=&quot;retry-button-selected-2&quot; /&gt;
    &lt;/Animation&gt;
    &lt;Animation name=&quot;quit-button-selected&quot; delay=&quot;300&quot;&gt;
      &lt;Frame region=&quot;quit-button-selected-1&quot; /&gt;
      &lt;Frame region=&quot;quit-button-selected-2&quot; /&gt;
    &lt;/Animation&gt;
  &lt;/Animations&gt;
&lt;/TextureAtlas&gt;
</code></pre>
<p>This change adds the regions for all of the UI elements and the animations for the buttons including:</p>
<ul>
<li><code>*-button</code> regions to represent the default state of each button</li>
<li><code>*-button-selected-1</code> regions to represent the first frame of each button's animated sprite</li>
<li><code>*-button-selected-2</code> regions to represent the second frame of each button's animated sprite.</li>
<li><code>*-label</code> regions to represent the text labels to render</li>
<li><code>slider</code> region for the UI slider</li>
<li><code>title</code> region to represent the game title during the title scene.</li>
<li><code>panel</code> region to represent the image for the panels that group elements together.</li>
<li><code>white-pixel</code> region that represents a 1x1 white pixel from the texture atlas that we can use to fill the slider container with.</li>
<li><code>overlay-pixel</code> region that represents a 1x1 opaque blue pixel from the texture atlas we can use to overlay the game scene when the game is paused to visually represent the game is paused/disabled.</li>
</ul>
<h3 id="updating-the-title-scene">Updating the Title Scene</h3>
<p>The title scene is the player's first point of interaction with the game.  Currently it just displays the text to &quot;Press Enter To Stat&quot;.  Let's update it to instead include a main menu with &quot;Start&quot; and &quot;Options&quot; buttons, and an options menu for adjusting game settings. Open the <em>TitleScene.cs</em> file in the game project and update it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="27-39,45-49,67-77,80-174,176-479,507-510">using DungeonSlime.UI;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Scenes;
using MonoGameLibrary.UI;

namespace DungeonSlime.Scenes;

public class TitleScene : Scene
{
    // The texture used for the background pattern.
    private Texture2D _backgroundPattern;

    // The destination rectangle for the background pattern to fill.
    private Rectangle _backgroundDestination;

    // The offset to apply when drawing the background pattern so it appears to
    // be scrolling.
    private Vector2 _backgroundOffset;

    // The speed that the background pattern scrolls.
    private float _scrollSpeed = 50.0f;

    // Tracks the ui element that represents the title menu.
    private UIElement _titleMenu;

    // Tracks the ui element that represents the options menu.
    private UIElement _optionsMenu;

    // Tracks the volume level of songs before changes are made in the options
    // menu so it can be restored if they player selects cancel.
    private float _previousSongVolume;

    // Tracks the volume level of sound effects before changes are made in the
    // options menu so it can be restored if the player selects cancel.
    private float _previousSoundEffectVolume;

    public override void Initialize()
    {
        base.Initialize();

        // Explicitly set exit on escape to false so that the game doesn't exit
        // when the options menu is open and the user presses escape to cancel
        // an action.  Instead, we'll perform the exit check in the title menu's
        // cancel logic
        Core.ExitOnEscape = false;

        // Initialize the offset of the background pattern at zero
        _backgroundOffset = Vector2.Zero;

        // Set the background pattern destination rectangle to fill the entire
        // screen background
        _backgroundDestination = Core.GraphicsDevice.PresentationParameters.Bounds;
    }

    public override void LoadContent()
    {
        // Create a texture atlas from the XML configuration file.
        TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);

        // Load the background pattern texture.
        _backgroundPattern = Content.Load&lt;Texture2D&gt;(&quot;images/background-pattern&quot;);

        // Load the sound effect to play when ui actions occur.
        SoundEffect uiSoundEffect = Core.Content.Load&lt;SoundEffect&gt;(&quot;audio/ui&quot;);

        // Create the UI controller
        UIElementController controller = new UIElementController();

        // Create the title menu
        CreateTileMenu(atlas, uiSoundEffect, controller);

        // Create the options menu
        CreateOptionsMenu(atlas, uiSoundEffect, controller);
    }

    private void CreateTileMenu(TextureAtlas atlas, SoundEffect soundEffect, UIElementController controller)
    {
        // Create the root container for the title menu.
        _titleMenu = new UISprite();
        _titleMenu.Position = Vector2.Zero;
        _titleMenu.Controller = controller;
        _titleMenu.IsSelected = true;

        // Create the title sprite as a child of the title menu.
        UISprite titleSprite = _titleMenu.CreateChild&lt;UISprite&gt;();
        titleSprite.Sprite = atlas.CreateSprite(&quot;title&quot;);
        titleSprite.Sprite.CenterOrigin();
        titleSprite.Position = new Vector2(640, 220);

        // Create the start button as a child of the title menu.
        UIButton startButton = _titleMenu.CreateChild&lt;UIButton&gt;();
        startButton.NotSelectedSprite = atlas.CreateSprite(&quot;start-button&quot;);
        startButton.NotSelectedSprite.CenterOrigin();
        startButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;start-button-selected&quot;);
        startButton.SelectedSprite.CenterOrigin();
        startButton.Position = new Vector2(432, 670);
        startButton.IsSelected = true;

        // Create the options button as a child of the title menu.
        UIButton optionsButton = _titleMenu.CreateChild&lt;UIButton&gt;();
        optionsButton.NotSelectedSprite = atlas.CreateSprite(&quot;options-button&quot;);
        optionsButton.NotSelectedSprite.CenterOrigin();
        optionsButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;options-button-selected&quot;);
        optionsButton.SelectedSprite.CenterOrigin();
        optionsButton.Position = new Vector2(848, 670);

        // Wire up the actions to perform when the Left action is triggered
        // for the menu.
        _titleMenu.LeftAction = () =&gt;
        {
            // Play the sound effect.
            Core.Audio.PlaySoundEffect(soundEffect);

            // The left action was performed, so deselect the options button and
            // select the start button.
            startButton.IsSelected = true;
            optionsButton.IsSelected = false;
        };

        // Wire up the actions to perform when the Right action is triggered
        // for the menu.
        _titleMenu.RightAction = () =&gt;
        {
            // Play the sound effect.
            Core.Audio.PlaySoundEffect(soundEffect);

            // The right action was performed, so deselect the start button and
            // select the options button.
            startButton.IsSelected = false;
            optionsButton.IsSelected = true;
        };

        // Wire up the actions to perform when the Confirm action is triggered
        // for the menu.
        _titleMenu.ConfirmAction = () =&gt;
        {
            // Play the sound effect.
            Core.Audio.PlaySoundEffect(soundEffect);

            if (startButton.IsSelected)
            {
                // The start button is selected and the confirm action was
                // performed, so change the scene to the game select scene.
                Core.ChangeScene(new GameScene());
            }
            else if (optionsButton.IsSelected)
            {
                // The accept button is selected and the confirm action was
                // performed, so disable the title menu...
                _titleMenu.IsEnabled = _titleMenu.IsVisible = _titleMenu.IsSelected = false;

                // ...cache the current volume levels of songs and
                // sound effects..
                _previousSongVolume = Core.Audio.SongVolume;
                _previousSoundEffectVolume = Core.Audio.SoundEffectVolume;

                // ...and restore the default selections of the title menu for
                // when they come back to it...
                startButton.IsSelected = true;
                optionsButton.IsSelected = false;

                // ...and enable the options menu.
                _optionsMenu.IsEnabled = _optionsMenu.IsVisible = _optionsMenu.IsSelected = true;
            }
        };

        // If the cancel button is pressed while the title menu is active, tell
        // the game to exit.
        _titleMenu.CancelAction = Core.Instance.Exit;
    }

    private void CreateOptionsMenu(TextureAtlas atlas, SoundEffect soundEffect, UIElementController controller)
    {
        // Crete the root container for the options menu.
        _optionsMenu = new UIElement();
        _optionsMenu.Controller = controller;
        _optionsMenu.IsEnabled = false;
        _optionsMenu.IsVisible = false;

        // Create the options label as a child of the options menu.
        UISprite optionsLabel = _optionsMenu.CreateChild&lt;UISprite&gt;();
        optionsLabel.Sprite = atlas.CreateSprite(&quot;options-label&quot;);
        optionsLabel.Position = new Vector2(112, 20);

        // Create the enter label as a child of the options menu.
        UISprite enterLabel = _optionsMenu.CreateChild&lt;UISprite&gt;();
        enterLabel.Sprite = atlas.CreateSprite(&quot;enter-label&quot;);
        enterLabel.Position = new Vector2(640, 52);

        // Create the escape label as a child of the options menu.
        UISprite escapeLabel = _optionsMenu.CreateChild&lt;UISprite&gt;();
        escapeLabel.Sprite = atlas.CreateSprite(&quot;escape-label&quot;);
        escapeLabel.Position = new Vector2(804, 52);

        // Create the music panel as a child of the options menu.
        UISprite musicPanel = _optionsMenu.CreateChild&lt;UISprite&gt;();
        musicPanel.Sprite = atlas.CreateSprite(&quot;panel&quot;);
        musicPanel.Position = new Vector2(198, 139);
        musicPanel.IsSelected = true;

        // Create the sound effect panel as a child of the options menu.
        UISprite soundEffectPanel = _optionsMenu.CreateChild&lt;UISprite&gt;();
        soundEffectPanel.Sprite = atlas.CreateSprite(&quot;panel&quot;);
        soundEffectPanel.Position = new Vector2(198, 406);
        soundEffectPanel.IsEnabled = false;

        // Create the accept button as a child of the options menu.
        UIButton acceptButton = _optionsMenu.CreateChild&lt;UIButton&gt;();
        acceptButton.NotSelectedSprite = atlas.CreateSprite(&quot;accept-button&quot;);
        acceptButton.NotSelectedSprite.CenterOrigin();
        acceptButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;accept-button-selected&quot;);
        acceptButton.SelectedSprite.CenterOrigin();
        acceptButton.Position = new Vector2(432, 670);

        // Create the cancel button as a child of the options menu.
        UIButton cancelButton = _optionsMenu.CreateChild&lt;UIButton&gt;();
        cancelButton.NotSelectedSprite = atlas.CreateSprite(&quot;cancel-button&quot;);
        cancelButton.NotSelectedSprite.CenterOrigin();
        cancelButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;cancel-button-selected&quot;);
        cancelButton.SelectedSprite.CenterOrigin();
        cancelButton.Position = new Vector2(848, 670);

        // Create the music text as a child of the music panel.
        UISprite musicText = musicPanel.CreateChild&lt;UISprite&gt;();
        musicText.Sprite = atlas.CreateSprite(&quot;music-label&quot;);
        musicText.Position = new Vector2(42, 42);

        // Create the music volume slider as a child of the music panel.
        UISlider musicVolumeSlider = musicPanel.CreateChild&lt;UISlider&gt;();
        musicVolumeSlider.SliderSprite = atlas.CreateSprite(&quot;slider&quot;);
        musicVolumeSlider.FillSprite = atlas.CreateSprite(&quot;white-pixel&quot;);
        musicVolumeSlider.FillBounds = new Rectangle(108, 4, 566, 36);
        musicVolumeSlider.Value = Core.Audio.SongVolume;
        musicVolumeSlider.MinValue = 0.0f;
        musicVolumeSlider.MaxValue = 1.0f;
        musicVolumeSlider.Step = 0.1f;
        musicVolumeSlider.Position = new Vector2(27, 117);

        // Create the sound text as a child of the sound effect panel.
        UISprite soundText = soundEffectPanel.CreateChild&lt;UISprite&gt;();
        soundText.Sprite = atlas.CreateSprite(&quot;sound-effect-label&quot;);
        soundText.Position = new Vector2(42, 42);

        // Create the sound effect volume slider as a child of the sound effect panel.
        UISlider soundEffectVolumeSlider = soundEffectPanel.CreateChild&lt;UISlider&gt;();
        soundEffectVolumeSlider.SliderSprite = atlas.CreateSprite(&quot;slider&quot;);
        soundEffectVolumeSlider.FillSprite = atlas.CreateSprite(&quot;white-pixel&quot;);
        soundEffectVolumeSlider.FillBounds = new Rectangle(108, 4, 566, 36);
        soundEffectVolumeSlider.Value = Core.Audio.SoundEffectVolume;
        soundEffectVolumeSlider.MinValue = 0.0f;
        soundEffectVolumeSlider.MaxValue = 1.0f;
        soundEffectVolumeSlider.Step = 0.1f;
        soundEffectVolumeSlider.Position = new Vector2(27, 117);

        // By setting the disabled color of the root options menu, it will
        // propagate the value to all child elements
        _optionsMenu.DisabledColor = new Color(70, 86, 130, 255);

        // Wire up the actions to perform when the Up Action is triggered
        // for the menu.
        _optionsMenu.UpAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (soundEffectPanel.IsSelected)
            {
                // The sound effect panel is selected and the up action was
                // performed, so deselect the sound effect panel and move the
                // navigation up to the music panel.
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
                musicPanel.IsEnabled = musicPanel.IsSelected = true;
            }
            else if (acceptButton.IsSelected)
            {
                // The accept button is selected and the up action was
                // performed, so deselect the accept button and move the
                // navigation up to the sound effect panel.
                acceptButton.IsSelected = false;
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
            }
            else if (cancelButton.IsSelected)
            {
                // The cancel button is selected and the up action was
                // performed, so deselect the cancel button and move the
                // navigation up to the sound effect panel.
                cancelButton.IsSelected = false;
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
            }
        };

        // Wire up the actions to perform when the Down action is triggered
        // for the menu.
        _optionsMenu.DownAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (musicPanel.IsSelected)
            {
                // The music panel is selected and the down action was
                // performed, so deselect the music panel and move the
                // navigation down to the  sound effect panel.
                musicPanel.IsEnabled = musicPanel.IsSelected = false;
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
            }
            else if (soundEffectPanel.IsSelected)
            {
                // The sound effect panel is selected and the down action was
                // performed, so deselect the sound effect panel and move the
                // navigation down to the accept button.
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
                acceptButton.IsSelected = true;
            }
        };

        // Wire up the actions to perform when the Left action is triggered
        // for the menu.
        _optionsMenu.LeftAction = () =&gt;
        {
            if (musicPanel.IsSelected)
            {
                // The music panel is selected and the right action was
                // performed, so step down the music volume slider.
                Core.Audio.SongVolume = musicVolumeSlider.StepDown();
            }
            else if (soundEffectPanel.IsSelected)
            {
                // The sound effect panel is selected and the right action was
                // performed, so step down the sound effect volume slider.
                Core.Audio.SoundEffectVolume = soundEffectVolumeSlider.StepDown();

            }
            else if (cancelButton.IsSelected)
            {
                // The cancel button is selected and the right action was
                // performed, so deselect the cancel button and move the
                // navigation to the accept button.
                cancelButton.IsSelected = false;
                acceptButton.IsSelected = true;
            }

            // For this action, we'll play the sound effect at the end of the
            // action so that if the sound effect volume slider was adjusted
            // the sound effect played will have those changes.
            Core.Audio.PlaySoundEffect(soundEffect);
        };

        // Wire up the actions to perform when the Right action is triggered
        // for the menu.
        _optionsMenu.RightAction = () =&gt;
        {
            if (musicPanel.IsSelected)
            {
                // The music panel is selected and the right action was
                // performed, so step up the music volume slider.
                Core.Audio.SongVolume = musicVolumeSlider.StepUp();

                // Play the sound effect
                Core.Audio.PlaySoundEffect(soundEffect);
            }
            else if (soundEffectPanel.IsSelected)
            {
                // The sound effect panel is selected and the right action was
                // performed, so step up the sound effect volume slider.
                Core.Audio.SoundEffectVolume = soundEffectVolumeSlider.StepUp();

            }
            else if (acceptButton.IsSelected)
            {
                // The accept button is selected and the right action was
                // performed, so deselect the accept button and move the
                // navigation to the cancel button.
                acceptButton.IsSelected = false;
                cancelButton.IsSelected = true;
            }

            // For this action, we'll play the sound effect at the end of the
            // action so that if the sound effect volume slider was adjusted
            // the sound effect played will have those changes.
            Core.Audio.PlaySoundEffect(soundEffect);
        };

        // Wire up the actions to perform when the Confirm action is triggered
        // for the menu.
        _optionsMenu.ConfirmAction = () =&gt;
        {
            // Play the sound effect.
            Core.Audio.PlaySoundEffect(soundEffect);

            if (musicPanel.IsSelected)
            {
                // The music panel is selected and the confirm action was
                // performed, so deselect the music panel and move the
                // navigation to the sound effect panel.
                musicPanel.IsEnabled = musicPanel.IsSelected = false;
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
            }
            else if (soundEffectPanel.IsSelected)
            {
                // The sound effect panel is selected and the confirm action was
                // performed, so deselect the sound effect panel and move the
                // navigation to the accept button.
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
                acceptButton.IsSelected = true;
            }
            else if (acceptButton.IsSelected)
            {
                // The accept button is selected and the confirm action was
                // performed, so disable the options menu...
                _optionsMenu.IsEnabled = _optionsMenu.IsVisible = _optionsMenu.IsSelected = false;

                // ...and restore the default selections of the options menu in
                // case they come back to it...
                musicPanel.IsEnabled = musicPanel.IsSelected = true;
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
                acceptButton.IsSelected = cancelButton.IsSelected = false;

                // ...and enable the title menu.
                _titleMenu.IsEnabled = _titleMenu.IsVisible = _titleMenu.IsSelected = true;
            }
            else if (cancelButton.IsSelected)
            {
                // The cancel button is selected and the confirm action was
                // performed, so disable the options menu...
                _optionsMenu.IsEnabled = _optionsMenu.IsVisible = _optionsMenu.IsSelected = false;

                // ...and restore the song and sound effect volume levels...
                musicVolumeSlider.Value = Core.Audio.SongVolume = _previousSongVolume;
                soundEffectVolumeSlider.Value = Core.Audio.SoundEffectVolume = _previousSoundEffectVolume;

                // ...and restore the default selections of the options menu in
                // case they come back to it...
                musicPanel.IsEnabled = musicPanel.IsSelected = true;
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
                acceptButton.IsSelected = cancelButton.IsSelected = false;

                // ...and enable the title menu.
                _titleMenu.IsEnabled = _titleMenu.IsVisible = _titleMenu.IsSelected = true;
            }
        };

        // Wire up the actions to perform when the Cancel action is triggered
        // for the menu.
        _optionsMenu.CancelAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (soundEffectPanel.IsSelected)
            {
                // The sound effect panel is selected and the cancel action was
                // performed, so deselect the sound effect panel and move the
                // navigation back to the music panel.
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
                musicPanel.IsEnabled = musicPanel.IsSelected = true;
            }
            else if (acceptButton.IsSelected)
            {
                // The accept button is selected and the cancel action was
                // performed, so deselect the accept button and move the
                // navigation back to the sound effect panel.
                acceptButton.IsSelected = false;
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
            }
            else if (cancelButton.IsSelected)
            {
                // The cancel button is selected and the cancel action was
                // performed, so deselect the cancel button and move the
                // navigation back to the sound effect panel.
                cancelButton.IsSelected = false;
                soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
            }
        };
    }

    public override void Update(GameTime gameTime)
    {
        // Update the offsets for the background pattern wrapping so that it
        // scrolls down and to the right.
        float offset = _scrollSpeed * (float)gameTime.ElapsedGameTime.TotalSeconds;
        _backgroundOffset.X -= offset;
        _backgroundOffset.Y -= offset;

        // Ensure that the offsets do not go beyond the texture bounds so it is
        // a seamless wrap
        _backgroundOffset.X %= _backgroundPattern.Width;
        _backgroundOffset.Y %= _backgroundPattern.Height;

        _titleMenu.Update(gameTime);
        _optionsMenu.Update(gameTime);
    }

    public override void Draw(GameTime gameTime)
    {
        Core.GraphicsDevice.Clear(new Color(32, 40, 78, 255));

         // Draw the background pattern first using the PointWrap sampler state.
        Core.SpriteBatch.Begin(samplerState: SamplerState.PointWrap);
        Core.SpriteBatch.Draw(_backgroundPattern, _backgroundDestination, new Rectangle(_backgroundOffset.ToPoint(), _backgroundDestination.Size), Color.White * 0.5f);
        Core.SpriteBatch.End();

        Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp);
        _titleMenu.Draw(Core.SpriteBatch);
        _optionsMenu.Draw(Core.SpriteBatch);
        Core.SpriteBatch.End();
    }
}
</code></pre>
<p>The key changes made here are:</p>
<ul>
<li>The fields associated with the &quot;Press enter to start&quot; text have been removed and replaced with proper UI elements.</li>
<li>New fields <code>_titleMenu</code> and <code>_optionsMenu</code> were added to serve as root <code>UIElement</code> containers for each menu.</li>
<li>Fields <code>_previousSongVolume</code> and <code>_previousSoundEffectVolume</code> were added to track audio settings, allowing players to cancel changes.</li>
<li>In <code>Initialize</code>, <code>Core.ExistOnEscape</code> is explicitly set to <code>false</code> so that the Escape key can be integrated with the UI navigation.</li>
<li>The <code>LoadContent</code> method now
<ul>
<li>Loads the assets used for the UI such as the UI sound effect.</li>
<li>Calls the <code>CreateTitleMenu</code> and <code>CreateOptionsMenu</code> methods to create the menus.</li>
</ul>
</li>
<li>The <code>CreateTitleMenu</code> and <code>CreateOptionsMenu</code> methods were added which construct the title and options menu UI elements.</li>
<li>The <code>Update</code> method:
<ul>
<li>No longer checks for the Enter key to switch to the game scene, as this is no handled by the UI system, specifically the <code>_titleMenu</code>.</li>
<li>Calls <code>Update</code> for both the title and options menu.  We don't need to check the enabled stated here before updating since a <code>UIElement</code> will not run its update method if its already disabled.</li>
</ul>
</li>
<li>The <code>Draw</code> method draws both UI elements, though one will always be set as not visible so we don't have both drawing at the same time overlapping each other visually.</li>
</ul>
<p>Running the game now, the title scene loads and presents the user with two buttons to navigate through, &quot;Start&quot; and &quot;Options&quot;.  The button that is currently selected will animate using its animated sprite to provide visual feedback to the player.  When pressing left or right to navigate between the two, the UI sound effect is played to give auditory feedback to the player.  Selecting the &quot;Options&quot; button and pressing the Enter key on the keyboard will hide the title menu and show the options menu where players can adjust the volume levels of the music and sound effects.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/titlescene.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 19-2: The title scene now with the title menu buttons and the options menu for adjusting music and sound effect volume</strong></td>
</tr>
</tbody>
</table>
<h3 id="building-ui-hierarchies">Building UI Hierarchies</h3>
<p>Let's examine how the title scene UI is constructed through a breakdown of the <code>CreateOptionsMenu</code> method.  This approach illustrates how a complete UI menu is built with a parent-child relationship hierarchy.</p>
<h4 id="step-1-creating-the-root-container">Step 1. Creating the Root Container</h4>
<p>First, we create a root element to serve as the main container for all elements of that menu.</p>
<pre><code class="lang-csharp">// Crete the root container for the options menu.
_optionsMenu = new UIElement();
_optionsMenu.Controller = controller;
_optionsMenu.IsEnabled = false;
_optionsMenu.IsVisible = false;
</code></pre>
<p>This root element:</p>
<ul>
<li>Holds a reference to the UI controller for navigation</li>
<li>Is initially disabled and invisible (since it's the options menu it only appears when the player selects &quot;Options&quot;).</li>
<li>Services as the parent for all other elements in this menu.</li>
</ul>
<h4 id="step-2-adding-primary-ui-elements">Step 2. Adding Primary UI Elements</h4>
<p>Next, we create the main visual elements of the menu as children of the root container:</p>
<pre><code class="lang-csharp">// Create the options label as a child of the options menu.
UISprite optionsLabel = _optionsMenu.CreateChild&lt;UISprite&gt;();
optionsLabel.Sprite = atlas.CreateSprite(&quot;options-label&quot;);
optionsLabel.Position = new Vector2(112, 20);

// Create the enter label as a child of the options menu.
UISprite enterLabel = _optionsMenu.CreateChild&lt;UISprite&gt;();
enterLabel.Sprite = atlas.CreateSprite(&quot;enter-label&quot;);
enterLabel.Position = new Vector2(640, 52);

// Create the escape label as a child of the options menu.
UISprite escapeLabel = _optionsMenu.CreateChild&lt;UISprite&gt;();
escapeLabel.Sprite = atlas.CreateSprite(&quot;escape-label&quot;);
escapeLabel.Position = new Vector2(804, 52);

// Create the music panel as a child of the options menu.
UISprite musicPanel = _optionsMenu.CreateChild&lt;UISprite&gt;();
musicPanel.Sprite = atlas.CreateSprite(&quot;panel&quot;);
musicPanel.Position = new Vector2(198, 139);
musicPanel.IsSelected = true;

// Create the sound effect panel as a child of the options menu.
UISprite soundEffectPanel = _optionsMenu.CreateChild&lt;UISprite&gt;();
soundEffectPanel.Sprite = atlas.CreateSprite(&quot;panel&quot;);
soundEffectPanel.Position = new Vector2(198, 406);
soundEffectPanel.IsEnabled = false;

// Create the accept button as a child of the options menu.
UIButton acceptButton = _optionsMenu.CreateChild&lt;UIButton&gt;();
acceptButton.NotSelectedSprite = atlas.CreateSprite(&quot;accept-button&quot;);
acceptButton.NotSelectedSprite.CenterOrigin();
acceptButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;accept-button-selected&quot;);
acceptButton.SelectedSprite.CenterOrigin();
acceptButton.Position = new Vector2(432, 670);

// Create the cancel button as a child of the options menu.
UIButton cancelButton = _optionsMenu.CreateChild&lt;UIButton&gt;();
cancelButton.NotSelectedSprite = atlas.CreateSprite(&quot;cancel-button&quot;);
cancelButton.NotSelectedSprite.CenterOrigin();
cancelButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;cancel-button-selected&quot;);
cancelButton.SelectedSprite.CenterOrigin();
cancelButton.Position = new Vector2(848, 670);
</code></pre>
<p>This establishes:</p>
<ul>
<li>Labels for the options screen and navigation hints.</li>
<li>Panels that will contain the volume controls for music and sound effects.</li>
<li>Buttons for accepting or cancelling changes.</li>
<li>Initial select state (music panel is selected first).</li>
</ul>
<p>each of these elements is positioned relative to the root container using absolute coordinates, but benefits from the parent-child relationship for visibility and enabled state inheritance.</p>
<h4 id="step-3-building-nested-controls">Step 3. Building Nested Controls</h4>
<p>For complex elements like panels that contain their own controls, we create child elements of those panels:</p>
<pre><code class="lang-csharp">// Create the music text as a child of the music panel.
UISprite musicText = musicPanel.CreateChild&lt;UISprite&gt;();
musicText.Sprite = atlas.CreateSprite(&quot;music-label&quot;);
musicText.Position = new Vector2(42, 42);

// Create the music volume slider as a child of the music panel.
UISlider musicVolumeSlider = musicPanel.CreateChild&lt;UISlider&gt;();
musicVolumeSlider.SliderSprite = atlas.CreateSprite(&quot;slider&quot;);
musicVolumeSlider.FillSprite = atlas.CreateSprite(&quot;white-pixel&quot;);
musicVolumeSlider.FillBounds = new Rectangle(108, 4, 566, 36);
musicVolumeSlider.Value = Core.Audio.SongVolume;
musicVolumeSlider.MinValue = 0.0f;
musicVolumeSlider.MaxValue = 1.0f;
musicVolumeSlider.Step = 0.1f;
musicVolumeSlider.Position = new Vector2(27, 117);

// Create the sound text as a child of the sound effect panel.
UISprite soundText = soundEffectPanel.CreateChild&lt;UISprite&gt;();
soundText.Sprite = atlas.CreateSprite(&quot;sound-effect-label&quot;);
soundText.Position = new Vector2(42, 42);

// Create the sound effect volume slider as a child of the sound effect panel.
UISlider soundEffectVolumeSlider = soundEffectPanel.CreateChild&lt;UISlider&gt;();
soundEffectVolumeSlider.SliderSprite = atlas.CreateSprite(&quot;slider&quot;);
soundEffectVolumeSlider.FillSprite = atlas.CreateSprite(&quot;white-pixel&quot;);
soundEffectVolumeSlider.FillBounds = new Rectangle(108, 4, 566, 36);
soundEffectVolumeSlider.Value = Core.Audio.SoundEffectVolume;
soundEffectVolumeSlider.MinValue = 0.0f;
soundEffectVolumeSlider.MaxValue = 1.0f;
soundEffectVolumeSlider.Step = 0.1f;
soundEffectVolumeSlider.Position = new Vector2(27, 117);
</code></pre>
<p>This creates:</p>
<ul>
<li>Text labels inside each panel.</li>
<li>Volume sliders with appropriate min/max values and initial values that are set to the current audio volume settings.</li>
</ul>
<p>The nested structure demonstrates an advantage of our UI system: elements added as children of the music panel are automatically positioned relative to that panel, making the layout simpler and more maintainable.</p>
<h4 id="step-4-setting-shared-visual-properties">Step 4. Setting Shared Visual Properties</h4>
<p>With the UI structure established, we set shared visual properties that apply to the entire hierarchy:</p>
<pre><code class="lang-csharp">// By setting the disabled color of the root options menu, it will
// propagate the value to all child elements
_optionsMenu.DisabledColor = new Color(70, 86, 130, 255);
</code></pre>
<p>This demonstrates a key another advantage of the parent-child relationship: properties like <code>DisabledColor</code> can be set once at the parent level and automatically cascade to all children.</p>
<h4 id="step-5-implementing-navigation-logic">Step 5. Implementing Navigation Logic</h4>
<p>Finally, we wire up the navigation logic through the action handlers:</p>
<pre><code class="lang-csharp">// Wire up the actions to perform when the Up Action is triggered
// for the menu.
_optionsMenu.UpAction = () =&gt;
{
    // Play the sound effect
    Core.Audio.PlaySoundEffect(soundEffect);

    if (soundEffectPanel.IsSelected)
    {
        // The sound effect panel is selected and the up action was
        // performed, so deselect the sound effect panel and move the
        // navigation up to the music panel.
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
        musicPanel.IsEnabled = musicPanel.IsSelected = true;
    }
    else if (acceptButton.IsSelected)
    {
        // The accept button is selected and the up action was
        // performed, so deselect the accept button and move the
        // navigation up to the sound effect panel.
        acceptButton.IsSelected = false;
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
    }
    else if (cancelButton.IsSelected)
    {
        // The cancel button is selected and the up action was
        // performed, so deselect the cancel button and move the
        // navigation up to the sound effect panel.
        cancelButton.IsSelected = false;
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
    }
};

// Wire up the actions to perform when the Down action is triggered
// for the menu.
_optionsMenu.DownAction = () =&gt;
{
    // Play the sound effect
    Core.Audio.PlaySoundEffect(soundEffect);

    if (musicPanel.IsSelected)
    {
        // The music panel is selected and the down action was
        // performed, so deselect the music panel and move the
        // navigation down to the  sound effect panel.
        musicPanel.IsEnabled = musicPanel.IsSelected = false;
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
    }
    else if (soundEffectPanel.IsSelected)
    {
        // The sound effect panel is selected and the down action was
        // performed, so deselect the sound effect panel and move the
        // navigation down to the accept button.
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
        acceptButton.IsSelected = true;
    }
};

// Wire up the actions to perform when the Left action is triggered
// for the menu.
_optionsMenu.LeftAction = () =&gt;
{
    if (musicPanel.IsSelected)
    {
        // The music panel is selected and the right action was
        // performed, so step down the music volume slider.
        Core.Audio.SongVolume = musicVolumeSlider.StepDown();
    }
    else if (soundEffectPanel.IsSelected)
    {
        // The sound effect panel is selected and the right action was
        // performed, so step down the sound effect volume slider.
        Core.Audio.SoundEffectVolume = soundEffectVolumeSlider.StepDown();

    }
    else if (cancelButton.IsSelected)
    {
        // The cancel button is selected and the right action was
        // performed, so deselect the cancel button and move the
        // navigation to the accept button.
        cancelButton.IsSelected = false;
        acceptButton.IsSelected = true;
    }

    // For this action, we'll play the sound effect at the end of the
    // action so that if the sound effect volume slider was adjusted
    // the sound effect played will have those changes.
    Core.Audio.PlaySoundEffect(soundEffect);
};

// Wire up the actions to perform when the Right action is triggered
// for the menu.
_optionsMenu.RightAction = () =&gt;
{
    if (musicPanel.IsSelected)
    {
        // The music panel is selected and the right action was
        // performed, so step up the music volume slider.
        Core.Audio.SongVolume = musicVolumeSlider.StepUp();

        // Play the sound effect
        Core.Audio.PlaySoundEffect(soundEffect);
    }
    else if (soundEffectPanel.IsSelected)
    {
        // The sound effect panel is selected and the right action was
        // performed, so step up the sound effect volume slider.
        Core.Audio.SoundEffectVolume = soundEffectVolumeSlider.StepUp();

    }
    else if (acceptButton.IsSelected)
    {
        // The accept button is selected and the right action was
        // performed, so deselect the accept button and move the
        // navigation to the cancel button.
        acceptButton.IsSelected = false;
        cancelButton.IsSelected = true;
    }

    // For this action, we'll play the sound effect at the end of the
    // action so that if the sound effect volume slider was adjusted
    // the sound effect played will have those changes.
    Core.Audio.PlaySoundEffect(soundEffect);
};

// Wire up the actions to perform when the Confirm action is triggered
// for the menu.
_optionsMenu.ConfirmAction = () =&gt;
{
    // Play the sound effect.
    Core.Audio.PlaySoundEffect(soundEffect);

    if (musicPanel.IsSelected)
    {
        // The music panel is selected and the confirm action was
        // performed, so deselect the music panel and move the
        // navigation to the sound effect panel.
        musicPanel.IsEnabled = musicPanel.IsSelected = false;
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
    }
    else if (soundEffectPanel.IsSelected)
    {
        // The sound effect panel is selected and the confirm action was
        // performed, so deselect the sound effect panel and move the
        // navigation to the accept button.
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
        acceptButton.IsSelected = true;
    }
    else if (acceptButton.IsSelected)
    {
        // The accept button is selected and the confirm action was
        // performed, so disable the options menu...
        _optionsMenu.IsEnabled = _optionsMenu.IsVisible = _optionsMenu.IsSelected = false;

        // ...and restore the default selections of the options menu in
        // case they come back to it...
        musicPanel.IsEnabled = musicPanel.IsSelected = true;
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
        acceptButton.IsSelected = cancelButton.IsSelected = false;

        // ...and enable the title menu.
        _titleMenu.IsEnabled = _titleMenu.IsVisible = _titleMenu.IsSelected = true;
    }
    else if (cancelButton.IsSelected)
    {
        // The cancel button is selected and the confirm action was
        // performed, so disable the options menu...
        _optionsMenu.IsEnabled = _optionsMenu.IsVisible = _optionsMenu.IsSelected = false;

        // ...and restore the song and sound effect volume levels...
        musicVolumeSlider.Value = Core.Audio.SongVolume = _previousSongVolume;
        soundEffectVolumeSlider.Value = Core.Audio.SoundEffectVolume = _previousSoundEffectVolume;

        // ...and restore the default selections of the options menu in
        // case they come back to it...
        musicPanel.IsEnabled = musicPanel.IsSelected = true;
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
        acceptButton.IsSelected = cancelButton.IsSelected = false;

        // ...and enable the title menu.
        _titleMenu.IsEnabled = _titleMenu.IsVisible = _titleMenu.IsSelected = true;
    }
};

// Wire up the actions to perform when the Cancel action is triggered
// for the menu.
_optionsMenu.CancelAction = () =&gt;
{
    // Play the sound effect
    Core.Audio.PlaySoundEffect(soundEffect);

    if (soundEffectPanel.IsSelected)
    {
        // The sound effect panel is selected and the cancel action was
        // performed, so deselect the sound effect panel and move the
        // navigation back to the music panel.
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = false;
        musicPanel.IsEnabled = musicPanel.IsSelected = true;
    }
    else if (acceptButton.IsSelected)
    {
        // The accept button is selected and the cancel action was
        // performed, so deselect the accept button and move the
        // navigation back to the sound effect panel.
        acceptButton.IsSelected = false;
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
    }
    else if (cancelButton.IsSelected)
    {
        // The cancel button is selected and the cancel action was
        // performed, so deselect the cancel button and move the
        // navigation back to the sound effect panel.
        cancelButton.IsSelected = false;
        soundEffectPanel.IsEnabled = soundEffectPanel.IsSelected = true;
    }
};
</code></pre>
<p>For each potential navigation direction (up, down, left, right) and action (confirm, cancel) we:</p>
<ol>
<li>Provide auditory feedback to the player by playing the UI sound effect.</li>
<li>Determine which element is currently selected.</li>
<li>Update selections states to move between elements.</li>
<li>Perform actions like adjusting volume or transitioning between menus.</li>
</ol>
<p>This creates a complete navigation flow where the player can</p>
<ul>
<li>Move between different UI elements.</li>
<li>Adjust settings with immediate audible and visual feedback.</li>
<li>Accept changes or cancel changes and go back to the previous menu.</li>
</ul>
<h4 id="ui-flow-and-state-management">UI Flow and State Management</h4>
<p>An important aspect of this menu system is how it manages the state transitions between menus.  When the player selects the &quot;Options&quot; button in the title menu and confirms:</p>
<ol>
<li>The title menu is disabled and hidden.</li>
<li>The current audio volume settings are saved.</li>
<li>Selection states are reset for when the player returns back to the title menu.</li>
<li>The options menu is enabled and becomes visible and selected.</li>
</ol>
<p>Similarly, when accepting or canceling from the options menu:</p>
<ol>
<li>The options menu is disabled and hidden.</li>
<li>If canceled, the previous audio settings are restored.</li>
<li>Default selection states are reset in case the player returns back to the options menu.</li>
<li>The title menu is re-enabled and becomes visible again.</li>
</ol>
<p>This state management creates a smooth flow between different UI screens without having to create entirely new scenes for each menu.</p>
<h3 id="updating-the-game-scene">Updating the Game Scene</h3>
<p>The game scene as it is right now is lacking two important UI elements for players; a pause menu and a game over menu.  Let's add these in now.  Open the <em>GameScene.cs</em> file and update it to the following</p>
<pre><code class="lang-csharp" highlight-lines="17-18,123-133,136-331,333-341,343-454,478,538-541,622-623">using System;
using DungeonSlime.UI;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;
using MonoGameLibrary.Scenes;
using MonoGameLibrary.UI;

namespace DungeonSlime.Scenes;

public class GameScene : Scene
{
    private UISprite _pauseMenu;
    private UISprite _gameOverMenu;

    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    // Tracks the position of the bat.
    private Vector2 _batPosition;

    // Tracks the velocity of the bat.
    private Vector2 _batVelocity;

    // Defines the tilemap to draw.
    private Tilemap _tilemap;

    // Defines the bounds of the room that the slime and bat are contained within.
    private Rectangle _roomBounds;

    // The sound effect to play when the bat bounces off the edge of the screen.
    private SoundEffect _bounceSoundEffect;

    // The sound effect to play when the slime eats a bat.
    private SoundEffect _collectSoundEffect;

    // The SpriteFont Description used to draw text
    private SpriteFont _font;

    // Tracks the players score.
    private int _score;

    // Defines the position to draw the score text at.
    private Vector2 _scoreTextPosition;

    // Defines the origin used when drawing the score text.
    private Vector2 _scoreTextOrigin;

    public override void Initialize()
    {
        // LoadContent is called during base.Initialize().
        base.Initialize();

        // During the game scene, we want to disable exit on escape. Instead,
        // the escape key will be used to return back to the title screen
        Core.ExitOnEscape = false;

        Rectangle screenBounds = Core.GraphicsDevice.PresentationParameters.Bounds;

        _roomBounds = new Rectangle(
            _tilemap.TileSize,
            _tilemap.TileSize,
            screenBounds.Width - _tilemap.TileSize * 2,
            screenBounds.Height - _tilemap.TileSize * 2
        );

        // Initial slime position will be the center tile of the tile map.
        int centerRow = _tilemap.Rows / 2;
        int centerColumn = _tilemap.Columns / 2;
        _slimePosition = new Vector2(centerColumn, centerRow) * _tilemap.TileSize;

        // Initial bat position will the in the top left corner of the room
        _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top);

        // Set the position of the score text to align to the left edge of the
        // room bounds, and to vertically be at the center of the first tile.
        _scoreTextPosition = new Vector2(_roomBounds.Left, _tilemap.TileSize * 0.5f);

        // Set the origin of the text so it's left-centered.
        float scoreTextYOrigin = _font.MeasureString(&quot;Score&quot;).Y * 0.5f;
        _scoreTextOrigin = new Vector2(0, scoreTextYOrigin);

        // Assign the initial random velocity to the bat.
        AssignRandomBatVelocity();
    }

    public override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);

        // Load the tilemap from the XML configuration file.
        _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);

        // Load the bounce sound effect
        _bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

        // Load the collect sound effect
        _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

        // Load the font
        _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/gameFont&quot;);

        // Load the sound effect to play when ui actions occur.
        SoundEffect uiSoundEffect = Core.Content.Load&lt;SoundEffect&gt;(&quot;audio/ui&quot;);

        // Create the UI Controller
        UIElementController controller = new UIElementController();

        // Create the pause menu.
        CreatePauseMenu(atlas, uiSoundEffect, controller);

        // Create the game over menu.
        CreateGameOverMenu(atlas, uiSoundEffect, controller);
    }

    private void CreatePauseMenu(TextureAtlas atlas, SoundEffect soundEffect, UIElementController controller)
    {
        // Create the root container for the paused menu.
        _pauseMenu = new UISprite();
        _pauseMenu.Sprite = atlas.CreateSprite(&quot;overlay-pixel&quot;);
        _pauseMenu.Sprite.Scale = Core.GraphicsDevice.PresentationParameters.Bounds.Size.ToVector2();
        _pauseMenu.Controller = controller;
        _pauseMenu.IsSelected = true;
        _pauseMenu.IsEnabled = _pauseMenu.IsVisible = false;

        // Create the paused panel as a child of the paused menu.
        UISprite pausePanel = _pauseMenu.CreateChild&lt;UISprite&gt;();
        pausePanel.Sprite = atlas.CreateSprite(&quot;panel&quot;);
        pausePanel.Position = new Vector2(215, 249);

        // Create the paused text as a child of the paused panel.
        UISprite pausedText = pausePanel.CreateChild&lt;UISprite&gt;();
        pausedText.Sprite = atlas.CreateSprite(&quot;paused-label&quot;);
        pausedText.Position = new Vector2(42, 42);

        // Create the resume button as a child of the paused panel.
        UIButton resumeButton = pausePanel.CreateChild&lt;UIButton&gt;();
        resumeButton.NotSelectedSprite = atlas.CreateSprite(&quot;resume-button&quot;);
        resumeButton.NotSelectedSprite.CenterOrigin();
        resumeButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;resume-button-selected&quot;);
        resumeButton.SelectedSprite.CenterOrigin();
        resumeButton.Position = new Vector2(148, 148);
        resumeButton.IsSelected = true;

        // Create the quite button as a child of the paused panel.
        UIButton quitButton = pausePanel.CreateChild&lt;UIButton&gt;();
        quitButton.NotSelectedSprite = atlas.CreateSprite(&quot;quit-button&quot;);
        quitButton.NotSelectedSprite.CenterOrigin();
        quitButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;quit-button-selected&quot;);
        quitButton.SelectedSprite.CenterOrigin();
        quitButton.Position = new Vector2(691, 148);

        // Wire up the actions to perform when the Right action is triggered
        // for the menu.
        _pauseMenu.LeftAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (quitButton.IsSelected)
            {
                // The quit button is selected and the left action was
                // performed, so deselect the quit button and select the resume
                // button.
                quitButton.IsSelected = false;
                resumeButton.IsSelected = true;
            }
        };

        // Wire up the actions to perform when the Right action is triggered
        // for the menu.
        _pauseMenu.RightAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (resumeButton.IsSelected)
            {
                // The resume button is selected and the right action was
                // performed, so deselect the resume button and select the quit
                // button
                resumeButton.IsSelected = false;
                quitButton.IsSelected = true;
            }
        };

        // Wire up the actions to perform when the Confirm action is triggered
        // for the menu.
        _pauseMenu.ConfirmAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (resumeButton.IsSelected)
            {
                // The resume button is selected and the confirm action was
                // performed, so unpause the game by disabling the pause menu.
                _pauseMenu.IsEnabled = _pauseMenu.IsVisible = _pauseMenu.IsSelected = false;
            }
            else if (quitButton.IsSelected)
            {
                // The quit button is selected and the confirm action was
                // performed, so quit the game by changing the scene back to the
                // title scene.
                Core.ChangeScene(new TitleScene());
            }
        };

        // Wire up the actions to perform when the Cancel action is triggered
        // for the menu.
        _pauseMenu.CancelAction = () =&gt;
        {
            // Play the sound effect.
            Core.Audio.PlaySoundEffect(soundEffect);

            // Unpause the game by disabling the paused menu.
            _pauseMenu.IsEnabled = _pauseMenu.IsVisible = _pauseMenu.IsSelected = false;
        };
    }

    private void CreateGameOverMenu(TextureAtlas atlas, SoundEffect soundEffect, UIElementController controller)
    {
        // Create the root container for the game over menu.
        _gameOverMenu = new UISprite();
        _gameOverMenu.Sprite = atlas.CreateSprite(&quot;overlay-pixel&quot;);
        _gameOverMenu.Sprite.Scale = Core.GraphicsDevice.PresentationParameters.Bounds.Size.ToVector2();
        _gameOverMenu.Controller = controller;
        _gameOverMenu.IsSelected = true;
        _gameOverMenu.IsEnabled = _gameOverMenu.IsVisible = false;

        // Create the game over panel as a child of the game over menu.
        UISprite gameOverPanel = _gameOverMenu.CreateChild&lt;UISprite&gt;();
        gameOverPanel.Sprite = atlas.CreateSprite(&quot;panel&quot;);
        gameOverPanel.Position = new Vector2(215, 249);

        // Create the game over text as a child of the game over panel.
        UISprite gameOverText = gameOverPanel.CreateChild&lt;UISprite&gt;();
        gameOverText.Sprite = atlas.CreateSprite(&quot;game-over-label&quot;);
        gameOverText.Position = new Vector2(42, 42);

        // Create the retry button as a child of the game over panel.
        UIButton retryButton = gameOverPanel.CreateChild&lt;UIButton&gt;();
        retryButton.NotSelectedSprite = atlas.CreateSprite(&quot;retry-button&quot;);
        retryButton.NotSelectedSprite.CenterOrigin();
        retryButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;retry-button-selected&quot;);
        retryButton.SelectedSprite.CenterOrigin();
        retryButton.Position = new Vector2(148, 148);

        // Create the quit button as a child of the game over panel.
        UIButton quitButton = gameOverPanel.CreateChild&lt;UIButton&gt;();
        quitButton.NotSelectedSprite = atlas.CreateSprite(&quot;quit-button&quot;);
        quitButton.NotSelectedSprite.CenterOrigin();
        quitButton.SelectedSprite = atlas.CreateAnimatedSprite(&quot;quit-button-selected&quot;);
        quitButton.SelectedSprite.CenterOrigin();
        quitButton.Position = new Vector2(691, 148);

        // Wire up the actions to perform when the Right action is triggered
        // for the menu.
        _gameOverMenu.LeftAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (quitButton.IsSelected)
            {
                // The quit button is selected and the left action was
                // performed, so deselect the quit button and select the retry
                // button.
                quitButton.IsSelected = false;
                retryButton.IsSelected = true;
            }
        };

        // Wire up the actions to perform when the Right action is triggered
        // for the menu.
        _gameOverMenu.RightAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (retryButton.IsSelected)
            {
                // The retry button is selected and the right action was
                // performed, so deselect the retry button and select the quit
                // button.
                retryButton.IsSelected = false;
                quitButton.IsSelected = true;
            }
        };

        // Wire up the actions to perform when the Confirm action is triggered
        // for the menu.
        _gameOverMenu.ConfirmAction = () =&gt;
        {
            // Play the sound effect
            Core.Audio.PlaySoundEffect(soundEffect);

            if (retryButton.IsSelected)
            {
                // The retry button is selected and the confirm action was
                // performed, so deselect the game over menu.
                _gameOverMenu.IsEnabled = _gameOverMenu.IsVisible = _gameOverMenu.IsSelected = false;
            }
            else if (quitButton.IsSelected)
            {
                // The quite button is selected and the confirm action was
                // performed, so change the scene back to the title scene.
                Core.ChangeScene(new TitleScene());
            }
        };
    }

    public override void Update(GameTime gameTime)
    {
        _pauseMenu.Update(gameTime);
        _gameOverMenu.Update(gameTime);
        if (!_pauseMenu.IsEnabled &amp;&amp; !_gameOverMenu.IsEnabled)
        {
            UpdateGame(gameTime);
        }
    }

    private void UpdateGame(GameTime gameTime)
    {
        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        // Creating a bounding circle for the slime
        Circle slimeBounds = new Circle(
            (int)(_slimePosition.X + (_slime.Width * 0.5f)),
            (int)(_slimePosition.Y + (_slime.Height * 0.5f)),
            (int)(_slime.Width * 0.5f)
        );

        // Use distance based checks to determine if the slime is within the
        // bounds of the game screen, and if it's outside that screen edge,
        // move it back inside.
        if (slimeBounds.Left &lt; _roomBounds.Left)
        {
            _slimePosition.X = _roomBounds.Left;
        }
        else if (slimeBounds.Right &gt; _roomBounds.Right)
        {
            _slimePosition.X = _roomBounds.Right - _slime.Width;
        }

        if (slimeBounds.Top &lt; _roomBounds.Top)
        {
            _slimePosition.Y = _roomBounds.Top;
        }
        else if (slimeBounds.Bottom &gt; _roomBounds.Bottom)
        {
            _slimePosition.Y = _roomBounds.Bottom - _slime.Height;
        }

        // Calculate the new position of the bat based on the velocity
        Vector2 newBatPosition = _batPosition + _batVelocity;

        // Create a bounding circle for the bat
        Circle batBounds = new Circle(
            (int)(newBatPosition.X + (_bat.Width * 0.5f)),
            (int)(newBatPosition.Y + (_bat.Height * 0.5f)),
            (int)(_bat.Width * 0.5f)
        );

        Vector2 normal = Vector2.Zero;

        // Use distance based checks to determine if the bat is within the
        // bounds of the game screen, and if it's outside that screen edge,
        // reflect it about the screen edge normal
        if (batBounds.Left &lt; _roomBounds.Left)
        {
            normal.X = Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Left;
        }
        else if (batBounds.Right &gt; _roomBounds.Right)
        {
            normal.X = -Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Right - _bat.Width;
        }

        if (batBounds.Top &lt; _roomBounds.Top)
        {
            normal.Y = Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Top;
        }
        else if (batBounds.Bottom &gt; _roomBounds.Bottom)
        {
            normal.Y = -Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Bottom - _bat.Height;
        }

        // If the normal is anything but Vector2.Zero, this means the bat had
        // moved outside the screen edge so we should reflect it about the
        // normal.
        if (normal != Vector2.Zero)
        {
            _batVelocity = Vector2.Reflect(_batVelocity, normal);

            // Play the bounce sound effect
            Core.Audio.PlaySoundEffect(_bounceSoundEffect);
        }

        _batPosition = newBatPosition;

        if (slimeBounds.Intersects(batBounds))
        {
            // Choose a random row and column based on the total number of each
            int column = Random.Shared.Next(1, _tilemap.Columns - 1);
            int row = Random.Shared.Next(1, _tilemap.Rows - 1);

            // Change the bat position by setting the x and y values equal to
            // the column and row multiplied by the width and height.
            _batPosition = new Vector2(column * _bat.Width, row * _bat.Height);

            // Assign a new random velocity to the bat
            AssignRandomBatVelocity();

            // Play the collect sound effect
            Core.Audio.PlaySoundEffect(_collectSoundEffect);

            // Increase the player's score.
            _score += 100;
        }
    }

    private void AssignRandomBatVelocity()
    {
        // Generate a random angle
        float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2);

        // Convert angle to a direction vector
        float x = (float)Math.Cos(angle);
        float y = (float)Math.Sin(angle);
        Vector2 direction = new Vector2(x, y);

        // Multiply the direction vector by the movement speed
        _batVelocity = direction * MOVEMENT_SPEED;
    }

    private void CheckKeyboardInput()
    {
        // Get a reference to the keyboard info
        KeyboardInfo keyboard = Core.Input.Keyboard;

        // If the escape key is pressed, return to the title screen
        if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Escape))
        {
            _pauseMenu.IsEnabled = _pauseMenu.IsVisible = _pauseMenu.IsSelected = true;
        }

        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (keyboard.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (keyboard.IsKeyDown(Keys.W) || keyboard.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (keyboard.IsKeyDown(Keys.S) || keyboard.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (keyboard.IsKeyDown(Keys.A) || keyboard.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (keyboard.IsKeyDown(Keys.D) || keyboard.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }

        // If the M key is pressed, toggle mute state for audio.
        if (keyboard.WasKeyJustPressed(Keys.M))
        {
            Core.Audio.ToggleMute();
        }

        // If the + button is pressed, increase the volume.
        if (keyboard.WasKeyJustPressed(Keys.OemPlus))
        {
            Core.Audio.IncreaseVolume(0.1f);
        }

        // If the - button was pressed, decrease the volume.
        if (keyboard.WasKeyJustPressed(Keys.OemMinus))
        {
            Core.Audio.DecreaseVolume(0.1f);
        }
    }

    private void CheckGamePadInput()
    {
        // Get the gamepad info for gamepad one.
        GamePadInfo gamePadOne = Core.Input.GamePads[(int)PlayerIndex.One];

        if (gamePadOne.WasButtonJustPressed(Buttons.Start))
        {
            _pauseMenu.IsEnabled = _pauseMenu.IsVisible = _pauseMenu.IsSelected = true;
        }

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadOne.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
        }
        else
        {
            GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadOne.LeftThumbStick != Vector2.Zero)
        {
            _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
            _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    public override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        Core.GraphicsDevice.Clear(new Color(32, 40, 78, 255));

        // Begin the sprite batch to prepare for rendering.
        Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the tilemap
        _tilemap.Draw(Core.SpriteBatch);

        // Draw the slime sprite.
        _slime.Draw(Core.SpriteBatch, _slimePosition);

        // Draw the bat sprite.
        _bat.Draw(Core.SpriteBatch, _batPosition);

        // Draw the score
        Core.SpriteBatch.DrawString(
            _font,              // spriteFont
            $&quot;Score: {_score}&quot;, // text
            _scoreTextPosition, // position
            Color.White,        // color
            0.0f,               // rotation
            _scoreTextOrigin,   // origin
            1.0f,               // scale
            SpriteEffects.None, // effects
            0.0f                // layerDepth
        );

        _pauseMenu.Draw(Core.SpriteBatch);
        _gameOverMenu.Draw(Core.SpriteBatch);

        // Always end the sprite batch when finished.
        Core.SpriteBatch.End();
    }
}
</code></pre>
<p>The key changes made here are:</p>
<ul>
<li>New fields <code>_pauseMenu</code> and <code>gameOverMenu</code> were added to serve as root <code>UIElement</code> containers for each menu.</li>
<li>The <code>LoadContent</code> method now loads the UI assets and creates the necessary menus.</li>
<li>The <code>Update</code> method updates both the pause and game over panels.  Internally, if these panels are disabled, no actual update happens to them so we don't need to check for the <code>IsEnabled</code> state explicitly.  However, we do perform a check to see if either menu is enabled before updating the game.  We do not want the actual game updating if either the pause or game over menu is enabled.</li>
<li>The game update code was moved to its own function called <code>UpdateGame</code>.</li>
<li>When keyboard input is checked, if the Escape key is pressed, the game will now enable the pause menu instead of exiting back to the title scene.  The same was updated for gamepad input when the Start button is pressed.</li>
<li>In <code>Draw</code> both the pause menu and the game over menu are drawn.  Same as with update, we do not need to explicitly check if they are visible first, as internally they will not draw if not visible.</li>
</ul>
<p>Running the game now, when selecting the &quot;Start&quot; button on the title scene and pressing the Enter key, the game starts as expected.  Now, if you press the Escape key on the keyboard, instead of exiting back to the title scene as before, the pause menu will be shown.  From here, players can choose to either resume gameplay or quit back to the title menu.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/gamescene.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 19-3: The game scene now with a pause menu when the user presses the Escape key where they can resume gameplay from or quit back to the title scene</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>While we did implement a game over menu, currently our game has no game over condition, so it won't be shown.  We'll implement the rest of the game in the next chapter, including a game over condition, where the game over menu will then be shown.</p>
</div>
<h2 id="accessibility-in-game-ui">Accessibility in Game UI</h2>
<p>Creating accessible user interfaces is an essential aspect of inclusive game design.  Accessibility ensures that your game can be played by a broader audience, including players with visual acuity or other specific needs.  When designing your UI system, consider some of these key accessibility principles:</p>
<h3 id="visual-accessibility">Visual Accessibility</h3>
<ul>
<li><strong>Color contrast</strong>: Ensure sufficient contrast between text and backgrounds</li>
<li><strong>Use shapes</strong>: Don't rely solely on color to convey important information; add shapes, patterns, or text labels as well.  For example, if displaying warning text, also use something such as the common warning sign ⚠️.</li>
<li><strong>Text size and scaling</strong>: Allow players to adjust text size or implement a UI scaling option.  In MonoGame, this can be achieved by applying scaling factors to your UI elements or by having multiple font sizes available.</li>
<li><strong>Internationalization (i18n)</strong>: Consider how your UI might be interpreted across different cultures and regions. Number formatting can vary significantly - some regions use periods for thousands separators (1.000.000) while others use commas (1,000,000). Control symbolism also differs culturally; for example, on console controllers, the Cross button typically means &quot;Select&quot; in Western regions but &quot;Cancel&quot; in Japan, with Circle having the opposite meaning.</li>
</ul>
<h3 id="input-accessibility">Input Accessibility</h3>
<ul>
<li><p><strong>Input redundancy</strong>: Support multiple input methods for the same action. Our <code>IUIElementController</code> interface already provides a foundation for this by abstracting input detection.</p>
</li>
<li><p><strong>Reduce input precision requirements</strong>: While our UI system does not use mouse input, when creating oen that does, implement generous hitboxes for clickable UI elements to help players with motor control difficulties.</p>
</li>
</ul>
<h3 id="implementation-in-our-ui-system">Implementation in Our UI System</h3>
<p>Our current UI system already has a foundation that can be expanded to support more accessibility features such as scaling the UI elements:</p>
<pre><code class="lang-cs">// Example of adding an accessible ui element that has a scale factor.
public class AccessibleUIElement : UIElement
{
    
    public float ScaleFactor {get; set;}

    public float AbsoluteScaleFactor
    {
        get
        {
            if (Parent is UIElement parent)
            {
                return parent.AbsoluteScaleFactor * ScaleFactor;
            }

            return ScaleFactor;
        }
    }
}
</code></pre>
<h3 id="testing-for-accessibility">Testing for Accessibility</h3>
<p>The most effect way to ensure accessibility is through testing under different circumstances and with diverse users:</p>
<ul>
<li>Test your Ui using only keyboard navigation.</li>
<li>Try playing without sound.</li>
<li>Check your UI with a color blindness simulator.</li>
<li>Adjust the display scale to simulate low vision.</li>
<li>Get feedback from player with different abilities.</li>
</ul>
<p>By considering accessibility early in development rather than as an afterthought, you create games that can be enjoyed by more players while also often improving the experience for everyone.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Created a flexible <code>UIElement</code> base class that establishes a parent-child hierarchy for organizing UI components.</li>
<li>Implemented specialized UI components including sprites, buttons, and sliders.</li>
<li>Developed an input-agnostic control system through the <code>IUIElementController</code> interface.</li>
<li>Built interactive menus for our game; a title menu with options screen and a pause menu.</li>
<li>Applied navigation logic to create a complete keyboard/gamepad friendly interface.</li>
<li>Discussed accessibility considerations for inclusive game design.</li>
</ul>
<p>In the next chapter, we'll complete our game by polishing the gameplay experience and implementing win and loss conditions.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What are the some advantages of using a parent-child relationship in UI systems?</p>
<div class="question-answer">
<ul>
<li>Inheritance of properties: visual states cascade parent to children.</li>
<li>Relative positioning: Child elements are positioned relative to their parents.</li>
<li>Simplified state management: Parent states affect children automatically.</li>
<li>Batch operations: Update and draw calls propagate through the hierarchy.</li>
<li>Logical grouping: Mirrors the conceptual organization of UI elements.</li>
</ul>
</div>
</li>
<li><p>In the UI system we implemented, how does a <code>UIElement</code> determine if it should be enabled or visible?</p>
<div class="question-answer"><p>The <code>UIElement</code> class first checks if it has a parent element.  If it does and that parent element is disabled or invisible, then the child element is automatically considered disabled or invisible, regardless of its own internal state.  Otherwise, it returns its own internal enabled or visible state.  This creates a cascade effect where disabling or hiding a parent automatically disables or hides its children.</p>
</div>
</li>
<li><p>In the UI system we implemented, what is the purposed of the <code>IUIElementController</code> interface?</p>
<div class="question-answer"><p>The <code>IUIElementController</code> interface provides a device agnostic method for handling UI navigation.  It abstracts input detection (keyboard, gamepad, touch, etc) into a consistent set of navigation and action methods.  This allows UI elements to respond to user input without being tied to specific input devices, making it a more flexible and maintainable system.</p>
</div>
</li>
<li><p>What are some accessibility considerations that should be implemented in game UI systems?</p>
<div class="question-answer">
<ul>
<li>Visual accessibility: High contrast colors, not relying solely on color for information, adjustable text size and UI scaling, and internationalization support.</li>
<li>Input accessibility: Support for multiple input methods and reduced precision requirements.</li>
<li>Testing practices: Ensure the UI works with keyboard only navigation, without sound, and with simulated visual impairments.</li>
</ul>
<p>Implementing these considerations makes games playable by a wider audience and often improves the experience for all players.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
