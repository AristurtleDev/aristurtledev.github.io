<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-25-packaging-your-game-for-distribution">Chapter 25: Packaging Your Game for Distribution</h1>
<p class="text-secondary">Learn how to package your game for distribution across Windows, macOS, and Linux platforms.</p>
<p>After all of our work creating Dungeon Slime, we need to prepare the game for distribution to players.  Properly packaging your game ensure it runs correctly on different platforms without requiring players to have development tools installed.</p>
<p>In this chapter you will:</p>
<ul>
<li>Learn how to prepare your game for release.</li>
<li>Package your game for Windows, macOS, and Linux platforms.</li>
<li>Create platform-specific distributions with appropriate configurations.</li>
<li>Understand important publishing parameters and their impact on game performance.</li>
<li>Address common cross-platform distribution challenges.</li>
<li>Learn about third-party tools that can automate the packaging process.</li>
</ul>
<h2 id="understanding-game-packaging">Understanding Game Packaging</h2>
<p>When developing with MonoGame, you are working in a .NET environment that abstracts away many platform-specific details.  However, when distributing your game to players, you need to ensure they can run it without installing the .NET runtime or other development dependencies.</p>
<h3 id="self-contained-deployments">Self-Contained Deployments</h3>
<p>The recommended approach for distributing MonoGame games is to use self-contained deployments.  This approach packages your game with all necessary .NET dependencies, resulting in a larger distribution but ensuring your game runs without requiring players install additional runtimes.</p>
<p>A self-contained deployment offers several advantages:</p>
<ul>
<li>Players can run your game without installing the .NET runtime.</li>
<li>Your game will always use the exact version of the runtime it was developed with.</li>
<li>Distribution is simplified with fewer external dependencies.</li>
</ul>
<p>The main trade-off is a larger distribution size compared to framework-dependent deployments, but this is usually worth it for the improved player experience.</p>
<h2 id="preparing-your-game-for-release">Preparing Your Game for Release</h2>
<p>Before packaging your game for distribution, you should take some preparatory steps:</p>
<ol>
<li><strong>Set Release Configuration</strong>: Ensure your build configuration is set to &quot;Release&quot; rather than &quot;Debug&quot; for better performance and smaller executable size.</li>
<li><strong>Update Game Information</strong>: Verify your game's title, version, and other information in the project's properties file (<em>.csproj</em>).</li>
<li><strong>Final Testing</strong>: Perform thorough testing in Release mode ot catch any issue that might not appear in Debug mode.</li>
<li><strong>Asset Optimization</strong>: Consider optimizing larger content files to reduce the final package size.</li>
</ol>
<h2 id="platform-specific-packaging">Platform-Specific Packaging</h2>
<p>Now that we understand the general packaging concepts, we will explore how to create distributions for WIndows, macOS, and Linux.  Each platform has specific requirements and tooling that we will need to navigate.  Choose the instructions below based on the platform you are using.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>The packaging instructions for each platform are designed to be executed on that same platform.  This is because each operating system provides specific tools needed for proper packaging (like <code>lipo</code> on macOS or permission settings on Unix-based systems).  When building on Windows for macOS or Linux, the executable permissions cannot be set since Windows lacks this concept.</p>
<p>While you will need access to each platform for the steps below, do not worry if you do not have all these systems available.  At the end of this chapter, third party libraries provided by MonoGame community members are included that can automate these processes for you without requiring you to own each type of machine.</p>
</div>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_windows" role="tab" aria-controls="tabpanel_1_windows" data-tab="windows" tabindex="0" aria-selected="true">Windows</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_macOS" role="tab" aria-controls="tabpanel_1_macOS" data-tab="macOS" tabindex="-1">macOS</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_linux" role="tab" aria-controls="tabpanel_1_linux" data-tab="linux" tabindex="-1">Linux</a>
</li>
</ul>
<section id="tabpanel_1_windows" role="tabpanel" data-tab="windows">

<p>Windows is the most straightforward platform to target since MonoGame development typically happens on Windows machines.</p>
<h4 id="building-for-windows">Building for Windows</h4>
<p>To create a self-contained application for Window, open a new command prompt window in the same folder as the as the main game project (in our case the folder with the <em>DungeonSlime.csproj</em> file) and execute the following .NET CLI command:</p>
<pre><code class="lang-sh">dotnet publish -c Release -r win-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained
</code></pre>
<p>This command specifies:</p>
<ul>
<li><code>-c Release</code>: Builds in Release configuration for better performance.</li>
<li><code>-r win-x64</code>: Targets 64-bit Windows platforms.</li>
<li><code>-p:PublishReadyToRun=false</code>: Disables ReadyToRun compilation (explained later).</li>
<li><code>-p:TieredCompilation=false</code>: Disables Tiered Compilation (explained later).</li>
<li><code>--self-contained</code>: Includes the .NET runtime in the package.</li>
</ul>
<p>The output will be placed in a directory like <em>bin/Release/net8.0/win-x64/publish/</em>, relative to the game's <em>.csproj</em> file.  This directory will contain the executable and all necessary files to run your game.</p>
<h4 id="creating-a-windows-distribution">Creating a Windows Distribution</h4>
<p>Once you have created a build for Windows, to create a Windows distribution, you can simply:</p>
<ol>
<li>Zip the entire contents of the publish folder.</li>
<li>Distribute the ZIP file to your players.</li>
<li>Players can extract the ZIP and run the executable directly.</li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>If you are using the WindowsDX platform target, players may need to install the <a href="https://www.microsoft.com/en-us/download/details.aspx?id=8109">DirectX June 2010 Runtime</a> for audio and gamepad support.  If you are targeting this platform, consider including this information in your game's documentation.</p>
</div>
</section>
<section id="tabpanel_1_macOS" role="tabpanel" data-tab="macOS" aria-hidden="true" hidden="hidden">

<p>Packaging for macOS requires creating an <strong>Application Bundle</strong> (<em>.app</em>), which is a directory structure that macOS recognizes as an application.</p>
<h4 id="building-for-macos">Building for macOS</h4>
<p>For macOS, you will need to build for both the Intel (x64) and Apple Silicon (arm64) to support all modern mac computers.  Open a new terminal window in the same folder as the <em>DungeonSlime.csproj</em> file (the main game project).</p>
<div class="TIP">
<h5>Tip</h5>
<p>The following sections will guide you through several terminal commands that build on each other.  It is best to use a single terminal window located in your projects root directory (where the <em>DungeonSlime.csproj</em> file is) for all of these steps to ensure paths remain consistent.</p>
</div>
<p>First, to create the Intel (x64) self contained application, execute the following .NET CLI command in the terminal:</p>
<pre><code class="lang-sh">dotnet publish -c Release -r osx-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained
</code></pre>
<p>This command specifies:</p>
<ul>
<li><code>-c Release</code>: Builds in Release configuration for better performance.</li>
<li><code>-r osx-x64</code>: Targets Intel (x64) macOS platforms.</li>
<li><code>-p:PublishReadyToRun=false</code>: Disables ReadyToRun compilation (explained later).</li>
<li><code>-p:TieredCompilation=false</code>: Disables Tiered Compilation (explained later).</li>
<li><code>--self-contained</code>: Includes the .NET runtime in the package.</li>
</ul>
<p>The output from this command will be placed in a directory like <em>bin/Release/net8.0/osx-x64/publish/</em>, relative to the game's <em>.csproj</em> file.</p>
<p>Next, to create the Apple Silicon (arm64) self contained application for macOS, in the same terminal window, execute the following .NET CLI command:</p>
<pre><code class="lang-sh">dotnet publish -c Release -r osx-arm64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained
</code></pre>
<p>The only difference in this command is the use of <code>-r osx-arm64</code> which specifies to target the Apple Silicon (arm64) macOS platform.</p>
<p>The output from this command will be placed in a directory like <em>bin/Release/net8.0/osx-arm64/publish/</em>, relative to the game's <em>.csproj</em> file.</p>
<h4 id="creating-a-macos-application-bundle">Creating a macOS Application Bundle</h4>
<p>With the Intel (x64) and Apple Silicon (arm64) builds completed, we can now create the macOS <strong>Application Bundle</strong>.  macOS applications follow a very specific directory structure:</p>
<pre><code class="lang-sh">YourGame.app/
├── Contents/
│   ├── Info.plist
│   ├── MacOS/
│   │   └── YourGame
│   └── Resources/
│       ├── Content/
│       └── YourGame.icns
</code></pre>
<p>To create this structure, from the same terminal window:</p>
<ol>
<li><p>First, create the folder structure by executing the following commands:</p>
<pre><code class="lang-sh">mkdir -p bin/Release/DungeonSlime.app/Contents/MacOS/
mkdir -p bin/Release/DungeonSlime.app/Contents/Resources/Content
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>mkdir -p</code> command creates directories including any necessary parent directories.  The <code>-p</code> flag ensures all intermediate directories are created without error if they do not exist yet.</p>
</div>
</li>
<li><p>Combine the Intel (x64) and Apple Silicon (arm64) builds into a <em>universal binary</em>.  To do this, execute the following commands:</p>
<pre><code class="lang-sh">lipo -create bin/Release/net8.0/osx-arm64/publish/DungeonSlime bin/Release/net8.0/osx-x64/publish/DungeonSlime -output bin/Release/DungeonSlime.app/Contents/MacOS/DungeonSlime
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>lipo</code> command is a macOS utility that works with multi-architecture binaries.  Here, it combines the Intel (x64) and Apple Silicon (arm64) executables into a single &quot;universal binary&quot; that can run natively on both Apple Silicon and Intel processor based Macs.</p>
</div>
</li>
<li><p>Next, copy the your content files to the expected location within the application bundle structure.  To do this, execute the following commands:</p>
<pre><code class="lang-sh">cp -R bin/Release/net8.0/Content bin/Release/DungeonSlime.app/Contents/Resources/Content
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>cp -R</code> command copies files recursively, meaning it will copy the entire directory structure.  The <code>-R</code> flag ensures all subdirectories and their contents are copied.</p>
</div>
</li>
<li><p>Create a new file called <em>Info.plist</em> in the <em>Contents</em> directory of the application bundle with the following command:</p>
<pre><code class="lang-sh">touch bin/Release/DungeonSlime.app/Contents/Info.plist
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>touch</code> command creates an empty file if it does not exist or updates the modification time if it does exist.  We are using it here to create a blank file that we will populate with content in the next step.</p>
</div>
</li>
<li><p>Open the <em>Info.plist</em> file you just created in a text editor and add the following content to the file and save it.</p>
<pre><code class="lang-xml" highlight-lines="8,10,12,16,30">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;
    &lt;string&gt;en&lt;/string&gt;
    &lt;key&gt;CFBundleExecutable&lt;/key&gt;
    &lt;string&gt;DungeonSlime&lt;/string&gt;
    &lt;key&gt;CFBundleIconFile&lt;/key&gt;
    &lt;string&gt;DungeonSlime&lt;/string&gt;
    &lt;key&gt;CFBundleIdentifier&lt;/key&gt;
    &lt;string&gt;com.yourdomain.dungeonslime&lt;/string&gt;
    &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
    &lt;string&gt;6.0&lt;/string&gt;
    &lt;key&gt;CFBundleName&lt;/key&gt;
    &lt;string&gt;DungeonSlime&lt;/string&gt;
    &lt;key&gt;CFBundlePackageType&lt;/key&gt;
    &lt;string&gt;APPL&lt;/string&gt;
    &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
    &lt;string&gt;1.0&lt;/string&gt;
    &lt;key&gt;CFBundleSignature&lt;/key&gt;
    &lt;string&gt;FONV&lt;/string&gt;
    &lt;key&gt;CFBundleVersion&lt;/key&gt;
    &lt;string&gt;1&lt;/string&gt;
    &lt;key&gt;LSApplicationCategoryType&lt;/key&gt;
    &lt;string&gt;public.app-category.games&lt;/string&gt;
    &lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;
    &lt;string&gt;10.15&lt;/string&gt;
    &lt;key&gt;NSHumanReadableCopyright&lt;/key&gt;
    &lt;string&gt;Copyright © 2025&lt;/string&gt;
    &lt;key&gt;NSPrincipalClass&lt;/key&gt;
    &lt;string&gt;NSApplication&lt;/string&gt;
    &lt;key&gt;LSRequiresNativeExecution&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;LSArchitecturePriority&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;arm64&lt;/string&gt;
    &lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <em>Info.plist</em> file is a critical component of any macOS application bundle.  It contains essential metadata that macOS uses to:</p>
<ul>
<li>Identify the application (bundle identifier, name, version).</li>
<li>Display the application correctly in Finder and the Dock.</li>
<li>Associate the correct icon with the application.</li>
<li>Define the application's capabilities and requirements.</li>
<li>Provide copyright and developer information.</li>
</ul>
<p>Without a properly formatted <em>Info.plist</em> file, macOS would not recognize your game as a valid application, and users would be unable to launch it through normal means.</p>
</div>
<div class="TIP">
<h5>Tip</h5>
<p>The highlighted sections in the <em>Info.plist</em> file need to be customized for your game:</p>
<ul>
<li>Replace all instances of &quot;DungeonSlime&quot; with your game's name.</li>
<li>The <code>CFBundleIconFile</code> value (line 10) must exactly match the name of your .icns file that we will create in the next step.</li>
<li>Update the bundle identifier on line 12 with your domain.</li>
<li>Modify the copyright information on line 30 as needed.</li>
</ul>
<p>Getting these values right, especially the icon filename, ensures your game appears correctly on macOS.</p>
<p>For more information on the <em>Info.plist</em> manifest file, refer to the <a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html">About Info.plist Keys and Values</a> Apple Developer documentation.</p>
</div>
</li>
<li><p>Next, create the application bundle <em>.icns</em> icon file.  To do this, execute the following commands:</p>
<pre><code class="lang-sh">mkdir -p bin/Release/DungeonSlime.iconset
sips -z 16 16 Icon.png --out bin/Release/DungeonSlime.iconset/icon_16x16.png
sips -z 32 32 Icon.png --out bin/Release/DungeonSlime.iconset/icon_16x16@2x.png
sips -z 32 32 Icon.png --out bin/Release/DungeonSlime.iconset/icon_32x32.png
sips -z 64 64 Icon.png --out bin/Release/DungeonSlime.iconset/icon_32x32@2x.png
sips -z 128 128 Icon.png --out bin/Release/DungeonSlime.iconset/icon_128x128.png
sips -z 256 256 Icon.png --out bin/Release/DungeonSlime.iconset/icon_128x128@2x.png
sips -z 256 256 Icon.png --out bin/Release/DungeonSlime.iconset/icon_256x256.png
sips -z 512 512 Icon.png --out bin/Release/DungeonSlime.iconset/icon_256x256@2x.png
sips -z 512 512 Icon.png --out bin/Release/DungeonSlime.iconset/icon_512x512.png
sips -z 1024 1024 Icon.png --out bin/Release/DungeonSlime.iconset/icon_512x512@2x.png
iconutil -c icns bin/Release/DungeonSlime.iconset --output bin/Release/DungeonSlime.app/Contents/Resources/DungeonSlime.icns
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>These commands create a macOS icon file (<em>.icns</em>) with multiple resolutions:</p>
<ul>
<li><code>sips</code> (Scriptable Image Processing System) resizes the source image to create different icon sizes.</li>
<li>Each size is necessary for different display scenarios in macOS (Dock, Finder, etc.).</li>
<li>The <code>iconutil</code> command then compiles these images into a single <em>.icns</em> file that macOS recognizes as an application icon.</li>
</ul>
</div>
</li>
<li><p>Set executable permissions for the game executable.  To do this, execute the following command:</p>
<pre><code class="lang-sh">chmod +x bin/Release/DungeonSlime.app/Contents/MacOS/DungeonSlime
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>the <code>chmod +x</code> command changes the file permissions to make it executable. WIthout this step, macOS would not be able to run the application.</p>
</div>
</li>
</ol>
<h4 id="distributing-for-macos">Distributing for macOS</h4>
<p>For macOS distribution:</p>
<ol>
<li><p>Archive the application bundle using the tar.gz archive format to preserve the executable permissions that were set.  To do this, execute the following command in the same terminal window:</p>
<pre><code class="lang-sh">tar -czf DungeonSlime-osx.tar.gz -C bin/Release/DungeonSlime.app
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>tar</code> command creates an archive file:</p>
<ul>
<li><code>-c</code> creates a new archive.</li>
<li><code>-z</code> compresses the archive using gzip.</li>
<li><code>-f</code> specifies the filename to create</li>
<li><code>-C</code> changes to the specified directory before adding files.</li>
</ul>
<p>Unlike ZIP files, the tar.gz format preserves Unix file permissions, which is crucial for maintaining the executable permission we set in the previous steps.</p>
</div>
</li>
<li><p>Distribute the tar.gz archive file to players.</p>
</li>
<li><p>Players can extract the tar.gz archive file and run the application bundle to play the game.</p>
</li>
</ol>
</section>
<section id="tabpanel_1_linux" role="tabpanel" data-tab="linux" aria-hidden="true" hidden="hidden">

<p>Linux packaging is relatively straightforward, but requires attention to ensure executable permission are set.</p>
<h4 id="building-for-linux">Building for Linux</h4>
<p>To create a self-contained application for LInux, open a new Terminal window in the same folder as the <em>DungeonSlime.csproj</em> file (your main game project folder) and execute the following .NET CLI command:</p>
<pre><code class="lang-sh">dotnet publish -c Release -r linux-x64 -p:PublishReadyToRun=false -p:TieredCompilation=false --self-contained
</code></pre>
<ul>
<li><code>-c Release</code>: Builds in Release configuration for better performance.</li>
<li><code>-r linux-x64</code>: Targets 64-bit Linux platforms.</li>
<li><code>-p:PublishReadyToRun=false</code>: Disables ReadyToRun compilation (explained later).</li>
<li><code>-p:TieredCompilation=false</code>: Disables Tiered Compilation (explained later).</li>
<li><code>--self-contained</code>: Includes the .NET runtime in the package.</li>
</ul>
<p>The output will be placed in a directory like <em>bin/Release/net8.0/linux-x64/publish</em>, relative to the <em>DungeonSlime.csproj</em> file.  This folder will contain the executable and all necessary files to run the game.</p>
<h4 id="creating-a-linux-distribution">Creating a Linux Distribution</h4>
<p>Once you have created a build for Linux, to create a distributable archive:</p>
<ol>
<li><p>Ensure the main executable has proper execute permissions by executing the following command in the same terminal window:</p>
<pre><code class="lang-sh">chmod +x bin/Release/net8.0/linux-x64/publish/DungeonSlime
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>the <code>chmod +x</code> command changes the file permissions to make it executable. WIthout this step, Linux would not be able to run the application.</p>
</div>
</li>
<li><p>Package the game using the tar.gz archive format to preserve executable permissions by executing the following command:</p>
<pre><code class="lang-sh">tar -czf DungeonSlime-linux-x64.tar.gz -C bin/Release/net8.0/linux-x64/publish/
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>tar</code> command creates an archive file:</p>
<ul>
<li><code>-c</code> creates a new archive.</li>
<li><code>-z</code> compresses the archive using gzip.</li>
<li><code>-f</code> specifies the filename to create</li>
<li><code>-C</code> changes to the specified directory before adding files.</li>
</ul>
<p>Unlike ZIP files, the tar.gz format preserves Unix file permissions, which is crucial for maintaining the executable permission we set in the previous step.</p>
</div>
</li>
</ol>
</section>
</div>
<h2 id="important-net-publishing-parameters">Important .NET Publishing Parameters</h2>
<p>When publishing your game, there are several .NET parameters that can significantly impact the performance of the game.  In the above sections, these are all set to the recommended values, however, we will examine them in detail below.</p>
<h3 id="readytorun-r2r">ReadyToRun (R2R)</h3>
<p>ReadyToRun is a feature in .NET that pre-compiles code to improve startup time.  This sounds like a good thing on paper, however, for games, it can lead to micro-stutters during gameplay.</p>
<p>This happens because ReadyToRun-compiled code is initially of lower quality, and the Just-In-Time (JIT) compiler will trigger periodically to optimize the code further.  These optimization passes can cause visible stutters in the game.</p>
<p>For games, it is recommended to disable ReadyToRun by setting <code>-p:PublishReadyToRun=false</code> in your publish command, which we have already included in our examples.</p>
<p>For more information on ReadyToRun, refer to the <a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/ready-to-run">ReadyToRun deployment overview</a> documentation on Microsoft Learn</p>
<h3 id="tiered-compilation">Tiered Compilation</h3>
<p>Tiered compilation is another .NET feature that works similarly to ReadyToRun.  It initially compiles code quickly at a lower optimization level, then recompiles frequently-used methods with higher optimization.</p>
<p>While this improves application startup time, it can also cause stutters during gameplay as methods are recompiled.  It is recommended to disable tiered compilation by setting <code>-p:TieredCompilation=false</code> in your publish command, which we have already included in our examples.</p>
<p>For more information on Tiered Compilation, refer to the <a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#tiered-compilation">Tiered compilation</a> section on Microsoft Learn.</p>
<h3 id="native-aot-ahead-of-time-compilation">Native AOT (Ahead-of-Time) Compilation</h3>
<p>Native AOT compilation (specified with <code>-p:PublishAot=tru</code>) compiles your entire application to native code at build time, eliminating the need for JIT compilation during runtime.  This can provide better performance and a smaller distribution size.</p>
<p>However, AOT has limitations:</p>
<ol>
<li>No support for runtime reflection.</li>
<li>No runtime code generation.</li>
<li>Some third-party libraries your game uses may not be compatible.</li>
</ol>
<p>For MonoGame game, AOT can work well if you avoid these limitations.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Native AoT is recommended for mobile platforms due to its performance benefits and smaller binary size, which are important for mobile devices with limited resources.  Additionally, it is mandatory when targeting console platforms (Xbox, PlayStation, Switch) as these platforms typically do not support JIT compilation for security and performance reasons.</p>
</div>
<p>For more information on Native AOT, refer to the <a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/?tabs=windows%2Cnet8">Native AOT deployment overview</a> documentation on Microsoft Learn.</p>
<h3 id="trimming">Trimming</h3>
<p>Trimming (specified with <code>-p:Trimming:true</code>) removes unused code from your distribution to reduce size.  It is automatically enabled when using AOT.</p>
<p>While trimming can significantly reduce your game's size, it may remove types that appear unused but are accessed indirectly through reflection or generics causing runtime errors.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Trimming can cause issues with content pipeline extensions that are used at runtime.  When the compiler cannot detect that certain types are used (especially with reflection or generic collections), thy might be trimmed away, resulting in &quot;type not found&quot; exceptions when loading content.</p>
<p>If you encounter runtime exceptions about missing types when loading content with trimming enabled, you can resolve this by ensuring the compiler recognizes the types being uset at runtime by making the following call:</p>
<pre><code class="lang-cs">ContentTypeReaderManager.AddTypeCreator(typeof(ReflectiveReader&lt;ReaderType&gt;).FullName, () =&gt; new ReflectiveReader&lt;ReaderType&gt;())
</code></pre>
<p>Where <code>ReaderType</code> is the <code>ContentTypeReader</code> of the content pipeline extension to be preserved.  This call should be made somewhere in your code before loading content that uses these types.</p>
</div>
<p>For more information on Trimming, refer to the <a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained">Trim self-contained applications</a> documentation on Microsoft Learn.</p>
<h3 id="single-file-publishing">Single File Publishing</h3>
<p>Single file publishing packages your entire application into a single executable.  While this sounds convenient, it is essentially a self-extracting archive that extracts to a temporary directory at runtime.</p>
<p>This can significantly increase startup time for larger games and may fail on system with restricted permissions of limited storage.  For this reason, it is not recommended to use this option for games.</p>
<p>For more information on Single File Publishing, refer to the <a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/single-file/overview?tabs=cli">Create a single file for application deployment</a> documentation on Microsoft Learn.</p>
<h2 id="cross-platform-considerations">Cross-Platform Considerations</h2>
<p>When distributing your games across multiple platforms, be aware of these additional considerations:</p>
<h3 id="file-paths">File Paths</h3>
<p>Different operating systems use different path separators (Windows uses backslashes, macOS and Linux use forward slashes).  Always use <code>Path.Combine</code> in your code rather than hardcoding path separators.</p>
<pre><code class="lang-cs">// Incorrect approach - will fail on some platforms
string path = &quot;Content\\images\\atlas-definition.xml&quot;;

// Correct approach, works on all platforms
string path = Path.Combine(&quot;Content&quot;, &quot;images&quot;, &quot;atlas-definition.xml&quot;);
</code></pre>
<h3 id="case-sensitivity">Case Sensitivity</h3>
<p>Windows is case-insensitive for filenames, but macOS and Linux are case-sensitive.  Ensure your asset references use the exact case that matches your files for maximum compatibility.</p>
<pre><code class="lang-cs">// If the content path on disk is:
// images/Atlas.xnb

// On Windows, this would work fine since windows is case-insensitive.
// ON macOS and Linux, this would fail since they are case-sensitive.
Texture2D text = Content.Load&lt;Texture2D&gt;(&quot;images/atlas&quot;);
</code></pre>
<h3 id="external-dependencies">External Dependencies</h3>
<p>Try to minimize external dependencies.  If your game requires additional libraries or runtimes, document these requirements clearly for players.</p>
<div class="NOTE">
<h5>Note</h5>
<p>When publishing to distribution platforms and app stores (such as Steam, Epic Game Sore, App Store, or Google Play), you are typically required to disclose all external dependencies in your privacy policy or a dedicate dependencies section.  This includes third-party libraries, analytics tools, and any software components that your game depends on.</p>
<p>Check specific requirements for each distribution platform you plant to target, as well as requirements by third-party libraries for using them, as disclosure requirements may vary.</p>
</div>
<h2 id="mobile-platforms">Mobile Platforms</h2>
<p>While this tutorial series has focused on creating a 2D game for desktop platforms, MonoGame also offers support for mobile development on Android and iOS.  The game we have built throughout this series could be adapted for touch controls and distributed through mobile app stores with additional work.</p>
<p>Mobile deployment involves several considerations beyond those of desktop platforms:</p>
<ul>
<li>App store submission process and platform-specific requirements.</li>
<li>Platform-specific signing and certification procedures.</li>
<li>Extensive device compatibility testing across various screen sizes and hardware.</li>
<li>Optimization of touch input controls (replacing our keyboard and gamepad input).</li>
<li>Power consumption management and performance optimization for mobile hardware.</li>
</ul>
<p>For the Dungeon Slime game, adapting to mobile would require:</p>
<ul>
<li>Implementing touch controls to replace the keyboard/gamepad movement.</li>
<li>Potentially rethinking game mechanics to suit mobile play patterns.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Mobile deployment for MonoGame games is significantly more complex than desktop deployment and typically requires platform-specific development environments (Android Studio for Android and Xcode for iOS).  A comprehensive guide to mobile deployment will be covered in a future tutorial.</p>
</div>
<p>If you are interested in extending the Dungeon Slime game, or future games, to mobile platforms after completing this tutorial series, these resources provide a good starting point:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/previous-versions/xamarin/android/deploy-test/publishing/">Android Deployment Guide</a></li>
<li><a href="https://learn.microsoft.com/en-us/previous-versions/xamarin/ios/deploy-test/app-distribution/app-store-distribution/publishing-to-the-app-store?tabs=windows">iOS App Store Distribution</a></li>
</ul>
<h2 id="third-party-packaging-tools">Third-Party Packaging Tools</h2>
<p>While the platform-specific packaging steps outlined in this chapter give you complete control over the distribution process, they require multiple commands and potentially access to different operating system.  Fortunately, the MonoGame community has developed several tools that can automate these packaging steps across platforms.</p>
<h3 id="gamebundle">GameBundle</h3>
<p><a href="https://github.com/Ellpeck/GameBundle">GameBundle</a> is a .NET command-line tool created by <a href="https://github.com/Ellpeck">Ellpeck</a> that simplifies packaging MonoGame and other .NET applications into several distributable formats.  As described in its documentation, &quot;GameBundle is a tool to package MonoGame and other .NET applications into several distributable formats.&quot;</p>
<p>This tool can automatically bundle your game for Windows, Linux, and macOS platforms, create applications bundles for macOS, and handle various packaging configurations with a single command.</p>
<p>For more information about GameBundle, including installation and usage instructions, visit the <a href="https://github.com/Ellpeck/GameBundle">official repository on GitHub</a></p>
<h3 id="monopack">MonoPack</h3>
<p><a href="https://github.com/shyfox-studio/MonoPack">MonoPack</a> is a .NET command-line tool created by <a href="https://github.com/shyfox-studio">ShyFox Studio</a> designed specifically for MonoGame projects.  According to its documentation, &quot;MonoPack is a dotnet tool used for MonoGame projects to package the game for Windows, Linux, and/or macOS&quot;.</p>
<p>Key features include:</p>
<ul>
<li>Cross-platform packaging capabilities (build for any OS from any OS).</li>
<li>Automatic creation of macOS application bundles.</li>
<li>Appropriate compression formats for each target platform for distribution.</li>
</ul>
<p>For more information about MonoPack, including installation and usage instructions, visit the <a href="https://github.com/shyfox-studio/MonoPack">official repository on GitHub</a></p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you learned how to package your MonoGame project for distribution across Windows, macOS, and Linux platforms. You now understand how to create self-contained deployments for each target platform, the impact of various .NET publishing options on game performance, and important cross-platform considerations.</p>
<p>Whether you choose to use the manual platform-specific packaging steps or automate the process with tools like <a href="#gamebundle">GameBundle</a> or <a href="#monopack">MonoPack</a>, you now have the knowledge to ensure your game runs smoothly for players across different platforms without requiring them to install additional dependencies.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>Why is it recommended to use self-contained deployments for distributing MonoGame games?</p>
<div class="question-answer"><p>Self-contained deployments package your game with all necessary .NET dependencies, ensuring players can run the game without installing the .NET runtime. This simplifies distribution, guarantees your game uses the exact runtime version it was developed with, and provides a better player experience despite the larger package size.</p>
</div>
</li>
<li><p>Why should ReadyToRun and Tiered Compilation be disabled when publishing games?</p>
<div class="question-answer"><p>ReadyToRun and Tiered Compilation both initially produce lower-quality code that gets optimized during runtime. This dynamic optimization process causes micro-stutters during gameplay as the Just-In-Time compiler triggers to improve code quality. Disabling these features results in slightly longer startup times but provides smoother gameplay without performance hitches.</p>
</div>
</li>
<li><p>What is the purpose of the <em>Info.plist</em> file when creating a macOS application bundle?</p>
<div class="question-answer"><p>The <em>Info.plist</em> file contains essential metadata about the macOS application, including the bundle identifier, application name, version, copyright information, minimum system requirements, and other configuration details. macOS requires this file to properly recognize and display the application in the Finder and Dock, and to associate the correct icon and file types with the application.</p>
</div>
</li>
<li><p>What is the advantage of using a tar.gz archive over zip file when distributing for macOS and Linux?</p>
<div class="question-answer"><p>A tar.gz archive preserves Unix file permissions, which is crucial for maintaining the executable permissions set on game files.  Without these permissions, users would need to manually set execute permissions before running the game.  ZIP files do not reliably preserve these Unix-specific permissions, which could prevent the game from running directly after extraction on macOS and Linux platforms.</p>
</div>
</li>
<li><p>What is the purpose of creating a universal binary for macOS distributions?</p>
<div class="question-answer"><p>A universal binary combines executables for multiple CPU architectures (Intel x64 and Apple Silicon arm64) into a single file.  This allows the game to run natively on both older Intel-based Macs and newer Apple Silicon Macs without requiring separate distributions.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
