<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-03-the-game1-file">Chapter 03: The Game1 File</h1>
<p class="text-secondary">Explore the contents of the Game1 file generated when creating a new MonoGame project.</p>
<p>After you created a new MonoGame project using the <em>MonoGame Cross-Platform Desktop Application</em> template in <a href="../02_getting_started/index.html#creating-your-first-monogame-application">Chapter 02</a>, you will notice the generated files and project structure that serve as a starting point for your game application.  While MonoGame offers different templates based on target platform, all projects will contain the <code>Game1.cs</code> file.</p>
<h2 id="exploring-the-game1-class">Exploring the Game1 Class</h2>
<p>At the core of a MonoGame project is the <a href="xref:Microsoft.Xna.Framework.Game"><strong>Game</strong></a> class.  This class handles the initialization of graphics services, initialization of the game, loading content, updating, and rendering the game.  When you create a new MonoGame project, this <a href="xref:Microsoft.Xna.Framework.Game"><strong>Game</strong></a> class is implemented as the <code>Game1</code> class that you can customize as needed for your specific game.</p>
<div class="TIP">
<h5>Tip</h5>
<p>While the default template names the class <code>Game1</code>, you are free to rename it to something more appropriate for your project.  However, for consistency, the documentation will continue to refer to it as <code>Game1</code>.</p>
</div>
<p>Locate the <code>Game1.cs</code> file that was generated when you created the MonoGame project and open it.  The default content will be:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;

namespace DungeonSlime;

public class Game1 : Game
{
    private GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch;

    public Game1()
    {
        _graphics = new GraphicsDeviceManager(this);
        Content.RootDirectory = &quot;Content&quot;;
        IsMouseVisible = true;
    }

    protected override void Initialize()
    {
        base.Initialize();
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        GraphicsDevice.Clear(Color.CornflowerBlue);

        base.Draw(gameTime);
    }
}
</code></pre>
<p>This class provides the following structure:</p>
<ol>
<li><strong>Graphics and Rendering</strong>: The class declares two core graphics components; the <a href="xref:Microsoft.Xna.Framework.GraphicsDeviceManager"><strong>GraphicsDeviceManager</strong></a> for interacting with the Graphics Processing Unit (GPU) and the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> for 2D rendering.</li>
<li><strong>Initialization</strong>: The constructor and <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> method handle the game's setup sequence.</li>
<li><strong>Content Loading</strong>: The <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> method manages game asset loading during startup.</li>
<li><strong>Game Loop</strong>: The <em>game loop</em> consists of the <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> method for game logic and the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> method for rendering, running continuously until the game is told to exit.</li>
</ol>
<p><em>Figure 3-1</em> below shows the lifecycle of a MonoGame game including the <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> and <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> methods that make up the <em>game loop</em>.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/monogame-lifecycle.png" alt="Figure 3-1: Lifecycle of a MonoGame game"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 3-1: Lifecycle of a MonoGame game</strong></td>
</tr>
</tbody>
</table>
<h2 id="graphics-and-rendering">Graphics and Rendering</h2>
<p>The graphics pipeline in monogame starts with two components: the <a href="xref:Microsoft.Xna.Framework.GraphicsDeviceManager"><strong>GraphicsDeviceManager</strong></a> and <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>.</p>
<pre><code class="lang-csharp">private GraphicsDeviceManager _graphics;
private SpriteBatch _spriteBatch;
</code></pre>
<p>The <a href="xref:Microsoft.Xna.Framework.GraphicsDeviceManager"><strong>GraphicsDeviceManager</strong></a> initializes and the connection to the graphics hardware.  It handles tasks such as setting the screen resolution, toggling between fullscreen and windowed mode, and managing the <a href="xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice"><strong>GraphicsDevice</strong></a>, which is the interface between your game and the Graphics Processing Unit (GPU) the game is running on. The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> optimizes 2D rendering by batching similar draw calls together, improving draw performance when rendering multiple sprites.</p>
<h2 id="initialization">Initialization</h2>
<p>MonoGame's initialization process for your game follows a specific sequence.  The constructor runs first, which handles basic setup like creating the <a href="xref:Microsoft.Xna.Framework.GraphicsDeviceManager"><strong>GraphicsDeviceManager</strong></a>, setting the content directory, and the visibility of the mouse.</p>
<pre><code class="lang-csharp">public Game1()
{
    _graphics = new GraphicsDeviceManager(this);
    Content.RootDirectory = &quot;Content&quot;;
    IsMouseVisible = true;
}
</code></pre>
<p>After that, the <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> method executes, providing a dedicated place for additional configuration and initializations.</p>
<pre><code class="lang-csharp">protected override void Initialize()
{
    base.Initialize();
}
</code></pre>
<p>This separation allows you to perform setup tasks in a logical order; core systems in the constructor and game-specific initializations in the <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> method.  The call to <code>base.Initialize()</code> should never be removed, as this is where the graphics device is initialized for the target platform.</p>
<div class="TIP">
<h5>Tip</h5>
<p>You may be wondering why there is an <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> method instead of performing all initializations in the constructor.  The <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> method is a <code>virtual</code> method that is overridden, and <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2214">it is advised to not call overridable methods from within a constructor</a>, as this can lead to unexpected states in object constructor when called.  Additionally, when the constructor is called, the base constructor will instantiate properties and services based on the target platform that may be needed first before performing initializations for the game itself.</p>
</div>
<h2 id="content-loading">Content Loading</h2>
<p>The <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> method serves as the place for asset management. Here you can load textures, sound effects, music, and other game assets.  We will cover loading assets in the coming chapters as we discuss each asset type that can be loaded.  In a new project, the only task it performs is initializing a new instance of the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>.</p>
<pre><code class="lang-csharp">protected override void LoadContent()
{
    _spriteBatch = new SpriteBatch(GraphicsDevice);
}
</code></pre>
<p>This method is only call once during the startup of the game, but <em>when</em> it is called can be a little confusing at first.  In the <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> method shown above, when the <code>base.Initialize</code> call is executed, the final task it performs is calling the <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> method.  This means any initializations you need to perform that have a dependency on assets being loaded should be done <em>after</em> the <code>base.Initialize</code> call and not <em>before</em> it.</p>
<h2 id="the-game-loop">The Game Loop</h2>
<p>MonoGame implements a <em>game loop</em> by calling <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> and <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> over and over until the game is told to exit. Recall at the end of <a href="../02_getting_started/index.html#creating-your-first-monogame-application">Chapter 02</a> when you ran the project for the first time, I mentioned that there is a lot going on behind the scenes? This game loop is what I was referring to.</p>
<p>MonoGame is executing the <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> method and then the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> method 60 times per second.</p>
<pre><code class="lang-csharp">protected override void Update(GameTime gameTime)
{
    if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
        Exit();

    base.Update(gameTime);
}

protected override void Draw(GameTime gameTime)
{
    GraphicsDevice.Clear(Color.CornflowerBlue);

    base.Draw(gameTime);
}
</code></pre>
<p>The <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> method at the moment is not doing much, only checking for input from a controller or keyboard to determine if the game should exit. However, the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> method is doing more than what it appears to at first glance.</p>
<p>The first line is executing the <a href="xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color)"><strong>Clear</strong></a> method of the <a href="xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice"><strong>GraphicsDevice</strong></a> property using the color <a href="xref:Microsoft.Xna.Framework.Color.CornflowerBlue"><strong>CornflowerBlue</strong></a>. Recall that the <a href="xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice"><strong>GraphicsDevice</strong></a> object is your direct interface between the game and what is rendered to the screen. Every time the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> method is called, this line of code of erasing the contents of the game window and refilling it with the color specified. Without clearing the contents of the screen first, every draw call would draw the new frame render over top of the previous render, and you'd end up with something like the old solitaire win screen</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/solitaire.webp" alt="Figure 3-2: Windows XP Solitaire Win Screen"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 3-2: Windows XP Solitaire Win Screen</strong></td>
</tr>
</tbody>
</table>
<p>While this can make for a neat effect, it is not something you want all the time. So, the screen is cleared and refilled with a solid color.</p>
<div class="NOTE">
<h5>Note</h5>
<p>You can test this yourself by modifying the code to use a different color, such as <a href="xref:Microsoft.Xna.Framework.Color.MonoGameOrange"><strong>Color.MonoGameOrange</strong></a>. (yes, there is a MonoGame Orange color).</p>
<pre><code class="lang-csharp" highlight-lines="3">protected override void Draw(GameTime gameTime)
{
    GraphicsDevice.Clear(Color.MonoGameOrange);

    base.Draw(gameTime);
}
</code></pre>
<p>After making this change and running the game, the screen is cleared to the MonoGame Orange color.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/monogame-orange.png" alt="Figure 3-3: The game window clearing the screen using the MonoGame Orange color"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 3-3: The game window clearing the screen using the MonoGame Orange color</strong></td>
</tr>
</tbody>
</table>
</div>
<p>Each time the game loops completes and the game is drawn to the screen, we call this a <em>frame</em>. So if MonoGame is running the game loop at 60 frames per second, that means it is performing and update and a render of each frame every 16ms. Notice that both the <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> and the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> methods both receive a parameter of the type <a href="xref:Microsoft.Xna.Framework.GameTime"><strong>GameTime</strong></a>. The <a href="xref:Microsoft.Xna.Framework.GameTime"><strong>GameTime</strong></a> parameter provides a snapshot of the timing values for the game, including the amount of time that it took for the previous frame to execute. This is commonly referred to as the <em>delta time</em>.</p>
<p><em>Delta time</em> allows you to track time accurately for things such as animations and events based on <em>game time</em> and not the speed of the processor (CPU) on the machine running the game. While in ideal circumstances, the delta time will always be 16ms, there are any number of things that could cause a temporary slow down or hiccup in a frame, and using the delta time ensures that timing based events are always correct.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>You read through the default code provided in a <code>Game1.cs</code> file created by a MonoGame template.</li>
<li>You learned about the lifecycle of a MonoGame game project.</li>
<li>You learned what a game loop is and how it is implemented in MonoGame.</li>
</ul>
<p>In the next chapter, you will start working with sprites and learn how to load and render them.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>Can the <code>Game1</code> class be renamed or is it required to be called <code>Game1</code></p>
<div class="question-answer"><p>It is not a requirement that it be called <code>Game1</code>.  This is just the default name given to it by the templates when creating a new MonoGame game project.  However, you cannot change the name of the <em>BASE</em> class <code>Game</code>, as this is a MonoGame construct.</p>
</div>
</li>
<li><p>What is the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> used for?</p>
<div class="question-answer"><p>The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> provides an optimized method of rendering 2D graphics, like sprites, onto the screen</p>
</div>
</li>
<li><p>When is the <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> method executed and why is it important to know this?</p>
<div class="question-answer"><p><a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> is executed during the <code>base.Initialize()</code> method call within the <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> method.  It is important to know this because anything being initialized that is dependent on content loaded should be done <strong>after</strong> the <code>base.Initialize()</code> call and not <strong>before</strong>.</p>
</div>
</li>
<li><p>How does MonoGame provide a <em>delta time</em> value?</p>
<div class="question-answer"><p>Through the <a href="xref:Microsoft.Xna.Framework.GameTime"><strong>GameTime</strong></a> parameter that is given to both the <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> and the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> methods.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
