<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-11-input-management">Chapter 11: Input Management</h1>
<p class="text-secondary">Learn how to create an input management system to handle keyboard, mouse, and gamepad input, including state tracking between frames and creating a reusable framework for handling player input.</p>
<p>In <a href="../10_handling_input/index.html">Chapter 10</a>, you learned how to handle input from various devices like keyboard, mouse, and gamepad. While checking if an input is currently down works well for continuous actions like movement, many game actions should only happen once when an input is first pressed; think firing a weapon or jumping. To handle these scenarios, we need to compare the current input state with the previous frame's state to detect when an input changes from up to down.</p>
<p>In this chapter you will:</p>
<ul>
<li>Learn the difference between an input being down versus being pressed</li>
<li>Track input states between frames</li>
<li>Create a reusable input management system</li>
<li>Simplify handling input across multiple devices</li>
</ul>
<p>Let's start by understanding the concept of input state changes and how we can detect them.</p>
<h2 id="understanding-input-states">Understanding Input States</h2>
<p>When handling input in games, there are two key scenarios we need to consider:</p>
<ul>
<li>An input is being held down (like holding a movement key).</li>
<li>An input was just pressed for one frame (like pressing a jump button).</li>
</ul>
<p>Let's look at the difference using keyboard input as an example. With our current implementation, we can check if a key is down using <a href="xref:Microsoft.Xna.Framework.Input.KeyboardState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys)"><strong>KeyboardState.IsKeyDown</strong></a>:</p>
<pre><code>// Get the current state of keyboard input.
KeyboardState keyboardState = Keyboard.GetState();

// Check if the space key is down.
if (keyboardState.IsKeyDown(Keys.Space))
{
    // This runs EVERY frame the space key is held down
}
</code></pre>
<p>However, many game actions shouldn't repeat while a key is held. For instance, if the Space key makes your character jump, you probably don't want them to jump repeatedly just because the player is holding the key down. Instead, you want the jump to happen only on the first frame when Space is pressed.</p>
<p>To detect this &quot;just pressed&quot; state, we need to compare two states:</p>
<ol>
<li>Is the key down in the current frame?</li>
<li>Was the key up in the previous frame?</li>
</ol>
<p>If both conditions are true, we know the key was just pressed.  If we were to modify the above code to track the previous keyboard state it would look something like this:</p>
<pre><code class="lang-csharp">// Track the state of keyboard input during the previous frame.
private KeyboardState _previousKeyboardState;

protected override void Update(GameTime gameTime)
{
    // Get the current state of keyboard input.
    KeyboardState keyboardState = Keyboard.GetState();

    // Compare if the space key is down on the current frame but was up on the previous frame.
    if (keyboardState.IsKeyDown(Keys.Space) &amp;&amp; _previousKeyboardState.IsKeyUp(Keys.Space))
    {
        // This will only run on the first frame Space is pressed and will not
        // happen again until it has been released and then pressed again.
    }

    // At the end of update, store the current state of keyboard input into the
    // previous state tracker.
    _previousKeyboardState = keyboardState;
    
    base.Update(gameTime);
}
</code></pre>
<p>This same concept applies to mouse buttons and gamepad input as well. Any time you need to detect a &quot;just pressed&quot; or &quot;just released&quot; state, you'll need to compare the current input state with the previous frame's state.</p>
<p>So far, we've only been working with our game within the <em>Game1.cs</em> file.  This has been fine for the examples given.  Overtime, as the game grows, we're going to have a more complex system setup with different scenes, and each scene will need a way to track the state of input over time.  We could do this by creating a lot of variables in each scene to track this information, or we can use object-oriented design concepts to create a reusable <code>InputManager</code> class to simplify this for us.</p>
<p>Before we create the <code>InputManager</code> class, let's first create classes for the keyboard, mouse, and gamepad that encapsulates the information about those inputs which will then be exposed through the <code>InputManager</code>.</p>
<p>To get started, create a new directory called <em>Input</em> in the <em>MonoGameLibrary</em> project.  We'll put all of our input related classes here.</p>
<h2 id="the-keyboardinfo-class">The KeyboardInfo Class</h2>
<p>Let's start our input management system by creating a class to handle keyboard input. The <code>KeyboardInfo</code> class will encapsulate all keyboard-related functionality, making it easier to:</p>
<ul>
<li>Track current and previous keyboard states</li>
<li>Detect when keys are pressed or released</li>
<li>Check if keys are being held down</li>
</ul>
<p>In the <em>Input</em> directory of the <em>MonoGameLibrary</em> project, add a new file named <em>KeyboardInfo.cs</em> with this initial structure:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework.Input;

namespace MonoGameLibrary.Input;

public class KeyboardInfo { }
</code></pre><h3 id="keyboardinfo-properties">KeyboardInfo Properties</h3>
<p>To detect changes in keyboard input between frames, we need to track both the previous and current keyboard states. Add these properties to the <code>KeyboardInfo</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the state of keyboard input during the previous update cycle.
/// &lt;/summary&gt;
public KeyboardState PreviousState { get; private set; }

/// &lt;summary&gt;
/// Gets the state of keyboard input during the current input cycle.
/// &lt;/summary&gt;
public KeyboardState CurrentState { get; private set; }

/// &lt;summary&gt;
/// Gets the state of keyboard input during the previous update cycle.
/// &lt;/summary&gt;
public KeyboardState PreviousState { get; private set; }

/// &lt;summary&gt;
/// Gets the state of keyboard input during the current input cycle.
/// &lt;/summary&gt;
public KeyboardState CurrentState { get; private set; }
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>These properties use a public getter but private setter pattern. This allows other parts of the game to read the keyboard states if needed, while ensuring only the <code>KeyboardInfo</code> class can update them.</p>
</div>
<h3 id="keyboardinfo-constructor">KeyboardInfo Constructor</h3>
<p>The <code>KeyboardInfo</code> class needs a constructor to initialize the keyboard states. Add this constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new KeyboardInfo 
/// &lt;/summary&gt;
public KeyboardInfo()
{
    PreviousState = new KeyboardState();
    CurrentState = Keyboard.GetState();
}
</code></pre>
<p>The constructor:</p>
<ul>
<li>Creates an empty state for <code>PreviousState</code> since there is no previous input yet</li>
<li>Gets the current keyboard state as our starting point for <code>CurrentState</code></li>
</ul>
<p>This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes.</p>
<h3 id="keyboardinfo-methods">KeyboardInfo Methods</h3>
<p>The <code>KeyboardInfo</code> class needs methods both for updating states and checking key states. Let's start with our update method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the state information about keyboard input.
/// &lt;/summary&gt;
public void Update()
{
    PreviousState = CurrentState;
    CurrentState = Keyboard.GetState();
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Each time <code>Update</code> is called, the current state becomes the previous state, and we get a fresh current state. This creates our frame-to-frame comparison chain.</p>
</div>
<p>Next, we'll add methods to check various key states:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates if the specified key is currently down.
/// &lt;/summary&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified key is currently down; otherwise, false.&lt;/returns&gt;
public bool IsKeyDown(Keys key)
{
    return CurrentState.IsKeyDown(key);
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified key is currently up.
/// &lt;/summary&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified key is currently up; otherwise, false.&lt;/returns&gt;
public bool IsKeyUp(Keys key)
{
    return CurrentState.IsKeyUp(key);
}

/// &lt;summary&gt;
/// Returns a value that indicates if the specified key was just pressed on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified key was just pressed on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasKeyJustPressed(Keys key)
{
    return CurrentState.IsKeyDown(key) &amp;&amp; PreviousState.IsKeyUp(key);
}

/// &lt;summary&gt;
/// Returns a value that indicates if the specified key was just released on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;key&quot;&gt;The key to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified key was just released on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasKeyJustReleased(Keys key)
{
    return CurrentState.IsKeyUp(key) &amp;&amp; PreviousState.IsKeyDown(key);
}
</code></pre>
<p>These methods serve two distinct purposes.  For checking continuous states:</p>
<ul>
<li><code>IsKeyDown</code>: Returns true as long as a key is being held down.</li>
<li><code>IsKeyUp</code>: Returns true as long as a key is not being pressed.</li>
</ul>
<p>And for detecting state changes:</p>
<ul>
<li><code>WasKeyJustPressed</code>: Returns true only on the frame when a key changes from up-to-down.</li>
<li><code>WasKeyJustReleased</code>: Returns true only on the frame when a key changes from down-to-up.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Use continuous state checks (<code>IsKeyDown</code>/<code>IsKeyUp</code>) for actions that should repeat while a key is held, like movement. Use single-frame checks (<code>WasKeyJustPressed</code>/<code>WasKeyJustReleased</code>) for actions that should happen once per key press, like jumping or shooting.</p>
</div>
<p>That's it for the <code>KeyboardInfo</code> class, let's move on to mouse input next.</p>
<h2 id="mousebutton-enum">MouseButton Enum</h2>
<p>Recall from the <a href="../10_handling_input/index.html#mouse-input">Mouse Input</a> section of the previous chapter that the <a href="xref:Microsoft.Xna.Framework.Input.MouseState"><strong>MouseState</strong></a> struct provides button states through properties rather than methods like <code>IsButtonDown</code>/<code>IsButtonUp</code>. To keep our input management API consistent across devices, we'll create a <code>MouseButton</code> enum that lets us reference mouse buttons in a similar way to how we use <a href="xref:Microsoft.Xna.Framework.Input.Keys"><strong>Keys</strong></a> for keyboard input and <a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons</strong></a> for gamepad input.</p>
<p>In the <em>Input</em> directory of the <em>MonoGameLibrary</em> project, add a new file named <em>MouseButton.cs</em> with the following code:</p>
<pre><code class="lang-csharp">namespace MonoGameLibrary.Input;

public enum MouseButton
{
    Left,
    Middle,
    Right,
    XButton1,
    XButton2
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Each enum value corresponds directly to a button property in MouseState:</p>
<ul>
<li><code>Left</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.LeftButton"><strong>MouseState.LeftButton</strong></a>.</li>
<li><code>Middle</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.MiddleButton"><strong>MouseState.MiddleButton</strong></a>.</li>
<li><code>Right</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.RightButton"><strong>MouseState.RightButton</strong></a>.</li>
<li><code>XButton1</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.XButton1"><strong>MouseState.XButton1</strong></a>.</li>
<li><code>XButton2</code>: Maps to <a href="xref:Microsoft.Xna.Framework.Input.MouseState.XButton2"><strong>MouseState.XButton2</strong></a>.</li>
</ul>
</div>
<h2 id="the-mouseinfo-class">The MouseInfo Class</h2>
<p>To manage mouse input effectively, we need to track both current and previous states, as well as provide easy access to mouse position, scroll wheel values, and button states. The <code>MouseInfo</code> class will encapsulate all of this functionality, making it easier to:</p>
<ul>
<li>Track current and previous mouse states.</li>
<li>Track the mouse position.</li>
<li>Check the change in mouse position between frames and if it was moved.</li>
<li>Track scroll wheel changes.</li>
<li>Detect when mouse buttons are pressed or released</li>
<li>Check if mouse buttons are being held down</li>
</ul>
<p>Let's create this class in the <em>Input</em> directory of the <em>MonoGameLibrary</em> project. Add a new file named <em>MouseInfo.cs</em> with the following initial structure:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;

namespace MonoGameLibrary.Input;

public class MouseInfo { }
</code></pre><h3 id="mouseinfo-properties">MouseInfo Properties</h3>
<p>The <code>MouseInfo</code> class needs properties to track both mouse states and provide easy access to common mouse information. Let's add these properties.</p>
<p>First, we need properties for tracking mouse states:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// The state of mouse input during the previous update cycle.
/// &lt;/summary&gt;
public MouseState PreviousState { get; private set; }

/// &lt;summary&gt;
/// The state of mouse input during the current update cycle.
/// &lt;/summary&gt;
public MouseState CurrentState { get; private set; }
</code></pre>
<p>Next, we'll add properties for handling cursor position:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or Sets the current position of the mouse cursor in screen space.
/// &lt;/summary&gt;
public Point Position
{
    get =&gt; CurrentState.Position;
    set =&gt; SetPosition(value.X, value.Y);
}

/// &lt;summary&gt;
/// Gets or Sets the current x-coordinate position of the mouse cursor in screen space.
/// &lt;/summary&gt;
public int X
{
    get =&gt; CurrentState.X;
    set =&gt; SetPosition(value, CurrentState.Y);
}

/// &lt;summary&gt;
/// Gets or Sets the current y-coordinate position of the mouse cursor in screen space.
/// &lt;/summary&gt;
public int Y
{
    get =&gt; CurrentState.Y;
    set =&gt; SetPosition(CurrentState.X, value);
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The position properties use a <code>SetPosition</code> method that we'll implement later. This method will handle the actual cursor positioning on screen.</p>
</div>
<p>These properties provide different ways to work with the cursor position:</p>
<ul>
<li><code>Position</code>: Gets/sets the cursor position as a <a href="xref:Microsoft.Xna.Framework.Point"><strong>Point</strong></a>.</li>
<li><code>X</code>: Gets/sets just the horizontal position.</li>
<li><code>Y</code>: Gets/sets just the vertical position.</li>
</ul>
<p>Next, we'll add properties for determining if the mouse cursor moved between game frames and if so how much:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the difference in the mouse cursor position between the previous and current frame.
/// &lt;/summary&gt;
public Point PositionDelta =&gt; CurrentState.Position - PreviousState.Position;

/// &lt;summary&gt;
/// Gets the difference in the mouse cursor x-position between the previous and current frame.
/// &lt;/summary&gt;
public int XDelta =&gt; CurrentState.X - PreviousState.X;

/// &lt;summary&gt;
/// Gets the difference in the mouse cursor y-position between the previous and current frame.
/// &lt;/summary&gt;
public int YDelta =&gt; CurrentState.Y - PreviousState.Y;

/// &lt;summary&gt;
/// Gets a value that indicates if the mouse cursor moved between the previous and current frames.
/// &lt;/summary&gt;
public bool WasMoved =&gt; PositionDelta != Point.Zero;
</code></pre>
<p>The properties provide different ways of detecting mouse movement between frames:</p>
<ul>
<li><code>PositionDelta</code>: Gets how much the cursor moved between frames as a <a href="xref:Microsoft.Xna.Framework.Point"><strong>Point</strong></a>.</li>
<li><code>XDelta</code>: Gets how much the cursor moved horizontally between frames.</li>
<li><code>YDelta</code>: Gets how much the cursor moved vertically between frames.</li>
<li><code>WasMoved</code>: Indicates if the cursor moved between frames.</li>
</ul>
<p>Finally, we'll add properties for handling the scroll wheel:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the cumulative value of the mouse scroll wheel since the start of the game.
/// &lt;/summary&gt;
public int ScrollWheel =&gt; CurrentState.ScrollWheelValue;

/// &lt;summary&gt;
/// Gets the value of the scroll wheel between the previous and current frame.
/// &lt;/summary&gt;
public int ScrollWheelDelta =&gt; CurrentState.ScrollWheelValue - PreviousState.ScrollWheelValue;
</code></pre>
<p>The scroll wheel properties serve different purposes:</p>
<ul>
<li><code>ScrollWheel</code>: Gets the total accumulated scroll value since game start.</li>
<li><code>ScrollWheelDelta</code>: Gets the change in scroll value just in this frame.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Use <code>ScrollWheelDelta</code> when you need to respond to how much the user just scrolled, rather than tracking the total scroll amount.</p>
</div>
<h3 id="mouseinfo-constructor">MouseInfo Constructor</h3>
<p>The <code>MouseInfo</code> class needs a constructor to initialize the mouse states. Add this constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new MouseInfo.
/// &lt;/summary&gt;
public MouseInfo()
{
    PreviousState = new MouseState();
    CurrentState = Mouse.GetState();
}
</code></pre>
<p>The constructor:</p>
<ul>
<li>Creates an empty state for <code>PreviousState</code> since there is no previous input yet.</li>
<li>Gets the current mouse state as our starting point for <code>CurrentState</code>.</li>
</ul>
<p>This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes.</p>
<h3 id="mouseinfo-methods">MouseInfo Methods</h3>
<p>The <code>MouseInfo</code> class needs methods for updating states, checking button states, and setting the cursor position. Let's start with our update method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the state information about mouse input.
/// &lt;/summary&gt;
public void Update()
{
    PreviousState = CurrentState;
    CurrentState = Mouse.GetState();
}
</code></pre>
<p>Next, we'll add methods to check various button states:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates whether the specified mouse button is currently down.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The mouse button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified mouse button is currently down; otherwise, false.&lt;/returns&gt;
public bool IsButtonDown(MouseButton button)
{
    switch (button)
    {
        case MouseButton.Left:
            return CurrentState.LeftButton == ButtonState.Pressed;
        case MouseButton.Middle:
            return CurrentState.MiddleButton == ButtonState.Pressed;
        case MouseButton.Right:
            return CurrentState.RightButton == ButtonState.Pressed;
        case MouseButton.XButton1:
            return CurrentState.XButton1 == ButtonState.Pressed;
        case MouseButton.XButton2:
            return CurrentState.XButton2 == ButtonState.Pressed;
        default:
            return false;
    }
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified mouse button is current up.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The mouse button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified mouse button is currently up; otherwise, false.&lt;/returns&gt;
public bool IsButtonUp(MouseButton button)
{
    switch (button)
    {
        case MouseButton.Left:
            return CurrentState.LeftButton == ButtonState.Released;
        case MouseButton.Middle:
            return CurrentState.MiddleButton == ButtonState.Released;
        case MouseButton.Right:
            return CurrentState.RightButton == ButtonState.Released;
        case MouseButton.XButton1:
            return CurrentState.XButton1 == ButtonState.Released;
        case MouseButton.XButton2:
            return CurrentState.XButton2 == ButtonState.Released;
        default:
            return false;
    }
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified mouse button was just pressed on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The mouse button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified mouse button was just pressed on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasButtonJustPressed(MouseButton button)
{
    switch (button)
    {
        case MouseButton.Left:
            return CurrentState.LeftButton == ButtonState.Pressed &amp;&amp; PreviousState.LeftButton == ButtonState.Released;
        case MouseButton.Middle:
            return CurrentState.MiddleButton == ButtonState.Pressed &amp;&amp; PreviousState.MiddleButton == ButtonState.Released;
        case MouseButton.Right:
            return CurrentState.RightButton == ButtonState.Pressed &amp;&amp; PreviousState.RightButton == ButtonState.Released;
        case MouseButton.XButton1:
            return CurrentState.XButton1 == ButtonState.Pressed &amp;&amp; PreviousState.XButton1 == ButtonState.Released;
        case MouseButton.XButton2:
            return CurrentState.XButton2 == ButtonState.Pressed &amp;&amp; PreviousState.XButton2 == ButtonState.Released;
        default:
            return false;
    }
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified mouse button was just released on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The mouse button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified mouse button was just released on the current frame; otherwise, false.&lt;/returns&gt;F
public bool WasButtonJustReleased(MouseButton button)
{
    switch (button)
    {
        case MouseButton.Left:
            return CurrentState.LeftButton == ButtonState.Released &amp;&amp; PreviousState.LeftButton == ButtonState.Pressed;
        case MouseButton.Middle:
            return CurrentState.MiddleButton == ButtonState.Released &amp;&amp; PreviousState.MiddleButton == ButtonState.Pressed;
        case MouseButton.Right:
            return CurrentState.RightButton == ButtonState.Released &amp;&amp; PreviousState.RightButton == ButtonState.Pressed;
        case MouseButton.XButton1:
            return CurrentState.XButton1 == ButtonState.Released &amp;&amp; PreviousState.XButton1 == ButtonState.Pressed;
        case MouseButton.XButton2:
            return CurrentState.XButton2 == ButtonState.Released &amp;&amp; PreviousState.XButton2 == ButtonState.Pressed;
        default:
            return false;
    }
}
</code></pre>
<p>These methods serve two distinct purposes. For checking continuous states:</p>
<ul>
<li><code>IsKeyDown</code>: Returns true as long as a key is being held down.</li>
<li><code>IsKeyUp</code>: Returns true as long as a key is not being pressed.</li>
</ul>
<p>And for detecting state changes:</p>
<ul>
<li><code>WasKeyJustPressed</code>: Returns true only on the frame when a key changes from up-to-down.</li>
<li><code>WasKeyJustReleased</code>: Returns true only on the frame when a key changes from down-to-up.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Each method uses a switch statement to check the appropriate button property from the <a href="xref:Microsoft.Xna.Framework.Input.MouseState"><strong>MouseState</strong></a> based on which <code>MouseButton</code> enum value is provided. This provides a consistent API while handling the different button properties internally.</p>
</div>
<p>Finally, we need a method to handle setting the cursor position:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Sets the current position of the mouse cursor in screen space and updates the CurrentState with the new position.
/// &lt;/summary&gt;
/// &lt;param name=&quot;x&quot;&gt;The x-coordinate location of the mouse cursor in screen space.&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;The y-coordinate location of the mouse cursor in screen space.&lt;/param&gt;
public void SetPosition(int x, int y)
{
    Mouse.SetPosition(x, y);
    CurrentState = new MouseState(
        x,
        y,
        CurrentState.ScrollWheelValue,
        CurrentState.LeftButton,
        CurrentState.MiddleButton,
        CurrentState.RightButton,
        CurrentState.XButton1,
        CurrentState.XButton2
    );
}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>Notice that after setting the position, we immediately update the <code>CurrentState</code>. This ensures our state tracking remains accurate even when manually moving the cursor.</p>
</div>
<p>That's it for the <code>MouseInfo</code> class, next we'll move onto gamepad input.</p>
<h2 id="the-gamepadinfo-class">The GamePadInfo Class</h2>
<p>To manage gamepad input effectively, we need to track both current and previous states, is the gamepad still connected, as well as provide easy access to the thumbstick values, trigger values, and button states. The <code>GamePadInfo</code> class will encapsulate all of this functionality, making it easier to:</p>
<ul>
<li>Track current and previous gamepad states.</li>
<li>Check if the gamepad is still connected.</li>
<li>Track the position of the left and right thumbsticks.</li>
<li>Check the values of the left and right triggers.</li>
<li>Detect when gamepad buttons are pressed or released.</li>
<li>Check if gamepad buttons are being held down.</li>
<li>Start and Stop vibration of a gamepad.</li>
</ul>
<p>Let's create this class in the <em>Input</em> directory of the <em>MonoGameLibrary</em> project. Add a new file named <em>GamePadInfo.cs</em> with the following initial structure:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;

namespace MonoGameLibrary.Input;

public class GamePadInfo { }
</code></pre><h3 id="gamepadinfo-properties">GamePadInfo Properties</h3>
<p>We use vibration in gamepads to provide haptic feedback to the player.  The <a href="xref:Microsoft.Xna.Framework.Input.GamePad"><strong>GamePad</strong></a> class provides the <a href="xref:Microsoft.Xna.Framework.Input.GamePad.SetVibration(Microsoft.Xna.Framework.PlayerIndex,System.Single,System.Single)"><strong>SetVibration</strong></a> method to tell the gamepad to vibrate, but it does not provide a timing mechanism for it if we wanted to only vibrate for a certain period of time.  Add the following private field to the <code>GamePadInfo</code> class:</p>
<pre><code class="lang-csharp">private TimeSpan _vibrationTimeRemaining = TimeSpan.Zero;
</code></pre>
<p>Recall from the <a href="../10_handling_input/index.html#gamepad-input">previous chapter</a> that a <a href="xref:Microsoft.Xna.Framework.PlayerIndex"><strong>PlayerIndex</strong></a> value needs to be supplied when calling <a href="xref:Microsoft.Xna.Framework.Input.GamePad.GetState(Microsoft.Xna.Framework.PlayerIndex)"><strong>Gamepad.GetState</strong></a>.   Doing this returns the state of the gamepad connected at that player index.  So we'll need a property to track the player index this gamepad info is for.</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the index of the player this gamepad is for.
/// &lt;/summary&gt;
public PlayerIndex PlayerIndex { get; }
</code></pre>
<p>To detect changes in the gamepad input between frames, we need to track both the previous and current gamepad states.  Add these properties to the <code>GamePadInfo</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the state of input for this gamepad during the previous update cycle.
/// &lt;/summary&gt;
public GamePadState PreviousState { get; private set; }

/// &lt;summary&gt;
/// Gets the state of input for this gamepad during the current update cycle.
/// &lt;/summary&gt;
public GamePadState CurrentState { get; private set; }
</code></pre>
<p>There are times that a gamepad can disconnect for various reasons; being unplugged, bluetooth disconnection, or battery dying are just some examples.  To track if the gamepad is connected, add the following property:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets a value that indicates if this gamepad is currently connected.
/// &lt;/summary&gt;
public bool IsConnected =&gt; CurrentState.IsConnected;
</code></pre>
<p>The values of the thumbsticks and triggers can be accessed through the <code>CurrentState</code>.  However, instead of having to navigate through multiple property chains to get this information, add the following properties to get direct access to the values:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the value of the left thumbstick of this gamepad.
/// &lt;/summary&gt;
public Vector2 LeftThumbStick =&gt; CurrentState.ThumbSticks.Left;

/// &lt;summary&gt;
/// Gets the value of the right thumbstick of this gamepad.
/// &lt;/summary&gt;
public Vector2 RightThumbStick =&gt; CurrentState.ThumbSticks.Right;

/// &lt;summary&gt;
/// Gets the value of the left trigger of this gamepad.
/// &lt;/summary&gt;
public float LeftTrigger =&gt; CurrentState.Triggers.Left;

/// &lt;summary&gt;
/// Gets the value of the right trigger of this gamepad.
/// &lt;/summary&gt;
public float RightTrigger =&gt; CurrentState.Triggers.Right;
</code></pre><h3 id="gamepadinfo-constructor">GamePadInfo Constructor</h3>
<p>The <code>GamePadInfo</code> class needs a constructor to initialize the gamepad states.  Add this constructor</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new GamePadInfo for the gamepad connected at the specified player index.
/// &lt;/summary&gt;
/// &lt;param name=&quot;playerIndex&quot;&gt;The index of the player for this gamepad.&lt;/param&gt;
public GamePadInfo(PlayerIndex playerIndex)
{
    PlayerIndex = playerIndex;
    PreviousState = new GamePadState();
    CurrentState = GamePad.GetState(playerIndex);
}
</code></pre>
<p>This constructor</p>
<ul>
<li>Requires a <a href="xref:Microsoft.Xna.Framework.PlayerIndex"><strong>PlayerIndex</strong></a> value which is stored and will be used to get the states for the correct gamepad</li>
<li>Creates an empty state for <code>PreviousState</code> since there is no previous state yet.</li>
<li>Gets the current gamepad state as our starting <code>CurrentState</code>.</li>
</ul>
<p>This initialization ensures we have valid states to compare against in the first frame of our game, preventing any potential null reference issues when checking for input changes.</p>
<h3 id="gamepadinfo-methods">GamePadInfo Methods</h3>
<p>The <code>GamePadInfo</code> class needs methods for updating states, checking button states, and controlling vibration. Let's start with our update method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the state information for this gamepad input.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;&lt;/param&gt;
public void Update(GameTime gameTime)
{
    PreviousState = CurrentState;
    CurrentState = GamePad.GetState(PlayerIndex);

    if (_vibrationTimeRemaining &gt; TimeSpan.Zero)
    {
        _vibrationTimeRemaining -= gameTime.ElapsedGameTime;

        if (_vibrationTimeRemaining &lt;= TimeSpan.Zero)
        {
            StopVibration();
        }
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Unlike keyboard and mouse input, the gamepad update method takes a <a href="xref:Microsoft.Xna.Framework.GameTime"><strong>GameTime</strong></a> parameter. This allows us to track and manage timed vibration effects.</p>
</div>
<p>Next, we'll add methods to check various button states:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a value that indicates whether the specified gamepad button is current down.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The gamepad button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified gamepad button is currently down; otherwise, false.&lt;/returns&gt;
public bool IsButtonDown(Buttons button)
{
    return CurrentState.IsButtonDown(button);
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified gamepad button is currently up.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;The gamepad button to check.&lt;/param&gt;
/// &lt;returns&gt;true if the specified gamepad button is currently up; otherwise, false.&lt;/returns&gt;
public bool IsButtonUp(Buttons button)
{
    return CurrentState.IsButtonUp(button);
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified gamepad button was just pressed on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;&lt;The gamepad button to check./param&gt;
/// &lt;returns&gt;true if the specified gamepad button was just pressed on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasButtonJustPressed(Buttons button)
{
    return CurrentState.IsButtonDown(button) &amp;&amp; PreviousState.IsButtonUp(button);
}

/// &lt;summary&gt;
/// Returns a value that indicates whether the specified gamepad button was just released on the current frame.
/// &lt;/summary&gt;
/// &lt;param name=&quot;button&quot;&gt;&lt;The gamepad button to check./param&gt;
/// &lt;returns&gt;true if the specified gamepad button was just released on the current frame; otherwise, false.&lt;/returns&gt;
public bool WasButtonJustReleased(Buttons button)
{
    return CurrentState.IsButtonUp(button) &amp;&amp; PreviousState.IsButtonDown(button);
}
</code></pre>
<p>These methods serve two distinct purposes. For checking continuous states:</p>
<ul>
<li><code>IsButtonDown</code>: Returns true as long as a button is being held down.</li>
<li><code>IsButtonUp</code>: Returns true as long as a button is not being pressed.</li>
</ul>
<p>And for detecting state changes:</p>
<ul>
<li><code>WasButtonJustPressed</code>: Returns true only on the frame when a button changes from up-to-down.</li>
<li><code>WasButtonJustReleased</code>: Returns true only on the frame when a button changes from down-to-up.</li>
</ul>
<p>Finally, we'll add methods for controlling gamepad vibration:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Sets the vibration for all motors of this gamepad.
/// &lt;/summary&gt;
/// &lt;param name=&quot;strength&quot;&gt;The strength of the vibration from 0.0f (none) to 1.0f (full).&lt;/param&gt;
/// &lt;param name=&quot;time&quot;&gt;The amount of time the vibration should occur.&lt;/param&gt;
public void SetVibration(float strength, TimeSpan time)
{
    _vibrationTimeRemaining = time;
    GamePad.SetVibration(PlayerIndex, strength, strength);
}

/// &lt;summary&gt;
/// Stops the vibration of all motors for this gamepad.
/// &lt;/summary&gt;
public void StopVibration()
{
    GamePad.SetVibration(PlayerIndex, 0.0f, 0.0f);
}
</code></pre>
<p>The vibration methods provide control over the gamepad's haptic feedback:</p>
<ul>
<li><code>SetVibration</code>: Starts vibration at the specified strength for a set duration.</li>
<li><code>StopVibration</code>: Immediately stops all vibration.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>When setting vibration, you can specify both the strength (<code>0.0f</code> to <code>1.0f</code>) and duration. The vibration will automatically stop after the specified time has elapsed, so you don't need to manage stopping it manually.</p>
</div>
<p>That's it for the <code>GamePadInfo</code> class.  Next, let's create the actual input manager.</p>
<h2 id="the-inputmanager-class">The InputManager Class</h2>
<p>Now that we have classes to handle keyboard, mouse, and gamepad input individually, we can create a centralized manager class to coordinate all input handling.</p>
<p>In the <em>Input</em> directory of the <em>MonoGameLibrary</em> project, add a new file named <em>InputManager.cs</em> with this initial structure:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;

namespace MonoGameLibrary.Input;

public class InputManager
{

}
</code></pre><h3 id="inputmanager-properties">InputManager Properties</h3>
<p>The <code>InputManager</code> class needs properties to access each type of input device. Add these properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the state information of keyboard input.
/// &lt;/summary&gt;
public KeyboardInfo Keyboard { get; private set; }

/// &lt;summary&gt;
/// Gets the state information of mouse input.
/// &lt;/summary&gt;
public MouseInfo Mouse { get; private set; }

/// &lt;summary&gt;
/// Gets the state information of a gamepad.
/// &lt;/summary&gt;
public GamePadInfo[] GamePads { get; private set; }
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>GamePads</code> property is an array because MonoGame supports up to four gamepads simultaneously. Each gamepad is associated with a PlayerIndex (0-3).</p>
</div>
<h3 id="inputmanager-constructor">InputManager Constructor</h3>
<p>The constructor for the <code>InputManager</code> initializes the keybaord, mouse, and gamepad states. Add the following constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new InputManager.
/// &lt;/summary&gt;
/// &lt;param name=&quot;game&quot;&gt;The game this input manager belongs to.&lt;/param&gt;
public InputManager()
{
    Keyboard = new KeyboardInfo();
    Mouse = new MouseInfo();

    GamePads = new GamePadInfo[4];
    for (int i = 0; i &lt; 4; i++)
    {
        GamePads[i] = new GamePadInfo((PlayerIndex)i);
    }
}
</code></pre><h3 id="inputmanager-methods">InputManager Methods</h3>
<p>The <code>Update</code> method for the <code>InputManager</code> calls update for each device so that they can update their internal states.</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the state information for the keyboard, mouse, and gamepad inputs.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the timing values for the current frame.&lt;/param&gt;
public void Update(GameTime gameTime)
{
    Keyboard.Update();
    Mouse.Update();

    for (int i = 0; i &lt; 4; i++)
    {
        GamePads[i].Update(gameTime);
    }
}
</code></pre><h2 id="implementing-the-inputmanager-class">Implementing the InputManager Class</h2>
<p>Now tha we have our input management system complete, let's update our game to use it.  We'll do this in two steps:</p>
<ol>
<li>First, update the <code>Core</code> class to add the <code>InputManager</code> globally.</li>
<li>Update the <code>Game1</code> class to use the global input manager from <code>Core</code>.</li>
</ol>
<h3 id="updating-the-core-class">Updating the Core Class</h3>
<p>The <code>Core</code> class serves as our base game class, so we will update it to add and expose the <code>InputManager</code> globally.  Open the <em>Core.cs</em> file in the <em>MonoGameLibrary</em> project and update it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="6,39-47,103-104,112-115">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary.Input;

namespace MonoGameLibrary;

public class Core : Game
{
    internal static Core s_instance;

    /// &lt;summary&gt;
    /// Gets a reference to the Core instance.
    /// &lt;/summary&gt;
    public static Core Instance =&gt; s_instance;

    /// &lt;summary&gt;
    /// Gets the graphics device manager to control the presentation of graphics.
    /// &lt;/summary&gt;
    public static GraphicsDeviceManager Graphics { get; private set; }

    /// &lt;summary&gt;
    /// Gets the graphics device used to create graphical resources and perform primitive rendering.
    /// &lt;/summary&gt;
    public static new GraphicsDevice GraphicsDevice { get; private set; }

    /// &lt;summary&gt;
    /// Gets the sprite batch used for all 2D rendering.
    /// &lt;/summary&gt;
    public static SpriteBatch SpriteBatch { get; private set; }

    /// &lt;summary&gt;
    /// Gets the content manager used to load global assets.
    /// &lt;/summary&gt;
    public static new ContentManager Content { get; private set; }

    /// &lt;summary&gt;
    /// Gets a reference to to the input management system.
    /// &lt;/summary&gt;
    public static InputManager Input { get; private set; }

    /// &lt;summary&gt;
    /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed.
    /// &lt;/summary&gt;
    public static bool ExitOnEscape { get; set; }

    /// &lt;summary&gt;
    /// Creates a new Core instance.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;The title to display in the title bar of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;width&quot;&gt;The initial width, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;height&quot;&gt;The initial height, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;fullScreen&quot;&gt;Indicates if the game should start in fullscreen mode.&lt;/param&gt;
    public Core(string title, int width, int height, bool fullScreen)
    {
        // Ensure that multiple cores are not created.
        if (s_instance != null)
        {
            throw new InvalidOperationException($&quot;Only a single Core instance can be created&quot;);
        }

        // Store reference to engine for global member access.
        s_instance = this;

        // Create a new graphics device manager.
        Graphics = new GraphicsDeviceManager(this);

        // Set the graphics defaults
        Graphics.PreferredBackBufferWidth = width;
        Graphics.PreferredBackBufferHeight = height;
        Graphics.IsFullScreen = fullScreen;

        // Apply the graphic presentation changes
        Graphics.ApplyChanges();

        // Set the window title
        Window.Title = title;

        // Set the core's content manager to a reference of hte base Game's
        // content manager.
        Content = base.Content;

        // Set the root directory for content
        Content.RootDirectory = &quot;Content&quot;;

        // Mouse is visible by default
        IsMouseVisible = true;
    }

    protected override void Initialize()
    {
        base.Initialize();

        // Set the core's graphics device to a reference of the base Game's
        // graphics device.
        GraphicsDevice = base.GraphicsDevice;

        // Create the sprite batch instance.
        SpriteBatch = new SpriteBatch(GraphicsDevice);

        // Create a new input manager
        Input = new InputManager();
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the input manager
        Input.Update(gameTime);

        if (ExitOnEscape &amp;&amp; Input.Keyboard.IsKeyDown(Keys.Escape))
        {
            Exit();
        }

        base.Update(gameTime);
    }
}
</code></pre>
<p>The key changes to the <code>Core</code> class are:</p>
<ol>
<li>Added the <code>using MonoGameLibrary.Input;</code> directive to access the <code>InputManager</code> class.</li>
<li>Added a static <code>Input</code> property to provide global access to the input manager.</li>
<li>Added a static <code>ExitOnEscape</code> property to set whether the game should exit when the Escape key on the keyboard is pressed.</li>
<li>In <code>Initialize</code> the input manager is created.</li>
<li>Added an override for the <code>Update</code> method where:
<ol>
<li>The input manager is updated</li>
<li>A check is made to see if <code>ExitOnEscape</code> is true and if the Escape keyboard key is pressed.</li>
</ol>
</li>
</ol>
<h3 id="updating-the-game1-class">Updating the Game1 Class</h3>
<p>Now let's update our <code>Game1</code> class to use the new input management system through the <code>Core</code> class.  Open <em>Game1.cs</em> in the game project and update it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="74,80,86,92,98,106,111,114,118,124,126-127,132,138,144,150">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);

        base.LoadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        base.Update(gameTime);
    }

    private void CheckKeyboardInput()
    {
        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (Input.Keyboard.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }
    }

    private void CheckGamePadInput()
    {
        GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One];

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadOne.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
        }
        else
        {
            GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadOne.LeftThumbStick != Vector2.Zero)
        {
            _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
            _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, _slimePosition);

        // Draw the bat sprite 10px to the right of the slime.
        _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0));

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes to the <code>Game1</code> class are:</p>
<ol>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>, the check for the gamepad back button or keyboard escape key being pressed was removed.  This is now handled by the <code>ExitOnEscape</code> property and the <code>Update</code> method of the <code>Core</code> class.</li>
<li>In <code>CheckKeyboardInput</code> and <code>CheckGamepadInput</code>, instead of getting the keyboard and gamepad states and then using the states, calls to check those devices are now done through the input.</li>
</ol>
<p>Running the game now, you will be able to control it the same as before, only now we're using our new <code>InputManager</code> class instead.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/input-moving-slime.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 11-1: The slime moving around based on device input</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you learned how to:</p>
<ul>
<li>Detect the difference between continuous and single-frame input states.</li>
<li>Create classes to manage different input devices.</li>
<li>Build a centralized <code>InputManager</code> to coordinate all input handling that is:
<ul>
<li>Reusable across different game projects</li>
<li>Easy to maintain and extend</li>
<li>Consistent across different input devices</li>
</ul>
</li>
<li>Integrate the input system into the <code>Core</code> class for global access.</li>
<li>Update the game to use the new input management system.</li>
</ul>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What's the difference between checking if an input is &quot;down&quot; versus checking if it was &quot;just pressed&quot;?</p>
<div class="question-answer"><p>&quot;Down&quot; checks if an input is currently being held, returning true every frame while held. &quot;Just pressed&quot; only returns true on the first frame when the input changes from up to down, requiring comparison between current and previous states.</p>
</div>
</li>
<li><p>Why do we track both current and previous input states?</p>
<div class="question-answer"><p>Tracking both states allows us to detect when input changes occur by comparing the current frame's state with the previous frame's state. This is essential for implementing &quot;just pressed&quot; and &quot;just released&quot; checks.</p>
</div>
</li>
<li><p>What advantage does the <code>InputManager</code> provide over handling input directly?</p>
<div class="question-answer"><p>The <code>InputManager</code> centralizes all input handling, automatically tracks states between frames, and provides a consistent API across different input devices. This makes the code more organized, reusable, and easier to maintain.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
