<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-21-input-buffering">Chapter 21: Input Buffering</h1>
<p class="text-secondary">Learn how to implement input buffering for more responsive controls.</p>
<p>In the <a href="../20_the_game/index.md">previous chapter</a> we completed our Dungeon Slime game with class snake-like mechanics.  While the game is now playable, you might have noticed an issue with the inputs.  In games where movement updates happen at fixed intervals that are less frequent than input polling, inputs can sometimes feel unresponsive, especially when trying to make multiple inputs in succession.</p>
<p>For instance, if a player wants to navigate a tight corner by pressing up and then immediately left, pressing these keys in rapid succession often results in only the second input being registered, causing the slime to not move as expected.  This happens because the second input overwrites the first one before the ame has a chance to process it, leading ot frustrating gameplay.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Learn what input buffering is and why it is essential for responsive gameplay.</li>
<li>Understand how to implement a queue-based input buffer system.</li>
<li>Modify the game's input handling to store and process inputs in sequence.</li>
</ul>
<p>Let's start by understanding input buffering.</p>
<h2 id="understanding-input-buffering">Understanding Input Buffering</h2>
<p>Input buffering is a technique used in game development to temporarily store player inputs that cannot be immediately processed. Instead of discarding these inputs, they are placed in a queue and processed in order when the game is ready to handle them.</p>
<p>Games like snake often update movement at fixed intervals rather than continuously. This creates a disconnect between when the player presses a button (which is checked every frame) and when the game can actually respond to that input (which happens on a less frequent movement cycle). Without input buffering:</p>
<ul>
<li>Players must time their inputs perfectly to align with the game's update cycle.</li>
<li>Rapid inputs are lost because only the last input is remembered.</li>
<li>The game feels unresponsive and frustrating, especially during quick turns.</li>
</ul>
<p>A well-implemented input buffer gives players a more forgiving and responsive experience by:</p>
<ol>
<li>Storing inputs that arrive between movement updates.</li>
<li>Preserving the order of inputs for more predictable behavior.</li>
<li>Creating a sense that the game is actually listening to the player.</li>
</ol>
<p>The size of an input buffer is an important design decision. If it is too small, players still might feel the game isn't responsive enough during complex sequences. If it is too large, the game might feel like it is playing itself as it works through the backlog of buffered commands. For a snake-style game, a buffer size of two is typically ideal:</p>
<ul>
<li>It allows for quick two-direction turns (like up-then-left to navigate a corner).</li>
<li>It's small enough that players don't accidentally queue up too many moves.</li>
<li>It keeps the game challenging while removing most frustration with input.</li>
</ul>
<h2 id="implementing-an-input-buffer">Implementing an Input Buffer</h2>
<p>Now that we understand why input buffering is important, let's implement it in our game. We'll create a queue-based system that stores the last two directional inputs from the player.</p>
<p>Our implementation will require three main changes to the existing code:</p>
<ol>
<li>Adding new fields to the <code>GameScene</code> class to store our buffer.</li>
<li>Updating how we process input in the <code>CheckInput</code> method.</li>
<li>Modifying how we apply movement in the <code>UpdateSlimeMovement</code> method.</li>
</ol>
<p>Let's start by modifying the <code>GameScene</code> class to include an input buffer. Open the <em>GameScene.cs</em> file and add the following fields:</p>
<pre><code class="lang-csharp">// Buffer to queue inputs input by player during input polling.
private Queue&lt;Vector2&gt; _inputBuffer;

// The maximum size of the buffer queue.
private const int MAX_BUFFER_SIZE = 2;
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1?view=net-9.0%3E"><code>Queue&lt;T&gt;</code></a> is a First In, First Out (FIFO) collection in C#. When you add items with <code>Enqueue()</code>, they join the end of the line, and when you retrieve items with <code>Dequeue()</code>, you always get the oldest item (the one at the front of the line). Think of it like people waiting in line - the first person to arrive is the first one served.</p>
</div>
<p>This queue will store the directional vectors (up, down, left, right) that we will apply to the slime's movement in the order they were received.</p>
<p>Next, we need to initialize this queue in the <code>InitializeNewGame</code> method:</p>
<pre><code class="lang-csharp" highlight-lines="30-31">private void InitializeNewGame()
{
    // Create the list of slime segments
    _slimes = new List&lt;SlimeSegment&gt;();

    // Initial slime position will be the center tile of the tile map.
    int centerRow = _tilemap.Rows / 2;
    int centerColumn = _tilemap.Columns / 2;

    // Create the initial head segment.
    SlimeSegment segment = new SlimeSegment();
    segment.At = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight);
    segment.To = segment.At + new Vector2(_tilemap.TileWidth, 0);
    segment.Direction = Vector2.UnitX;
    _slimes.Add(segment);

    // Set the initial direction to match the head
    _nextDirection = segment.Direction;

    // Initialize the bat position to a random position
    AssignRandomBatPosition();

    // Assign the initial random position and velocity to the bat
    AssignRandomBatVelocity();

    // Reset the timer and score
    _tickTimer = s_tickTime;
    _score = 0;

    // initialize the input buffer.
    _inputBuffer = new Queue&lt;Vector2&gt;(MAX_BUFFER_SIZE);
}
</code></pre><h3 id="updating-the-checkinput-method">Updating the CheckInput Method</h3>
<p>Next, we need to update the <code>CheckInput</code> method.  Instead of immediately overwriting our next direction, we'll add valid input directions to the queue.  Update <code>CheckInput</code> to the following:</p>
<pre><code class="lang-csharp" highlight-lines="11,31-49">private void CheckInput()
{
    // Check for pause action
    if (_controller.Pause())
    {
        _pauseMenu.IsEnabled = _pauseMenu.IsVisible = _pauseMenu.IsSelected = true;
        return;
    }

    // Store the potential direction change
    Vector2? potentialNextDirection = null;

    // Check movement actions
    if (_controller.MoveUp())
    {
        potentialNextDirection = -Vector2.UnitY;
    }
    else if (_controller.MoveDown())
    {
        potentialNextDirection = Vector2.UnitY;
    }
    else if (_controller.MoveLeft())
    {
        potentialNextDirection = -Vector2.UnitX;
    }
    else if (_controller.MoveRight())
    {
        potentialNextDirection = Vector2.UnitX;
    }

    // If a new direction was input, consider adding it to the buffer.
    if (potentialNextDirection.HasValue &amp;&amp; _inputBuffer.Count &lt; MAX_BUFFER_SIZE)
    {
        // If the buffer is empty, validate against the current direction;
        // otherwise, validate against the last buffered direction
        Vector2 validateAgainst = _inputBuffer.Count &gt; 0 ?
                                    _inputBuffer.Last() :
                                    _slimes[0].Direction;

        // Check if this is a valid direction change (not reversed).
        if (Vector2.Dot(potentialNextDirection.Value, validateAgainst) &gt;= 0)
        {
            // Only add if it is different from the las buffered direction.
            if (_inputBuffer.Count == 0 || _inputBuffer.Last() != potentialNextDirection.Value)
            {
                _inputBuffer.Enqueue(potentialNextDirection.Value);
            }
        }
    }
}
</code></pre>
<p>The key changes made here are:</p>
<ol>
<li>The <code>potentialNewDirection</code> is now a nullable <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a> value.  We start it as null now so that we're not always enqueuing the already stored next direction every update.</li>
<li>A check is made to see if there is a new direction that has been input and if the buffer is not full.</li>
<li>If a new direction is input and the buffer is not full:
<ol>
<li>The validation is made using <a href="xref:Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)"><strong>Vector2.Dot</strong></a> just like before to ensure it is a valid direction</li>
<li>A final check is made to ensure that the direction being queued to the input buffer isn't the same direction as one that is already queued.  No need to queue the same direction twice.</li>
</ol>
</li>
</ol>
<h3 id="updating-the-updateslimemovement-method">Updating the UpdateSlimeMovement Method</h3>
<p>Finally, we need to modify how we apply the movement direction during the movement update cycle.  Make the following changes to the start of the <code>UpdateSlimeMovement</code> method:</p>
<pre><code class="lang-cs"> private void UpdateSlimeMovement()
{
    // Get the next direction from the input buffer if one is available
    if (_inputBuffer.Count &gt; 0)
    {
        _nextDirection = _inputBuffer.Dequeue();
    }

    // Rest of existing implementation for this method doesn't change....
}
</code></pre>
<p>The key change here is that we now dequeue a direction from the input buffer rather than directly using the <code>_nextDirection</code> value. This ensures we process inputs in the order they were received, preserving the player's intent.</p>
<h2 id="testing-the-input-buffer">Testing the Input Buffer</h2>
<p>With these changes in place, our game now supports input buffering.  Let's see how it improves the gameplay experience, particularly for making tight turns.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 21-1: Gameplay demonstration showing improved responsiveness with input buffering, particularly when making tight turns</strong></td>
</tr>
</tbody>
</table>
<ol>
<li>When navigating a corner, players can now quickly press up followed by left (or any other combination), and both inputs will be respected.</li>
<li>The game feels more responsive since it remembers inputs between movement update cycles.</li>
<li>Complex maneuvers are easier to execute since timing is more forgiving.</li>
</ol>
<p>The difference might seem subtle, but it significantly reduces frustration during gameplay, especially as the slime chain grows longer and navigation becomes more challenging.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Let's review what you accomplished in this chapter:</p>
<ul>
<li>Learned about input buffering and how it addresses the timing disconnect between input polling and movement updates.</li>
<li>Implemented a queue-based input buffer with a capacity of two inputs.</li>
<li>Modified the input handling to store directional commands.</li>
<li>Updated the movement system to process buffered input in sequence.</li>
<li>Improved the game's responsiveness for quick turns and navigation.</li>
</ul>
<p>This small additional enhances how the game feels to play, particularly when making rapid directional changes.  As the slime grows longer and navigation becomes more challenging, responsive controls become important to maintain a fair and enjoyable experience.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What problem does input buffering solve in grid-based movement games?</p>
<div class="question-answer"><p>Input buffering solves the timing disconnect between when players press buttons and when the game can actually process those inputs in games with fixed movement cycles.  Without buffering, inputs that occur between movement cycles are lost, especially when players make rapid sequential inputs.  This makes the game feel unresponsive and frustrating.</p>
</div>
</li>
<li><p>Why did we choose a buffer size of two for our input queue?</p>
<div class="question-answer"><p>A buffer size of two provides an ideal balance for a snake-style game: it's large enough to allow complex two-direction turns (like up-then-left), but small enough that players don't accidentally queue too many moves ahead.  This keeps the game responsive to player intent while maintaining challenge and preventing the game from feeling like it is playing itself with too many buffered commands.</p>
</div>
</li>
<li><p>In what order are buffered inputs processed, and why is this important?</p>
<div class="question-answer"><p>Buffered inputs are processed in a First In, First Out (FIFO) order using a queue data structure.  This is important because it preserves the sequence of player inputs, ensuring the game responds in teh order the player intended.  Processing inputs int he correct sequence makes the control feel natural and predictable, especially during complex maneuvers where the timing and order of directional changes matter.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
