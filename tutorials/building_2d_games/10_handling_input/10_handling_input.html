<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-10-handling-input">Chapter 10: Handling Input</h1>
<p class="text-secondary">Learn how to handle keyboard, mouse, and gamepad input in MonoGame.</p>
<p>When you play a game, you need ways to control what's happening; using a keyboard or gamepad to control a character or clicking the mouse to navigate a menu, MonoGame helps us handle all these different types of controls through dedicated input classes:</p>
<ul>
<li><a href="xref:Microsoft.Xna.Framework.Input.Keyboard"><strong>Keyboard</strong></a>: Detects which keys are being pressed.</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Mouse"><strong>Mouse</strong></a>: Tracks mouse movement, button clicks, and scroll wheel use.</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.GamePad"><strong>GamePad</strong></a>: Manages controller input like button presses and thumbstick movement.</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel"><strong>TouchPanel</strong></a>: Manages touch input on devices with a touch panel such as mobile phones and tablets.</li>
</ul>
<p>Each of these input types has a <code>GetState</code> method that, when called, checks what is happening with that device at that moment. Think of it like taking a snapshot; when you call <code>GetState</code>, MonoGame looks at that exact moment to see which buttons are pressed, where the mouse is, or how the controller is being used.</p>
<p>In this chapter you will, we will learn how to use each of these dedicated input classes to handle player input.</p>
<h2 id="keyboard-input">Keyboard Input</h2>
<p>The keyboard is often the primary input device for PC games, used for everything from character movement to menu navigation. MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Input.Keyboard"><strong>Keyboard</strong></a> class to handle keyboard input, making it easy to detect which keys are being pressed at any time.  Calling <a href="xref:Microsoft.Xna.Framework.Input.Keyboard.GetState"><strong>Keyboard.GetState</strong></a> will retrieve the current state of the keyboard as a <a href="xref:Microsoft.Xna.Framework.Input.KeyboardState"><strong>KeyboardState</strong></a> struct.</p>
<h3 id="keyboardstate-struct">KeyboardState Struct</h3>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.KeyboardState"><strong>KeyboardState</strong></a> struct contains methods that can be used to determine if a keyboard key is currently down or up:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.KeyboardState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys)"><strong>IsKeyDown(Keys)</strong></a></td>
<td>Returns <code>true</code> if the specified key is down; otherwise, returns <code>false</code>.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.KeyboardState.IsKeyUp(Microsoft.Xna.Framework.Input.Keys)"><strong>IsKeyUp(Keys)</strong></a></td>
<td>Returns <code>true</code> if the specified key is up; otherwise, returns <code>false</code>.</td>
</tr>
</tbody>
</table>
<p>For example, if we wanted to see if the Space key is down, you could use the following:</p>
<pre><code class="lang-csharp">// Get the current state of keyboard input.
KeyboardState keyboardState = Keyboard.GetState();

// Check if the space key is down.
if(keyboardState.IsKeyDown(Keys.Space))
{
    // The space key is down, so do something.
}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>Notice we store the keyboard state in a variable instead of calling <a href="xref:Microsoft.Xna.Framework.Input.Keyboard.GetState"><strong>Keyboard.GetState</strong></a> multiple times. This is more efficient and ensures consistent input checking within a single frame.</p>
</div>
<h2 id="mouse-input">Mouse Input</h2>
<p>The mouse is often the secondary input device for PC games, used for various actions from camera movement to interacting with menus and objects.  MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Input.Mouse"><strong>Mouse</strong></a> class to handle mouse input, making it easy to detect which buttons are pressed, the position of the mouse cursor, and the value of the scroll wheel.  Calling <a href="xref:Microsoft.Xna.Framework.Input.Mouse.GetState"><strong>Mouse.GetState</strong></a> will retrieve the current state of the mouse as a <a href="xref:Microsoft.Xna.Framework.Input.MouseState"><strong>MouseState</strong></a> struct.</p>
<h3 id="mousestate-struct">MouseState Struct</h3>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.MouseState"><strong>MouseState</strong></a> struct contains properties that can be used to determine the state of the mouse buttons, the mouse position, and the scroll wheel value:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.MouseState.LeftButton"><strong>LeftButton</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the left mouse button.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.MouseState.MiddleButton"><strong>MiddleButton</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the middle mouse button.  This is often the button when pressing the scroll wheel down as a button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.MouseState.Position"><strong>Position</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Point"><strong>Point</strong></a></td>
<td>Returns the position of the mouse cursor relative to the bounds of the game window.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.MouseState.RightButton"><strong>RightButton</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the right mouse button.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.MouseState.ScrollWheelValue"><strong>ScrollWheelValue</strong></a></td>
<td><code>int</code></td>
<td>Returns the <strong>cumulative</strong> scroll wheel value since the start of the game</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.MouseState.XButton1"><strong>XButton1</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the first extended button on the mouse.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.MouseState.XButton2"><strong>XButton2</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the second extended button on the mouse.</td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p><a href="xref:Microsoft.Xna.Framework.Input.MouseState.ScrollWheelValue"><strong>ScrollWheelValue</strong></a> returns the cumulative value of the scroll wheel since the start of the game, not how much it moved since the last update.  To determine how much it moved between one update and the next, you would need to compare it with the previous frame's value.  We'll discuss comparing previous and current frame values for inputs in the next chapter.</p>
</div>
<p>Unlike keyboard input which uses <a href="xref:Microsoft.Xna.Framework.Input.KeyboardState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys)"><strong>IsKeyDown(Keys)</strong></a>/<a href="xref:Microsoft.Xna.Framework.Input.KeyboardState.IsKeyUp(Microsoft.Xna.Framework.Input.Keys)"><strong>IsKeyUp(Keys)</strong></a> methods mouse buttons return a <a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a>:</p>
<ul>
<li><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState.Pressed</strong></a>: The button is being held down.</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState.Released</strong></a>: The button is not being pressed.</li>
</ul>
<p>For example, if we wanted to see if the left mouse button is down, you could use the following</p>
<pre><code class="lang-csharp">// Get the current state of mouse input.
MouseState mouseState = Mouse.GetState();

// Check if the left mouse button is pressed down.
if(mouseState.LeftButton == ButtonState.Pressed)
{
    // The left button is down, so do something.
}
</code></pre><h2 id="gamepad-input">Gamepad Input</h2>
<p>Gamepads are often used as a primary input for a game or an alternative for keyboard and mouse controls.  MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Input.GamePad"><strong>GamePad</strong></a> class to handle gamepad input, making it easy to detect which buttons are pressed and the value of the thumbsticks. Calling <a href="xref:Microsoft.Xna.Framework.Input.GamePad.GetState(Microsoft.Xna.Framework.PlayerIndex)"><strong>GamePad.GetState</strong></a> will retrieve the state of the gamepad as a <a href="xref:Microsoft.Xna.Framework.Input.GamePadState"><strong>GamePadState</strong></a> struct.  Since multiple gamepads can be connected, you will need to supply a <a href="xref:Microsoft.Xna.Framework.PlayerIndex"><strong>PlayerIndex</strong></a> value to specify which gamepad state to retrieve.</p>
<h3 id="gamepadstate-struct">GamePadState Struct</h3>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.GamePadState"><strong>GamePadState</strong></a> struct and properties that can be used to get the state of the buttons, dpad, triggers, and thumbsticks:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadState.Buttons"><strong>Buttons</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons"><strong>GamePadButtons</strong></a></td>
<td>Returns a struct that identifies which buttons on the controller are pressed.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadState.DPad"><strong>DPad</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadDPad"><strong>GamePadDPad</strong></a></td>
<td>Returns a struct that identifies which directions on the DPad are pressed.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadState.IsConnected"><strong>IsConnected</strong></a></td>
<td><code>bool</code></td>
<td>Returns a value that indicates whether the controller is connected.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadState.ThumbSticks"><strong>ThumbSticks</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadThumbSticks"><strong>GamePadThumbSticks</strong></a></td>
<td>Returns a struct that contains the direction of each thumbstick.  Each thumbstick (left and right) are represented as a <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a> value between <code>-1.0f</code> and <code>1.0</code> for the x- and y-axes.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadState.Triggers"><strong>Triggers</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadTriggers"><strong>GamePadTriggers</strong></a></td>
<td>Returns a struct that contains the value of each trigger. Each trigger (left and right) are represented as a <code>float</code> value between <code>0.0f</code>, meaning not pressed, and <code>1.0f</code>, meaning fully pressed.</td>
</tr>
</tbody>
</table>
<h4 id="buttons">Buttons</h4>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.GamePadState.Buttons"><strong>GamePadState.Buttons</strong></a> property returns a <a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons"><strong>GamePadButtons</strong></a> struct that can be used to identify which buttons on the controller are pressed.  This struct contains the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.A"><strong>A</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the A button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.B"><strong>B</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the B button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.Back"><strong>Back</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the Back button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.BigButton"><strong>BigButton</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the BigButton button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.LeftShoulder"><strong>LeftShoulder</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the LeftShoulder button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.LeftStick"><strong>LeftStick</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the LeftStick button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.RightShoulder"><strong>RightShoulder</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the RightShoulder button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.RightStick"><strong>RightStick</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the RightStick button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.Start"><strong>Start</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the Start button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.X"><strong>X</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the X button</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadButtons.Y"><strong>Y</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the Y button</td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>Recall from <a href="../01_what_is_monogame/index.html">Chapter 01</a> that MonoGame is a implementation the XNA API.  Since XNA was originally created for making games on Windows PC and Xbox 360, the names of the gamepad buttons match those of an Xbox 360 controller.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Front</th>
<th style="text-align: left;">Back</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Xbox</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><img src="images/xbox-controller-front.svg" alt="Front Of Controller"></td>
<td style="text-align: left;"><img src="images/xbox-controller-back.svg" alt="Back Of Controller"></td>
</tr>
<tr>
<td style="text-align: left;">Playstation</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><img src="images/ps-controller-front.svg" alt="Front Of Controller"></td>
<td style="text-align: left;"><img src="images/ps-controller-back.svg" alt="Back Of Controller"></td>
</tr>
</tbody>
</table>
</div>
<p>Like with the <a href="#mousestate-struct">mouse input</a>, each of these buttons are represented by a <a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a> enum value.  For instance, if you wanted to check if the A button is being pressed you could do the following:</p>
<pre><code class="lang-csharp">// Get the current state of player one's gamepad
GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);

// Check if the A button is pressed down.
if(gamePadState.Buttons.A == ButtonState.Pressed)
{
    // Button A is pressed, do something.
}
</code></pre><h4 id="dpad">DPad</h4>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.GamePadState.DPad"><strong>DPad</strong></a>  property returns a <a href="xref:Microsoft.Xna.Framework.Input.GamePadDPad"><strong>GamePadDPad</strong></a> struct that can be used to identify which DPad buttons on the controller are pressed. This struct contains the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadDPad.Down"><strong>Down</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the DPad Down button.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadDPad.Down"><strong>Left</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the DPad Left button.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadDPad.Down"><strong>Right</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the DPad Right button.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadDPad.Down"><strong>Up</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a></td>
<td>Returns the state of the DPad Up Button.</td>
</tr>
</tbody>
</table>
<p>Like with the <a href="#buttons">Buttons</a>, these also return a <a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a> enum value to represent the state of the DPad button.  For instance, if you wanted to check if the DPad up button is being pressed, you could do the following:</p>
<pre><code class="lang-csharp">// Get the current state of player one's gamepad
GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);

// Check if the down on the DPad is pressed.
if(gamePadState.DPad.Down == ButtonState.Pressed)
{
    // DPad down is pressed, do something.
}
</code></pre><h4 id="thumbsticks">Thumbsticks</h4>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.GamePadState.ThumbSticks"><strong>ThumbSticks</strong></a> property returns a <a href="xref:Microsoft.Xna.Framework.Input.GamePadThumbSticks"><strong>GamePadThumbSticks</strong></a> struct that can be used to retrieve the values of the left and right thumbsticks.  This struct contains the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadThumbSticks.Left"><strong>Left</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>The direction the left thumbstick is pressed.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadThumbSticks.Right"><strong>Right</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>The direction the right thumbstick is pressed.</td>
</tr>
</tbody>
</table>
<p>The thumbstick values are represented as a <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a> value:</p>
<ul>
<li>X-axis: A value between <code>-1.0f</code> (pushed fully to the left) and <code>1.0f</code> (pushed fully to the right).</li>
<li>Y-axis: A value between <code>-1.0f</code> (pushed fully downward) and <code>1.0f</code> (pushed fully upward).</li>
</ul>
<p>For example, if you wanted to move a sprite using the left thumbstick, you could do the following</p>
<pre><code class="lang-csharp">// Get the current state of player one's gamepad
GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);

// Get the value of the left thumbstick.
Vector2 leftStick = gamePadState.Thumbsticks.Left;

// Invert the y-axis value
leftStick.Y *= -1.0f;

// Apply the value to the position of the sprite.
sprite.Position += leftStick;
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Notice that we inverted the y-axis value of the thumbstick by multiplying it by <code>-1.0f</code>. This is necessary because the thumbstick y-axis values range from <code>-1.0f</code> (down) to <code>1.0f</code> (up).  The y-axis of the screen coordinates in MonoGame <strong>increases</strong> downward, as we saw in <a href="../06_working_with_textures/index.html#drawing-a-texture">Chapter 06</a>.</p>
<p>This inversion aligns the thumbstick's y-axis value with the screen movement.</p>
</div>
<h4 id="triggers">Triggers</h4>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.GamePadState.Triggers"><strong>Triggers</strong></a> property returns a <a href="xref:Microsoft.Xna.Framework.Input.GamePadTriggers"><strong>GamePadTriggers</strong></a> struct that can be used to retrieve the values of the left and right triggers. This struct contains the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadTriggers.Left"><strong>Left</strong></a></td>
<td><code>float</code></td>
<td>The value of the left trigger.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadTriggers.Right"><strong>Right</strong></a></td>
<td><code>float</code></td>
<td>The value of the left trigger.</td>
</tr>
</tbody>
</table>
<p>The trigger values are represented as a float value between <code>0.0f</code> (not pressed) to <code>1.0f</code> (fully pressed). The triggers on a gamepad, however, can be either <em>analog</em> or <em>digital</em> depending the gamepad manufacturer.  For gamepads with <em>digital</em> triggers, the value will always be either <code>0.0f</code> or <code>1.0f</code>, as a digital trigger does not register values in between based on the amount of pressure applied to the trigger.</p>
<p>For example, if we were creating a racing game, the right trigger could be used for acceleration like the following:</p>
<pre><code class="lang-csharp">// Get the current state of player one's gamepad
GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);

// Get the acceleration based on how far the right trigger is pushed down.
float acceleration = gamePadState.Triggers.Right;
</code></pre><h3 id="gamepadstate-methods">GamePadState Methods</h3>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.GamePadState"><strong>GamePadState</strong></a> struct also contains two methods that can be used to get information about the device's inputs as either being up or down:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadState.IsButtonDown(Microsoft.Xna.Framework.Input.Buttons)"><strong>IsButtonDown(Buttons)</strong></a></td>
<td>Returns a value that indicates whether the specified button is down.  Multiple <a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons</strong></a> values can be given using the bitwise OR <code>|</code> operator.  When multiple buttons are given, the return value indicates if all buttons specified are down, not just one of them.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.GamePadState.IsButtonUp(Microsoft.Xna.Framework.Input.Buttons)"><strong>IsButtonUp(Buttons)</strong></a></td>
<td>Returns a value that indicates whether the specified button is up.  Multiple <a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons</strong></a> values can be given using the bitwise OR <code>|</code> operator.  When multiple buttons are given, the return value indicates if all buttons specified are up, not just one of them.</td>
</tr>
</tbody>
</table>
<p>You can use the <a href="xref:Microsoft.Xna.Framework.Input.GamePadState.IsButtonDown(Microsoft.Xna.Framework.Input.Buttons)"><strong>IsButtonDown(Buttons)</strong></a> and <a href="xref:Microsoft.Xna.Framework.Input.GamePadState.IsButtonUp(Microsoft.Xna.Framework.Input.Buttons)"><strong>IsButtonUp(Buttons)</strong></a> methods to get the state of all buttons, including the DPad.  The following is a complete list of all of the <a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons</strong></a> enum values:</p>
<ul>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.A</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.B</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.Back</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.BigButton</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.DPadDown</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.DPadLeft</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.DPadRight</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.DPadUp</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.LeftShoulder</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.LeftStick</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.LeftThumbstickDown</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.LeftThumbstickLeft</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.LeftThumbstickRight</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.LeftThumbstickUp</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.LeftTrigger</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.None</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.RightShoulder</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.RightStick</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.RightStickDown</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.RightStickLeft</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.RightStickRight</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.RightStickUp</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.RightTrigger</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.Start</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.X</strong></a></li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Buttons"><strong>Buttons.Y</strong></a></li>
</ul>
<div class="CAUTION">
<h5>Caution</h5>
<p>While you can use these methods to get the state of any of these button inputs, the state will only tell you if it is being pressed or released.  For the actual thumbstick values and trigger values, you would need to use the properties instead.</p>
</div>
<p>For example, if we wanted to check if the A button on the the first gamepad is pressed, you could use the following:</p>
<pre><code class="lang-csharp">// Get the current state of player one's gamepad
GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);

// Check if the A button is down.
if(gamePadState.IsButtonDown(Buttons.A))
{
    // The A button is pressed, do something.
}
</code></pre><h3 id="gamepad-vibration">GamePad Vibration</h3>
<p>Another capability of gamepads is haptic feedback through vibration motors.  MonoGame allows you to control this feature using the <a href="xref:Microsoft.Xna.Framework.Input.GamePad.SetVibration(Microsoft.Xna.Framework.PlayerIndex,System.Single,System.Single)"><strong>GamePad.SetVibration</strong></a> method.  This method takes three parameters:</p>
<ol>
<li>The <a href="xref:Microsoft.Xna.Framework.PlayerIndex"><strong>PlayerIndex</strong></a> of the gamepad to vibrate.</li>
<li>The intensity of the left motor (from <code>0.0f</code> for no vibration to <code>1.0f</code> for maximum vibration).</li>
<li>The intensity of the right motor (using the same scale).</li>
</ol>
<p>Most modern gamepads have two vibration motors, a larger one (usually the left motor) for low-frequency rumble and a smaller one (usually the right motor) for high-frequency feedback.  By controlling these independently, you can create various haptic effects:</p>
<pre><code class="lang-csharp">// Make the gamepad vibrate at full intensity
GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);

// Stop all vibration
GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);

// Create a subtle, low-intensity vibration
GamePad.SetVibration(PlayerIndex.One, 0.3f, 0.1f);
</code></pre><h2 id="touchpanel-input">TouchPanel Input</h2>
<p>For mobile devices such as Android/iOS phones and tablets, the primary input device is the touch panel screen.  Touching a location on the screen is similar to clicking a location on your computer with a mouse.  MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel"><strong>TouchPanel</strong></a> class to handle touch input.</p>
<p>The <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel"><strong>TouchPanel</strong></a> class offers two ways of retrieving information about touch input:</p>
<ul>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.GetState"><strong>TouchPanel.GetState</strong></a> retrieves a <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchCollection"><strong>TouchCollection</strong></a> struct that contains <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation"><strong>TouchLocation</strong></a> values for each point of touch on the touch panel.</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.ReadGesture"><strong>TouchPanel.ReadGesture</strong></a> retrieves a <a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample"><strong>GestureSample</strong></a> struct that contains information about recent gestures that have been performed like a vertical or horizontal drag across the screen.</li>
</ul>
<h3 id="touchcollection">TouchCollection</h3>
<p>When calling <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.GetState"><strong>TouchPanel.GetState</strong></a> a <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchCollection"><strong>TouchCollection</strong></a> struct is returned.  This collection contains a <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation"><strong>TouchLocation</strong></a> value for each point of touch.</p>
<h4 id="touchlocation">TouchLocation</h4>
<p>Each <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation"><strong>TouchLocation</strong></a> value in a touch collection contains the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.Id"><strong>Id</strong></a></td>
<td><code>int</code></td>
<td>The id of the touch location.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.Position"><strong>Position</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>The position of the touch location.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.Pressure"><strong>Pressure</strong></a></td>
<td><code>float</code></td>
<td>The amount of pressure applied at the touch location. <strong>(Only available for Android devices.)</strong></td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>State</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocationState"><strong>TouchLocationState</strong></a></td>
<td>The current state of the touch location.</td>
</tr>
</tbody>
</table>
<p>The important properties of the location are the <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.Position"><strong>Position</strong></a> and the <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>State</strong></a> The position property will tell us the location of the touch event, and the state can be one of the following values:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>Invalid</strong></a></td>
<td>This touch location position is invalid.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>Moved</strong></a></td>
<td>This touch location position was updated or pressed at the same position.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>Pressed</strong></a></td>
<td>This touch location was pressed.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>Released</strong></a></td>
<td>This touch location was released.</td>
</tr>
</tbody>
</table>
<p>When the state is moved or pressed, then we know that location on the touch panel is being touched.  So we can capture it and use it like the following:</p>
<pre><code class="lang-csharp">// Get the current state of touch input.
TouchCollection touchCollection = TouchPanel.GetState();

foreach(TouchLocation touchLocation in touchCollection)
{
    if(touchLocation.State == TouchLocationState.Pressed || touchLocation.State == TouchLocationState.Moved)
    {
        // The the location at touchLocation.Position is currently being pressed,
        // so we can act on that information.
    }
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Unlike mouse input which only tracks a single point, <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel"><strong>TouchPanel</strong></a> supports multiple simultaneous touch points. The <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchCollection"><strong>TouchCollection</strong></a> contains all active touch points, which is why we loop through them in the sample above.</p>
</div>
<p>The state of a touch location progresses through the states typically in order of:</p>
<ul>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>Pressed</strong></a>: Initial contact with the screen.</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>Moved</strong></a> : Touch point moved while maintaining contact.</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>Released</strong></a>: Contact with screen ended.</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation.State"><strong>Invalid</strong></a> : Touch data is invalid (using when tracking data is lost).</li>
</ul>
<h3 id="gesturesample">GestureSample</h3>
<p>When calling <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.ReadGesture"><strong>TouchPanel.ReadGesture</strong></a> a <a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample"><strong>GestureSample</strong></a> struct containing the information about recent gestures that have been performed is returned.  The <a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample"><strong>GestureSample</strong></a> struct contains the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample.Delta"><strong>Delta</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>Gets the delta information about the first touch-point in the gesture sample.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample.Delta2"><strong>Delta2</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>Gets the delta information about the second touch-point in the gesture sample.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample.GestureType"><strong>GestureType</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>GestureType</strong></a></td>
<td>Gets the type of the gesture.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample.Position"><strong>Position</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>Gets the position of the first touch-point in the gesture sample.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample.Position2"><strong>Position2</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>Gets the position of the second touch-point in the gesture sample.</td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>Gestures have two delta properties and two position properties.  This is because some gestures require multiple touch inputs to perform, such as performing a pinch to zoom in or out.  You would need the location of both touch points to determine the correct zoom to apply during the gesture.</p>
</div>
<p>To determine what type of gesture is performed, we can get that from the <a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureSample.GestureType"><strong>GestureType</strong></a> property which will be one of the following values:</p>
<table>
<thead>
<tr>
<th>Gesture Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>DoubleTap</strong></a></td>
<td>The user double tapped the device twice which is always preceded by a Tap gesture.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>DragComplete</strong></a></td>
<td>States completion of a drag gesture (VerticalDrag, HorizontalDrag, or FreeDrag).</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>Flick</strong></a></td>
<td>States that a touch was combined with  a quick swipe.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>FreeDrag</strong></a></td>
<td>The user touched a point and the performed a free-form drag.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>Hold</strong></a></td>
<td>The user touched a single point for approximately one second.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>HorizontalDrag</strong></a></td>
<td>The user touched the screen and performed either a left-to-right or right-to-left drag gesture.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>None</strong></a></td>
<td>No gesture.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>Pinch</strong></a></td>
<td>The user converged or diverged two touch-points on the screen which is like a two-finger drag.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>PinchComplete</strong></a></td>
<td>An in-progress pinch gesture was completed.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>Tap</strong></a></td>
<td>The user touched a single point.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Input.Touch.GestureType"><strong>VerticalDrag</strong></a></td>
<td>The user touched the screen and performed either a top-to-bottom or bottom-to-top drag gesture.</td>
</tr>
</tbody>
</table>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Before gestures can be detected, they have to be enabled using <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures"><strong>TouchPanel.EnabledGestures</strong></a>.  This can be done in <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Game.Initialize</strong></a> like the following:</p>
<pre><code class="lang-csharp">protected override void Initialize()
{
    base.Initialize();
    
    // Enable gestures we want to handle
    TouchPanel.EnabledGestures =
        GestureType.Tap |
        GestureType.HorizontalDrag |
        GestureType.VerticalDrag;
}
</code></pre></div>
<p>The following is an example of using a gesture to detect horizontal and vertical drags:</p>
<pre><code class="lang-csharp">while(TouchPanel.IsGestureAvailable)
{
    GestureSample gesture = TouchPanel.ReadGesture();

    if(gesture.GestureType == GestureType.HorizontalDrag)
    {
        // A horizontal drag from left-to-right or right-to-left occurred.
        // You can use the Delta property to determine how much movement
        // occurred during the swipe.
        float xDragAmount = gesture.Delta.X;

        // Now do something with that information.
    }

    if(gesture.GestureType == GestureType.VerticalDrag)
    {
        // A vertical drag from top-to-bottom or bottom-to-top occurred.
        // You can use the Delta property to determine how much movement
        // occurred during the swipe.
        float yDragAmount = gesture.Delta.Y;

        // Now do something with that information.
    }
}
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Notice above that we use a <code>while</code> loop with <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.IsGestureAvailable"><strong>TouchPanel.IsGestureAvailable</strong></a> as the condition for the loop.  The reason we do this is because when a user performs a gesture, such as a horizontal drag across the screen, very quickly, what can often occurs is a series of multiple small drag gestures are registered and queued.</p>
<p>Each time <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.ReadGesture"><strong>TouchPanel.ReadGesture</strong></a> is called, it will dequeue the next gesture.  So to ensure that we handle the complete gesture, we loop the gesture queue until there are none left.</p>
</div>
<h2 id="implementing-input-in-our-game">Implementing Input in Our Game</h2>
<p>For our game, we're going to implement keyboard and gamepad controls based on the following criteria:</p>
<table>
<thead>
<tr>
<th>Keyboard Input</th>
<th>Gamepad Input</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Keys.W] and [Keys.Up]</td>
<td>[Thumbstick.Left.Y] and [Buttons.DPadUp]</td>
<td>Moves the slime up the screen.</td>
</tr>
<tr>
<td>[Keys.S] and [Keys.Down]</td>
<td>[Thumbstick.Left.Y] and [Buttons.DPadDown]</td>
<td>Moves the slime down the screen</td>
</tr>
<tr>
<td>[Keys.A] and [Keys.Left]</td>
<td>[Thumbstick.Left.X] and [Buttons.DPadLeft]</td>
<td>Moves the slime left on the screen.</td>
</tr>
<tr>
<td>[Keys.D] and [Keys.Right]</td>
<td>[Thumbstick.Left.X] and [Buttons.DPadRight]</td>
<td>Moves the slime right on the screen.</td>
</tr>
<tr>
<td>[Keys.Space]</td>
<td>[Buttons.A]</td>
<td>Increased the speed of the slime.</td>
</tr>
</tbody>
</table>
<p>Open <em>Game1.cs</em> and update it with the following:</p>
<pre><code class="lang-csharp" highlight-lines="17-21,62-66,71-159,170">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);

        base.LoadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        base.Update(gameTime);
    }

    private void CheckKeyboardInput()
    {
        // Get the state of keyboard input
        KeyboardState keyboardState = Keyboard.GetState();

        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (keyboardState.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (keyboardState.IsKeyDown(Keys.W) || keyboardState.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (keyboardState.IsKeyDown(Keys.S) || keyboardState.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (keyboardState.IsKeyDown(Keys.A) || keyboardState.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (keyboardState.IsKeyDown(Keys.D) || keyboardState.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }
    }

    private void CheckGamePadInput()
    {
        GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadState.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
        }
        else
        {
            GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadState.ThumbSticks.Left != Vector2.Zero)
        {
            _slimePosition.X += gamePadState.ThumbSticks.Left.X * speed;
            _slimePosition.Y -= gamePadState.ThumbSticks.Left.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadState.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadState.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadState.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadState.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, _slimePosition);

        // Draw the bat sprite 10px to the right of the slime.
        _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0));

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes made here are:</p>
<ol>
<li><p>The <code>_slimePosition</code> field was added to track the position of the slime as it moves.</p>
</li>
<li><p>The <code>MOVEMENT_SPEED</code> constant was added to use as the base multiplier for the movement speed.</p>
</li>
<li><p>The <code>CheckKeyboardInput</code> method was added which checks for input from the keyboard based on the input table above and moves the slime based on the keyboard input detected.</p>
</li>
<li><p>The <code>CheckGamePadInput</code> method was added which checks for input from the gamepad based on the input table above and moves the slime based the gamepad input detected.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The gamepad implementation includes a priority system for directional input.  The code prioritizes the analog thumbstick values over the digital DPad buttons.  This design choice provides players with more nuanced control, as analog inputs allow for a variable movements speed based on how far the thumbstick is pushed, while DPad buttons only provide on/off input states. The code first checks if either thumbstick axis has a non-zero value, and only falls back to DPad input when the thumbstick is centered.</p>
<p>To enhance player experience, the gamepad implementation also includes gamepad vibration when the speed boost is activated.  Haptic feedback like this creates a more immersive experience by engaging additional senses for the player beyond just visual and auditory feedback.</p>
</div>
</li>
<li><p>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>  <code>CheckKeyboardInput</code> and <code>CheckGamePadInput</code> methods are called.</p>
</li>
<li><p>In <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a>, the slime is now drawn using <code>_slimePosition</code> as the position.</p>
</li>
</ol>
<p>Running the game now, you can move the slime around using the keyboard with the arrow keys or WASD keys.  If you have a gamepad plugged in you can also use the DPad and left thumbstick.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/input-moving-slime.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 10-1: The slime moving around based on device input</strong></td>
</tr>
</tbody>
</table>
<h2 id="input-buffering">Input Buffering</h2>
<p>While checking for input every frame works well for continuous actions like movement, many games benefit from more sophisticated input handling techniques. One such technique is <strong>input buffering</strong>, which can significantly improve how responsive controls feel to players.</p>
<h3 id="understanding-input-buffering">Understanding Input Buffering</h3>
<p>Input buffering is a technique where the game temporarily stores player inputs that cannot be immediately processed. Instead of discarding these inputs, they are placed in a queue and processed in order when the game is ready to handle them.</p>
<p>Input buffering is particularly valuable in games where:</p>
<ul>
<li>Actions occur at fixed intervals rather than continuously (like turn-based games or grid movement).</li>
<li>Precise timing is required for complex input sequences (like fighting games).</li>
<li>Multiple rapid inputs need to be remembered in order (like quick directional changes).</li>
</ul>
<p>Without input buffering, players must time their inputs perfectly to align with the game's update cycle. With buffering, the game becomes more forgiving and responsive by:</p>
<ol>
<li>Storing inputs that arrive between action updates.</li>
<li>Preserving the order of inputs for more predictable behavior.</li>
<li>Creating a sense that the game is actually listening to the player.</li>
</ol>
<h3 id="implementing-a-simple-input-buffer">Implementing a Simple Input Buffer</h3>
<p>A basic input buffer can be implemented using a queue data structure, which follows a First-In-First-Out (FIFO) pattern:</p>
<pre><code class="lang-csharp">// Use a queue directly for input buffering
private Queue&lt;Vector2&gt; _inputBuffer;
private const int MAX_BUFFER_SIZE = 2;

// In initialization code:
_inputBuffer = new Queue&lt;Vector2&gt;(MAX_BUFFER_SIZE);

// In the input handling code:
KeyboardState keyboard = Keyboard.GetState();
Vector2 newDirection = Vector2.Zero;

if(keyboard.IsKeyDown(Keys.Up))
{
    newDirection = -Vector2.UnitY;
}
else if(keyboard.IsKeyDown(Keys.Down))
{
    newDirection = Vector2.UnitY;
}
else if(keyboard.IsKeyDown(Keys.Left))
{
    newDirection = -Vector2.UnitX;
}
else if(keyboard.IsKeyDown(Keys.Right))
{
    newDirection = Vector2.UnitX;
}

// Only add if a valid direction and does not exceed the buffer size
if(newDirection != Vector2.Zero &amp;&amp; _inputBuffer.Count &lt; MAX_BUFFER_SIZE)
{
    _inputBuffer.Enqueue(newDirection);
}

// In movement update code
if(_inputBuffer.COunt &gt; 0)
{
    Vector2 nextDirection = _inputBuffer.Dequeue();
    _position += nextDirection * _speed;
}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1?view=net-9.0%3E"><code>Queue&lt;T&gt;</code></a> is a First In, First Out (FIFO) collection in C#. When you add items with <code>Enqueue()</code>, they join the end of the line, and when you retrieve items with <code>Dequeue()</code>, you always get the oldest item (the one at the front of the line). Think of it like people waiting in line - the first person to arrive is the first one served.</p>
<p>This contrasts with a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1?view=net-9.0%3E"><code>Stack&lt;T&gt;</code></a>, which follows Last In, First Out (LIFO) behavior, where the most recently added item is the first one retrieved.</p>
</div>
<p>The size of an input buffer is an important design decision. If it's too small, players might still feel the game isn't responsive enough. If it's too large, the game might feel like it's playing itself by working through a backlog of commands.</p>
<h3 id="when-to-use-input-buffering">When to Use Input Buffering</h3>
<p>Consider implementing input buffering in your game when:</p>
<ul>
<li>Players complain about the game feeling &quot;unresponsive&quot;.</li>
<li>Your game uses fixed-interval updates for certain mechanics.</li>
<li>Actions require precise timing that is difficult for players to hit consistently.</li>
<li>You want to allow players to &quot;queue up&quot; their next few moves.</li>
</ul>
<p>We'll see a practical implementation of input buffering in <a href="../23_completing_the_game/index.html">Chapter 23</a> when we finalize our snake-like game mechanics, where timing and direction changes are critical to gameplay.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you learned how to:</p>
<ul>
<li>Handle keyboard input to detect key presses.</li>
<li>Handle mouse input including button clicks and cursor position.</li>
<li>Work with gamepad controls including buttons, thumbsticks, and vibration.</li>
<li>Understand touch input for mobile devices including touch points and gestures.</li>
<li>Implement movement controls using different input methods.</li>
<li>Consider controller-specific details like coordinate systems and analog vs digital input.</li>
</ul>
<p>In the next chapter, we'll learn how to track previous input states to handle single-press events and implement an input management system to simplify some of the complexity of handling input.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>Why do we store the result of <code>GetState</code> in a variable instead of calling it multiple times?</p>
<div class="question-answer"><p>Storing the state in a variable is more efficient and ensures consistent input checking within a frame. Each <code>GetState</code> call polls the device, which can impact performance if called repeatedly.</p>
</div>
</li>
<li><p>What's the main difference between how keyboard and mouse/gamepad button states are checked?</p>
<div class="question-answer"><p>Keyboard input uses <a href="xref:Microsoft.Xna.Framework.Input.KeyboardState.IsKeyUp(Microsoft.Xna.Framework.Input.Keys)"><strong>IsKeyUp</strong></a>/<a href="xref:Microsoft.Xna.Framework.Input.KeyboardState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys)"><strong>IsKeyDown</strong></a> methods, while mouse and gamepad buttons return a <a href="xref:Microsoft.Xna.Framework.Input.ButtonState"><strong>ButtonState</strong></a> enum value (Pressed or Released).</p>
</div>
</li>
<li><p>When using thumbstick values for movement, why do we multiply the Y value by -1?</p>
<div class="question-answer"><p>The thumbstick Y-axis values (-1.0f down to 1.0f up) are inverted compared to MonoGame's screen coordinate system (Y increases downward). Multiplying by -1 aligns the thumbstick direction with screen movement.</p>
</div>
</li>
<li><p>What's the difference between analog and digital trigger input on a gamepad?</p>
<div class="question-answer"><p>Analog triggers provide values between 0.0f and 1.0f based on how far they're pressed, while digital triggers only report 0.0f (not pressed) or 1.0f (pressed). This affects how you handle trigger input in your game.</p>
</div>
</li>
<li><p>What's the key difference between <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.GetState"><strong>TouchPanel.GetState</strong></a> and <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.ReadGesture"><strong>TouchPanel.ReadGesture</strong></a>?</p>
<div class="question-answer"><p><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.GetState"><strong>TouchPanel.GetState</strong></a> returns information about current touch points on the screen, while <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.ReadGesture"><strong>TouchPanel.ReadGesture</strong></a> provides information about specific gesture patterns like taps, drags, and pinches that have been performed.</p>
</div>
</li>
<li><p>Why do we use a while loop with <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.IsGestureAvailable"><strong>TouchPanel.IsGestureAvailable</strong></a> when reading gestures?</p>
<div class="question-answer"><p>Quick gestures can generate multiple gesture events that are queued. Using a while loop with <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.IsGestureAvailable"><strong>TouchPanel.IsGestureAvailable</strong></a> ensures we process all queued gestures, as <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchPanel.ReadGesture"><strong>TouchPanel.ReadGesture</strong></a> only returns one gesture at a time.</p>
</div>
</li>
<li><p>How does touch input differ from mouse input in terms of handling multiple input points?</p>
<div class="question-answer"><p>Touch input can handle multiple simultaneous touch points through the <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchCollection"><strong>TouchCollection</strong></a>, while mouse input only tracks a single cursor position. This allows touch input to support features like multi-touch gestures that aren't possible with a mouse.</p>
</div>
</li>
<li><p>What are the different states a <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation"><strong>TouchLocation</strong></a> can have and what do they indicate?</p>
<div class="question-answer"><p>A <a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocation"><strong>TouchLocation</strong></a> can have four states:</p>
<ul>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocationState"><strong>Pressed</strong></a>: Initial contact with the screen</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocationState"><strong>Moved</strong></a>: Touch point moved while maintaining contact</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocationState"><strong>Released</strong></a>: Contact with the screen ended</li>
<li><a href="xref:Microsoft.Xna.Framework.Input.Touch.TouchLocationState"><strong>Invalid</strong></a>: Touch data is not valid or tracking was lost</li>
</ul>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
