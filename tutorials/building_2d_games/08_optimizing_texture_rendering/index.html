<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-08-optimizing-texture-rendering">Chapter 08: Optimizing Texture Rendering</h1>
<p class="text-secondary">Explore optimization techniques when rendering textures using a texture atlas.</p>
<p>In <a href="../07_working_with_textures/index.html">Chapter 07</a>, you learned how to load and render textures using <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>. While rendering individual textures works well for simple games, it can lead to performance issues as your game grows more complex. In this chapter, we will explore how to optimize texture rendering by reducing texture swaps and creating reusable components for better organization.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Learn about texture swapping and its impact on performance.</li>
<li>Explore texture atlases as a solution for optimizing texture rendering.</li>
<li>Create reusable classes to optimize and simplify texture management and rendering.</li>
</ul>
<p>By the end of this chapter, you'll understand how to organize your game's textures for optimal performance and have a flexible texture atlas management system for your future game projects.</p>
<h2 id="texture-swapping">Texture Swapping</h2>
<p>Every time the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> method is executed with a different <em>texture</em> parameter than the previous <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> method call, a <em>texture swap</em> occurs, unbinding the current texture on the GPU and binding the new texture.</p>
<div class="NOTE">
<h5>Note</h5>
<p>A texture swap occurs when the GPU needs to switch between different textures during rendering. While each individual swap may seem trivial, the cumulative effect in a complex game can significantly impact performance.</p>
</div>
<p>For example, let's explore the following simplified draw calls for an example Pong game:</p>
<pre><code class="lang-csharp">// Using the paddle texture to render the left player paddle.
// The paddle texture is bound to the GPU.
_spriteBatch.Draw(paddleTexture, leftPaddlePosition, Color.White);

// Using the ball texture to render the ball
// A texture swap occurs, unbinding the paddle texture to bind the ball texture.
_spriteBatch.Draw(ballTexture, ballPosition, Color.White);

// Reusing the paddle texture to draw the right player paddle.
// A texture swap occurs again, unbinding the ball texture to bind the paddle texture.
_spriteBatch.Draw(paddleTexture, rightPaddlePosition, Color.White);
</code></pre>
<p>In the above example:</p>
<ol>
<li>The paddle texture is bound to the GPU so the left player paddle can be drawn.</li>
<li>The paddle texture is unbound from the GPU and the ball texture is bound so that the ball can be drawn (Texture Swap #1).</li>
<li>The ball texture is unbound from the GPU and the paddle texture is bound again so the right player paddle can be drawn (Texture Swap #2).</li>
</ol>
<p>These texture swaps, while negligible in this example, can become a performance issue in a full game where you might be drawing hundreds or thousands of sprites per frame.</p>
<h3 id="attempting-to-optimize-draw-order">Attempting to Optimize Draw Order</h3>
<p>One approach to get around this could be to optimize the order of the draw calls to minimize texture swaps  For example, if we reorder the draw calls from the previous example so that both paddles are drawn first and then the ball, the number of texture swaps is reduced from two to one:</p>
<pre><code class="lang-csharp">// Render the left and right paddles first.
// This reduces the number of texture swaps needed from two to one.
_spriteBatch.Draw(paddleTexture, _leftPaddlePosition, Color.White);
_spriteBatch.Draw(paddleTexture, _rightPaddlePosition, Color.White);
_spriteBatch.Draw(ballTexture, _ballPosition, Color.White);
</code></pre>
<p>However this is not a scalable solution. In a real game with dozens of different textures and complex draw orders for layered sprites, UI elements, particles, etc., managing draw order by texture becomes impractical and will conflict with desired visual layering.</p>
<h2 id="what-is-a-texture-atlas">What is a Texture Atlas</h2>
<p>A texture atlas (also known as a sprite sheet) is a large image file that contains multiple smaller images packed together. Instead of loading separate textures for each sprite, you load the single texture file with all the images combined like a scrapbook where all your photos are arranged on the same page.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Using a texture atlas not only eliminates texture swaps but also reduces memory usage and simplifies asset management since you're loading and tracking a single texture instead of many individual ones.</p>
</div>
<p>In the Pong example, imagine taking the paddle and ball image and combining them into a single image file like in Figure 8-1 below:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/pong-atlas.png" alt="Figure 8-1: Pong Texture Atlas Example"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 8-1: Pong Texture Atlas Example</strong></td>
</tr>
</tbody>
</table>
<p>Now when we draw these images, we would be using the same texture and just specify the source rectangles for the paddle or ball when needed, completely eliminating texture swaps.</p>
<pre><code class="lang-csharp">private Texture2D _textureAtlas;
private Rectangle _paddleSourceRect;
private Rectangle _ballSourceRect;

protected override void LoadContent()
{
    _textureAtlas = Content.Load&lt;Texture2D&gt;(&quot;pong-atlas&quot;);
    _paddleSourceRect = new Rectangle(0, 0, 32, 32);
    _ballSourceRect = new Rectangle(32, 0, 32, 32);
}

protected override void Draw(GameTime gameTime)
{
    GraphicsDevice.Clear(Color.CornflowerBlue);

    _spriteBatch.Begin();
    
    // All draw calls use the same texture, so there is no texture swapping!
    _spriteBatch.Draw(_textureAtlas, _leftPaddlePosition, _paddleSourceRect, Color.White);
    _spriteBatch.Draw(_textureAtlas, _rightPaddlePosition, _paddleSourceRect, Color.White);
    _spriteBatch.Draw(_textureAtlas, _ballPosition, _ballSourceRect, Color.White);
    
    _spriteBatch.End();
}
</code></pre>
<p>While using the single texture with source rectangles solves the potential performance issues, managing multiple source rectangles in variables can become complex as your game grows.  In the Pong example above, we're already tracking the source rectangles for both the paddle and ball sprites. Imagine scaling this up to a game with dozens of different images, each potentially needing their own position, rotation, scale, and other rendering properties.</p>
<p>To better organize this complexity, we can apply object-oriented design principles to create classes that encapsulates the information needed.</p>
<h2 id="the-textureregion-class">The TextureRegion Class</h2>
<p>In <a href="../07_working_with_textures/index.html#source-rectangle">Chapter 07</a>, we learned about using the <code>sourceRectangle</code> parameter to reuse the same texture when rendering sprites but specifying different regions within the texture to render.  Let's first build on this and create a class called <code>TextureRegion</code>.</p>
<p>We're going to add this class to the class library we created in <a href="../04_creating_a_class_library/index.html">Chapter 04</a>.  Perform the following:</p>
<ol>
<li>Add new directory in the <em>MonoGameLibrary</em> project named <code>Graphics</code></li>
<li>Create a new file named <em>TextureRegion.cs</em> inside the <em>Graphics</em> directory you just created.</li>
</ol>
<p>Add the following code for the foundation of the <code>TextureRegion</code> class to the <em>TextureRegion.cs</em> file:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameLibrary.Graphics;

/// &lt;summary&gt;
/// Represents a rectangular region within a texture.
/// &lt;/summary&gt;
public class TextureRegion { }
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <em>TextureRegion.cs</em> class file is placed in the <em>MonoGame/Graphics</em> directory and the class uses the <code>MonoGameLibrary.Graphics</code> <a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/namespaces#namespaces-overview">namespace</a> to keep graphics-related classes organized together.  As we add more functionality to the library, we will continue to use directories and namespaces to maintain a clean structure.</p>
</div>
<h3 id="textureregion-members">TextureRegion Members</h3>
<p>The <code>TextureRegion</code> class will utilize four properties to define and manage a region within a texture.  Add the following properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or Sets the source texture this texture region is part of.
/// &lt;/summary&gt;
public Texture2D Texture { get; set; }

/// &lt;summary&gt;
/// Gets or Sets the source rectangle boundary of this texture region within the source texture.
/// &lt;/summary&gt;
public Rectangle SourceRectangle { get; set; }

/// &lt;summary&gt;
/// Gets the width, in pixels, of this texture region.
/// &lt;/summary&gt;
public int Width =&gt; SourceRectangle.Width;

/// &lt;summary&gt;
/// Gets the height, in pixels, of this texture region.
/// &lt;/summary&gt;
public int Height =&gt; SourceRectangle.Height;
</code></pre>
<p>The <code>Texture</code> and <code>SourceRectangle</code> properties work together to define where the region is located: <code>Texture</code> specifies which texture contains the region, while <code>SourceRectangle</code> defines its exact location and size within that texture. The <code>Width</code> and <code>Height</code> properties provide convenient access to the region's dimensions without having to access the SourceRectangle property directly.</p>
<h3 id="textureregion-constructor">TextureRegion Constructor</h3>
<p>The <code>TextureRegion</code> class will provide two ways to create a new texture region.  Add the following constructors:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new texture region.
/// &lt;/summary&gt;
public TextureRegion() { }

/// &lt;summary&gt;
/// Creates a new texture region using the specified source texture.
/// &lt;/summary&gt;
/// &lt;param name=&quot;texture&quot;&gt;The texture to use as the source texture for this texture region.&lt;/param&gt;
/// &lt;param name=&quot;x&quot;&gt;The x-coordinate position of the upper-left corner of this texture region relative to the upper-left corner of the source texture.&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;&lt;The y-coordinate position of the upper-left corner of this texture region relative to the upper-left corner of the source texture./param&gt;
/// &lt;param name=&quot;width&quot;&gt;The width, in pixels, of this texture region.&lt;/param&gt;
/// &lt;param name=&quot;height&quot;&gt;The height, in pixels, of this texture region.&lt;/param&gt;
public TextureRegion(Texture2D texture, int x, int y, int width, int height)
{
    Texture = texture;
    SourceRectangle = new Rectangle(x, y, width, height);
}
</code></pre>
<p>The default constructor creates an empty texture region that can be configured later, while the parameterized constructor allows you to define the region's source texture and boundary in a single step. This second constructor provides a convenient way to create texture regions when you know the exact location and dimensions within the source texture upfront.</p>
<h3 id="textureregion-methods">TextureRegion Methods</h3>
<p>Finally, the <code>TextureRegion</code> class will provide three overloaded Draw methods to render the texture region. Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Submit this texture region for drawing in the current batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The spritebatch instance used for batching draw calls.&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The xy-coordinate location to draw this texture region on the screen.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;The color mask to apply when drawing this texture region on screen.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color)
{
    Draw(spriteBatch, position, color, 0.0f, Vector2.Zero, Vector2.One, SpriteEffects.None, 0.0f);
}

/// &lt;summary&gt;
/// Submit this texture region for drawing in the current batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The spritebatch instance used for batching draw calls.&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The xy-coordinate location to draw this texture region on the screen.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;The color mask to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;rotation&quot;&gt;The amount of rotation, in radians, to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;origin&quot;&gt;The center of rotation, scaling, and position when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;scale&quot;&gt;The scale factor to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;effects&quot;&gt;Specifies if this texture region should be flipped horizontally, vertically, or both when drawing on screen.&lt;/param&gt;
/// &lt;param name=&quot;layerDepth&quot;&gt;The depth of the layer to use when drawing this texture region on screen.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color, float rotation, Vector2 origin, float scale, SpriteEffects effects, float layerDepth)
{
    Draw(
        spriteBatch,
        position,
        color,
        rotation,
        origin,
        new Vector2(scale, scale),
        effects,
        layerDepth
    );
}

/// &lt;summary&gt;
/// Submit this texture region for drawing in the current batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The spritebatch instance used for batching draw calls.&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The xy-coordinate location to draw this texture region on the screen.&lt;/param&gt;
/// &lt;param name=&quot;color&quot;&gt;The color mask to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;rotation&quot;&gt;The amount of rotation, in radians, to apply when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;origin&quot;&gt;The center of rotation, scaling, and position when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;scale&quot;&gt;The amount of scaling to apply to the x- and y-axes when drawing this texture region on screen.&lt;/param&gt;
/// &lt;param name=&quot;effects&quot;&gt;Specifies if this texture region should be flipped horizontally, vertically, or both when drawing on screen.&lt;/param&gt;
/// &lt;param name=&quot;layerDepth&quot;&gt;The depth of the layer to use when drawing this texture region on screen.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch, Vector2 position, Color color, float rotation, Vector2 origin, Vector2 scale, SpriteEffects effects, float layerDepth)
{
    spriteBatch.Draw(
        Texture,
        position,
        SourceRectangle,
        color,
        rotation,
        origin,
        scale,
        effects,
        layerDepth
    );
}
</code></pre>
<p>These methods provide flexible options for rendering the texture region, similar to what the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> method does:</p>
<ul>
<li>The simplest overload requires only position and color.</li>
<li>A second overload exposes all rendering parameters while allowing for a single float value to be applied to both axes for scaling.</li>
<li>The third overload is the most flexible, offering all rendering parameters and independent x- and y-axis scaling.</li>
</ul>
<h2 id="the-textureatlas-class">The TextureAtlas Class</h2>
<p>In the <a href="#what-is-a-texture-atlas">What is a Texture Atlas</a> section above, a texture atlas was described as a scrap book that holds all of the individual sprites for the game.  These individual sprites can now be represented by the <code>TextureRegion</code> class we just created.  Now, we'll create the <code>TextureAtlas</code> class to represent the collection of the regions that make up all of our sprites.</p>
<p>Just like the <code>TextureRegion</code> class, we're going to add this to the class library.  In the <em>Graphics</em> directory within the <em>MonoGameLibrary</em> project, add a new file named <em>TextureAtlas.cs</em>.  Add the following code for the foundation fo the <code>TextureAtlas</code> class to the <em>TextureAtlas.cs</em> file:</p>
<pre><code class="lang-csharp">using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameLibrary.Graphics;

public class TextureAtlas { }
</code></pre><h3 id="textureatlas-members">TextureAtlas Members</h3>
<p>The <code>TextureAtlas</code> class needs two key members to manage texture regions. Add the following:</p>
<pre><code class="lang-csharp">private Dictionary&lt;string, TextureRegion&gt; _regions;

/// &lt;summary&gt;
/// Gets or Sets the source texture represented by this texture atlas.
/// &lt;/summary&gt;
public Texture2D Texture { get; set; }
</code></pre>
<p>The private <code>_regions</code> dictionary stores named texture regions, allowing us to retrieve specific regions by name, while the <code>Texture</code> property holds the source texture that contains all the regions. Together, these members enable the atlas to manage multiple texture regions from a single source texture.</p>
<h3 id="textureatlas-constructors">TextureAtlas Constructors</h3>
<p>The <code>TextureAtlas</code> class will provide two ways to create a new atlas.  Add the following constructors:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new texture atlas.
/// &lt;/summary&gt;
public TextureAtlas()
{
    _regions = new Dictionary&lt;string, TextureRegion&gt;();
}

/// &lt;summary&gt;
/// Creates a new texture atlas instance using the given texture.
/// &lt;/summary&gt;
/// &lt;param name=&quot;texture&quot;&gt;The source texture represented by the texture atlas.&lt;/param&gt;
public TextureAtlas(Texture2D texture)
{
    Texture = texture;
    _regions = new Dictionary&lt;string, TextureRegion&gt;();
}
</code></pre>
<p>The default constructor creates an empty atlas that can be configured later, while the parameterized constructor allows you to specify the source texture immediately. Both constructors initialize the <code>_regions</code> dictionary so that it's ready to be used either way.</p>
<h3 id="textureatlas-methods">TextureAtlas Methods</h3>
<p>Finally, The <code>TextureAtlas</code> class will provide methods for managing texture regions and creating atlases from configuration files. Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new region and adds it to this texture atlas.
/// &lt;/summary&gt;
/// &lt;param name=&quot;name&quot;&gt;The name to give the texture region.&lt;/param&gt;
/// &lt;param name=&quot;x&quot;&gt;The top-left x-coordinate position of the region boundary relative to the top-left corner of the source texture boundary.&lt;/param&gt;
/// &lt;param name=&quot;y&quot;&gt;The top-left y-coordinate position of the region boundary relative to the top-left corner of the source texture boundary.&lt;/param&gt;
/// &lt;param name=&quot;width&quot;&gt;The width, in pixels, of the region.&lt;/param&gt;
/// &lt;param name=&quot;height&quot;&gt;The height, in pixels, of the region.&lt;/param&gt;
public void AddRegion(string name, int x, int y, int width, int height)
{
    TextureRegion region = new TextureRegion(Texture, x, y, width, height);
    _regions.Add(name, region);
}

/// &lt;summary&gt;
/// Gets the region from this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the region to retrieve.&lt;/param&gt;
/// &lt;returns&gt;The TextureRegion with the specified name.&lt;/returns&gt;
public TextureRegion GetRegion(string name)
{
    return _regions[name];
}

/// &lt;summary&gt;
/// Removes the region from this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;name&quot;&gt;The name of the region to remove.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public bool RemoveRegion(string name)
{
    return _regions.Remove(name);
}

/// &lt;summary&gt;
/// Removes all regions from this texture atlas.
/// &lt;/summary&gt;
public void Clear()
{
    _regions.Clear();
}

/// &lt;summary&gt;
/// Creates a new texture atlas based a texture atlas xml configuration file.
/// &lt;/summary&gt;
/// &lt;param name=&quot;content&quot;&gt;The content manager used to load the texture for the atlas.&lt;/param&gt;
/// &lt;param name=&quot;fileName&quot;&gt;The path to the xml file, relative to the content root directory.&lt;/param&gt;
/// &lt;returns&gt;The texture atlas created by this method.&lt;/returns&gt;
public static TextureAtlas FromFile(ContentManager content, string fileName)
{
    TextureAtlas atlas = new TextureAtlas();

    string filePath = Path.Combine(content.RootDirectory, fileName);

    using (Stream stream = TitleContainer.OpenStream(filePath))
    {
        using (XmlReader reader = XmlReader.Create(stream))
        {
            XDocument doc = XDocument.Load(reader);
            XElement root = doc.Root;

            // The &lt;Texture&gt; element contains the content path for the Texture2D to load.
            // So we'll retrieve that value then use the content manager to load the texture.
            string texturePath = root.Element(&quot;Texture&quot;).Value;
            atlas.Texture = content.Load&lt;Texture2D&gt;(texturePath);

            // The &lt;Regions&gt; element contains individual &lt;Region&gt; elements, each one describing
            // a different texture region within the atlas.  
            //
            // Example:
            // &lt;Regions&gt;
            //      &lt;Region name=&quot;spriteOne&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;32&quot; height=&quot;32&quot; /&gt;
            //      &lt;Region name=&quot;spriteTwo&quot; x=&quot;32&quot; y=&quot;0&quot; width=&quot;32&quot; height=&quot;32&quot; /&gt;
            // &lt;/Regions&gt;
            //
            // So we retrieve all of the &lt;Region&gt; elements then loop through each one
            // and generate a new TextureRegion instance from it and add it to this atlas.
            var regions = root.Element(&quot;Regions&quot;)?.Elements(&quot;Region&quot;);

            if (regions != null)
            {
                foreach (var region in regions)
                {
                    string name = region.Attribute(&quot;name&quot;)?.Value;
                    int x = int.Parse(region.Attribute(&quot;x&quot;)?.Value ?? &quot;0&quot;);
                    int y = int.Parse(region.Attribute(&quot;y&quot;)?.Value ?? &quot;0&quot;);
                    int width = int.Parse(region.Attribute(&quot;width&quot;)?.Value ?? &quot;0&quot;);
                    int height = int.Parse(region.Attribute(&quot;height&quot;)?.Value ?? &quot;0&quot;);

                    if (!string.IsNullOrEmpty(name))
                    {
                        atlas.AddRegion(name, x, y, width, height);
                    }
                }
            }

            return atlas;
        }
    }
}
</code></pre>
<p>These methods serve different purposes in managing the texture atlas:</p>
<ol>
<li>Region Management
<ul>
<li><code>AddRegion</code>: Creates a new <code>TextureRegion</code> at the specified location in the atlas.</li>
<li><code>GetRegion</code>: Retrieves a previously added region by its name.</li>
<li><code>RemoveRegion</code>: Removes a specific region by its name.</li>
<li><code>Clear</code>: Removes all regions from the atlas.</li>
</ul>
</li>
<li>Atlas Creation
<ul>
<li><code>FromFile</code>: creates a new <code>TextureAtlas</code> from an XML configuration file. This method will load the source texture then create and add the regions based on the XML configuration.  We'll look more into using the XML configuration in a moment.</li>
</ul>
</li>
</ol>
<h2 id="using-the-textureatlas-class">Using the TextureAtlas Class</h2>
<p>Let's put our new <code>TextureAtlas</code> class to use by exploring two approaches; creating an atlas manually and using XML configuration.  So far, we've been practicing using textures with the MonoGame logo. Now we will use a new texture atlas that contains various sprites we'll need for our game.</p>
<p>Download the texture atlas by right-clicking the following image and saving it as atlas.png:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/atlas.png" alt="Figure 8-2: The texture atlas for our game"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 8-2: The texture atlas for our game</strong></td>
</tr>
</tbody>
</table>
<p>Add this texture atlas to your content project using the MGCB Editor:</p>
<ol>
<li>Open the <em>Content.mgcb</em> file in the MGCB Editor</li>
<li>In the editor, right-click the <em>images</em> directory and choose <em>Add &gt; Existing item...</em>.</li>
<li>Navigate to and choose the <em>atlas.png</em> file you downloaded to add it.</li>
<li>Save the changes and close the MGCB Editor.</li>
</ol>
<div class="TIP">
<h5>Tip</h5>
<p>If you need a refresher on adding content using the MGCB Editor, you can revisit the <a href="../06_content_pipeline/index.html#adding-assets-in-the-mgcb-editor">Adding Assets in the MGCB Editor</a> section of Chapter 04.</p>
</div>
<p>First, we'll explore creating the texture atlas and defining the texture regions directly in code.  Replace the contents of <em>Game1.cs</em> with the following:</p>
<pre><code class="lang-csharp" highlight-lines="13-17,37-53,71-75">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary.Graphics;

namespace DungeonSlime;

public class Game1 : Game
{
    private GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch;

    // texture region that defines the slime sprite in the atlas.
    private TextureRegion _slime;

    // texture region that defines the bat sprite in the atlas.
    private TextureRegion _bat;

    public Game1()
    {
        _graphics = new GraphicsDeviceManager(this);
        Content.RootDirectory = &quot;Content&quot;;
        IsMouseVisible = true;
    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);

        // Load the atlas texture using the content manager
        Texture2D atlasTexture = Content.Load&lt;Texture2D&gt;(&quot;images/atlas&quot;);

        //  Create a TextureAtlas instance from the atlas
        TextureAtlas atlas = new TextureAtlas(atlasTexture);

        // add the slime region to the atlas.
        atlas.AddRegion(&quot;slime&quot;, 0, 160, 40, 40);

        // add the bat region to the atlas.
        atlas.AddRegion(&quot;bat&quot;, 80, 160, 40, 40);

        // retrieve the slime region from the atlas.
        _slime = atlas.GetRegion(&quot;slime&quot;);

        // retrieve the bat region from the atlas.
        _bat = atlas.GetRegion(&quot;bat&quot;);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        _spriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime texture region.
        _slime.Draw(_spriteBatch, Vector2.One, Color.White);

        // Draw the bat texture region 10px to the right of the slime.
        _bat.Draw(_spriteBatch, new Vector2(_slime.Width + 10, 0), Color.White);

        // Always end the sprite batch when finished.
        _spriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes in this implementation are:</p>
<ol>
<li>The <code>_logo</code> field was removed.</li>
<li>The <code>FramesPerSecondCounter</code> component that was added in the constructor was removed.</li>
<li>Added  <code>TextureRegion</code> members for the slime and bat sprites.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>:
<ul>
<li>Removed loading the logo texture.</li>
<li>Created a <code>TextureAtlas</code> with the atlas texture.</li>
<li>Added regions for both the slime and the bat.</li>
<li>Retrieved the regions using their names.</li>
</ul>
</li>
<li>Updated <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> to render both sprites, using the slime's <code>Width</code> property to position the bat.</li>
</ol>
<p>Running the game now shows both sprites in the upper-left corner:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/slime-and-bat-rendered.png" alt="Figure 8-3: The slime and bat texture regions being rendered in the upper-left corner of the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 8-3: The slime and bat texture regions being rendered in the upper-left corner of the game window</strong></td>
</tr>
</tbody>
</table>
<p>While manual creation works for a few sprites, managing many regions becomes cumbersome. Let's now explore the <code>TextureAtlas.FromFile</code> method to load our atlas configuration from XML instead. Perform the following:</p>
<ol>
<li><p>Create a new file named <em>atlas-definition.xml</em> in the <em>Content/images</em> directory.</p>
</li>
<li><p>Add the following content to that file:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextureAtlas&gt;
    &lt;Texture&gt;images/atlas&lt;/Texture&gt;
    &lt;Regions&gt;
        &lt;Region name=&quot;slime&quot; x=&quot;0&quot; y=&quot;160&quot; width=&quot;40&quot; height=&quot;40&quot; /&gt;
        &lt;Region name=&quot;bat&quot; x=&quot;80&quot; y=&quot;160&quot; width=&quot;40&quot; height=&quot;40&quot; /&gt;
    &lt;/Regions&gt;
&lt;/TextureAtlas&gt;
</code></pre></li>
<li><p>Open the <em>Content.mgcb</em> file in the MGCB Editor</p>
</li>
<li><p>In the editor, right-click the <em>images</em> directory and choose <em>Add . Existing item...</em>.</p>
</li>
<li><p>Navigate to and choose the <em>atlas-definition.xml</em> file you just created to add it.</p>
</li>
<li><p>In the properties panel at the bottom for the <em>atlas-definition.xml</em> file, change the <em>Build Action</em> property from <em>Build</em> to <em>Copy</em>.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/mgcb-editor-copy.png" alt="Figure 8-4: The atlas-definition.xml file added to the content project with the Build Action property set to Copy"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 8-4: The atlas-definition.xml file added to the content project with the Build Action property set to Copy</strong></td>
</tr>
</tbody>
</table>
</li>
<li><p>Save the changes and close the MGCB Editor</p>
<div class="TIP">
<h5>Tip</h5>
<p>Using the content pipeline to copy files ensures they're placed in the correct location alongside other game content. While there are other methods (like editing the .csproj), this approach keeps asset management centralized</p>
</div>
</li>
<li><p>Replace the contents of <em>Game1.cs</em> with the following code:</p>
<pre><code class="lang-csharp" highlight-lines="37-38">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary.Graphics;

namespace DungeonSlime;

public class Game1 : Game
{
    private GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch;

    // texture region that defines the slime sprite in the atlas.
    private TextureRegion _slime;

    // texture region that defines the bat sprite in the atlas.
    private TextureRegion _bat;

    public Game1()
    {
        _graphics = new GraphicsDeviceManager(this);
        Content.RootDirectory = &quot;Content&quot;;
        IsMouseVisible = true;
    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);

        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // retrieve the slime region from the atlas.
        _slime = atlas.GetRegion(&quot;slime&quot;);

        // retrieve the bat region from the atlas.
        _bat = atlas.GetRegion(&quot;bat&quot;);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        _spriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime texture region.
        _slime.Draw(_spriteBatch, Vector2.One, Color.White);

        // Draw the bat texture region 10px to the right of the slime.
        _bat.Draw(_spriteBatch, new Vector2(_slime.Width + 10, 0), Color.White);

        // Always end the sprite batch when finished.
        _spriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre></li>
</ol>
<p>The key improvements here is in <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>, where we now:</p>
<ul>
<li>Create an atlas from the XML configuration file.</li>
<li>Let the <code>TextureAtlas.FromFile</code> method handle texture loading and region creation.</li>
</ul>
<p>This configuration based approached is advantageous because we can now add new and modify existing regions within the atlas without having to change code and/or recompile.  This also keeps the sprite definitions separate from the game logic.</p>
<p>Running the game now will show the same results as Figure 8-3 above, with the slime and bat texture regions rendered in the upper-left corner of the game window.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Let's review what you accomplished in this chapter:</p>
<ul>
<li>Learned about texture swapping and its impact on performance</li>
<li>Explored texture atlases as a solution for optimizing texture rendering</li>
<li>Learned what a class library is and the benefits of using one.</li>
<li>Created reusable <code>TextureRegion</code> and <code>TextureAtlas</code> classes to optimize and simplify texture management.</li>
<li>Learned how to include assets in the content pipeline that should only be copied and not processed.</li>
</ul>
<p>In the next chapter, we'll build on the concepts of the <code>TextureAtlas</code> and explore creating the <code>Sprite</code> and <code>AnimatedSprite</code> classes to further simplify managing and rendering sprites.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is a texture swap and why can it impact performance?</p>
<div class="question-answer"><p>A texture swap occurs when the GPU needs to unbind one texture and bind another between draw calls. While individual swaps may seem trivial, they can significantly impact performance in games with many sprites as each swap is an expensive GPU operation.</p>
</div>
</li>
<li><p>Name a benefit of using a texture atlas.</p>
<div class="question-answer"><p>Any of the following are benefits of using a texture atlas:</p>
<ul>
<li>Eliminates texture swaps by using a single texture</li>
<li>Reduces memory usage</li>
<li>Simplifies asset management</li>
<li>Improves rendering performance</li>
</ul>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
