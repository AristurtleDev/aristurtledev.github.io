<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-05-content-pipeline">Chapter 05: Content Pipeline</h1>
<p class="text-secondary">Learn the advantages of using the Content Pipeline to load assets and go through the processes of loading your first asset</p>
<p>Every game has assets; images to represent the visual graphics to players, audio to provide sound effects and background music, fonts to render text with, and much more.  These assets start out as raw files (e.g. <em>.png</em> image files or <em>.mp3</em> audio files), which you will need to load into the game to use.</p>
<h2 id="loading-assets">Loading Assets</h2>
<p>Loading assets can be done during runtime directly from file, or it can be loaded through the <strong>Content Pipeline</strong>  Both of these methods are two sides of the same coin and there are trade offs to each approach.</p>
<p>For instance, to load an image file directly at runtime, you would need to:</p>
<ol>
<li>Add the image file to your project.</li>
<li>Configure the project to copy the image file on build to the build output folder.</li>
<li>Load the image file as a texture at runtime using the <a href="xref:Microsoft.Xna.Framework.Graphics.Texture2D.FromFile(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.String)"><strong>Texture2D.FromFile</strong></a> method.</li>
</ol>
<div class="IMPORTANT">
<h5>Important</h5>
<p>A big disadvantage to loading an image file as a texture directly, is when that when it loads it, it does so in its compressed format such as <em>.png</em> or <em>.jpg</em>.  These compression formats are not understood by a Graphics Processing Unit (GPU); they will need to be decompressed into raw bytes as a format the GPU does understand before it can store the data.  Doing this can potentially leave a larger memory footprint for your assets.  You will also need to handle how different compression formats work on the platform you are targeting such as desktops, mobile, and consoles.</p>
</div>
<p>On the other side of this coin, MonoGame offers the <strong>Content Pipeline</strong>; a workflow for managing assets. The workflow is made up of a set of tools and utilities that are automatically added by default when you create a new MonoGame project using the MonoGame project templates.  To use this workflow, you need to:</p>
<ol>
<li>Add the asset file to your content project (<em>Content.mgcb</em> file) using the <em>MonoGame Content Builder Editor</em> (MGCB Editor).</li>
<li>Perform a project build. Doing this, the <em>MonoGame.Content.Builder.Tasks</em> NuGet reference will compile the assets defined in the content project, optimized for the target platform, and automatically copy them to the game project build folder.</li>
<li>Load the compiled asset at runtime using the <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a>.</li>
</ol>
<p>For the same amount of steps, you also get the benefit of the assets being pre-processed and compiled to an optimized format for the target platform.  For instance, image files can be compiled using <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">DXT compression</a>, which is a format that is understood by GPUs without needing to be decompressed first, reducing the memory footprint.</p>
<div class="NOTE">
<h5>Note</h5>
<p>For more information on the benefits of compiling assets and what optimizations it can offer, see the <a href="../../../getting_started/content_pipeline/index.md">Content Pipeline</a> documentation.</p>
</div>
<p>For this tutorial series, we are going to focus on using the content pipeline workflow to load assets.  Doing this will get you as the developer accustomed to using the content pipeline tools and also give the benefits of having assets precompiled to optimized formats.</p>
<h2 id="the-mgcb-editor">The MGCB Editor</h2>
<p>As mentioned previously, the content pipeline workflow in MonoGame is made up of a set of tools that come with every new MonoGame project.  At the center of this workflow is the MGCB Editor; a graphical tool for managing your game's content.</p>
<p>Opening the MGCB Editor can be done in different ways depending on which IDE and development environment you have.  Choose the one you are using below to open the MGCB Editor so we can explore its interface:</p>
<div class="tabGroup" id="tabgroup_1">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_1_vscode" role="tab" aria-controls="tabpanel_1_vscode" data-tab="vscode" tabindex="0" aria-selected="true">Visual Studio Code</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_vs2022" role="tab" aria-controls="tabpanel_1_vs2022" data-tab="vs2022" tabindex="-1">Visual Studio 2022</a>
</li>
<li role="presentation">
<a href="#tabpanel_1_dotnetcli" role="tab" aria-controls="tabpanel_1_dotnetcli" data-tab="dotnetcli" tabindex="-1">dotnet CLI</a>
</li>
</ul>
<section id="tabpanel_1_vscode" role="tabpanel" data-tab="vscode">

<p>To open the <em>Content.mgcb</em> content project file in the MGCB Editor with Visual Studio Code, you can use the <em>MonoGame for VSCode</em> extension.  You should have installed this extension in <a href="../02_getting_started/index.html#installing-the-monogame-for-vscode-extension">Chapter 02</a>.  With this extension install, anytime you have a code file open, you will see the MonoGame logo in the top-right of the code window like below:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/mgcb-editor-icon.png" alt="Figure 5-1: MonoGame for VSCode extension icon"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-1: MonoGame for VSCode extension icon</strong></td>
</tr>
</tbody>
</table>
<p>Clicking the MonoGame logo here will open the <em>Content.mgcb</em> content project file from the current project in the MGCB Editor.</p>
</section>
<section id="tabpanel_1_vs2022" role="tabpanel" data-tab="vs2022" aria-hidden="true" hidden="hidden">

<p>To open the <em>Content.mgcb</em> content project file in the MGCB Editor with Visual Studio 2022, you can use the <em>MonoGame Framework C# project templates</em> extension.  Despite the name, this extension does more than just install the MonoGame project templates.  With this extension installed, simply double-click the <em>Content.mgcb</em> content project file in the Solution Explorer panel and it will open it in the MGCB Editor.</p>
</section>
<section id="tabpanel_1_dotnetcli" role="tabpanel" data-tab="dotnetcli" aria-hidden="true" hidden="hidden">

<p>To open the <em>Content.mgcb</em> content project file in the MGCB Editor using the dotnet CLI commands, perform the following:</p>
<ol>
<li><p>Open a new Command Prompt or Terminal window in the same folder as the <em>DungeonSlime.csproj</em> project file (your main game project).</p>
</li>
<li><p>Enter the following dotnet CLI command</p>
<pre><code class="lang-sh">dotnet mgcb-editor ./Content/Content.mgcb`
</code></pre>
</li>
</ol>
</section>
</div>

<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/mgcb-editor.png" alt="Figure 5-2: MonoGame Content Builder Editor (MGCB Editor) Window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-2: MonoGame Content Builder Editor (MGCB Editor) Window</strong></td>
</tr>
</tbody>
</table>
<p>In Figure 5-2 above, you can see the user interface for the MGCB Editor:</p>
<ul>
<li><strong>Toolbar</strong>: Contains icon buttons for common actions such as creating new items, opening files, saving changes, and building content.</li>
<li><strong>Project Panel</strong>: Located on the left of the MGCB Editor, displays a hierarchial tree view of all content items added to the content project.  The root node <em>Content</em> represents the root of the content project.</li>
<li><strong>Properties Panel</strong>: Located on the bottom left of the MGCB Editor, shows the properties of the currently selected item in the project panel.  The properties available are based on the item type selected.</li>
<li><strong>Build Output Panel</strong>: The large area to the right side outputs build messages, warnings, and errors when content is processed.</li>
</ul>
<h3 id="creating-folders-to-organize-content">Creating Folders to Organize Content</h3>
<p>Organizing your game assets into folders helps keep your content project manageable as it grows. For now, we will add a new folder that will hold the image assets we will add to the game throughout this tutorial series.  In the MGCB Editor:</p>
<ol>
<li>In the Project Panel, select the root <em>Content</em> node.</li>
<li>Right-click it and choose <em>Add</em> &gt; <em>New Folder...</em> from the context menu.</li>
<li>Type &quot;images&quot; for the folder name and click the &quot;Ok&quot; button.</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/new-folder-popup.png" alt="Figure 5-3: New folder pop-up"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-3: New folder pop-up</strong></td>
</tr>
</tbody>
</table>
<p>You hae now created a folder that will help organize the game's image assets.  As we continue through this tutorial series, we will be adding additional folders for organization of content such as audio, fonts, and effects.</p>
<h3 id="adding-your-first-asset">Adding Your First Asset</h3>
<p>Now that we have a folder structure, we can add our first image asset to the project.  For this example, we will use the MonoGame logo.  Perform the following</p>
<ol>
<li><p>First, download the MonoGame logo by right-clicking the following image and saving it as <code>logo.png</code> somewhere on your computer:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo.png" alt="Figure 5-4: MonoGame Horizontal Logo"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-4: MonoGame Horizontal Logo</strong></td>
</tr>
</tbody>
</table>
</li>
<li><p>In the MGCB Editor, select the <em>images</em> folder you created earlier.</p>
</li>
<li><p>Right-click it and choose <em>Add</em> &gt; <em>Existing Item...</em> from the context menu.</p>
</li>
<li><p>Navigate to the location of the <code>logo.png</code> file you just downloaded and select it.</p>
</li>
<li><p>Click the &quot;Open&quot; button</p>
</li>
<li><p>When prompted in the add existing file popup, choose <em>Copy the file to the directory.</em></p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/add-file-popup.png" alt="Figure 5-5: Add existing file pop-up"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-5: Add existing file pop-up</strong></td>
</tr>
</tbody>
</table>
</li>
<li><p>Save the changes to the content project by selecting <em>File</em> &gt; <em>Save</em> from the top menu or pressing <code>CTRL+S</code>.</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/mgcb-logo-added.png" alt="Figure 5-6: The logo image added to the content project in the MGCB Editor"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-6: The logo image added to the content project in the MGCB Editor</strong></td>
</tr>
</tbody>
</table>
<div class="IMPORTANT">
<h5>Important</h5>
<p>After changes have been made in the MGCB Editor, ensure that you save the changes.  They are not automatically saved, though you will be warned if you close the editor and have not saved changes. You can tell that changes have not been saved by looking at the title bar of the MGCB editor window.  If it has an '*' at the end of the window title, this means changes have not been saved.</p>
</div>
<h2 id="understanding-the-content-pipeline-workflow">Understanding the Content Pipeline Workflow</h2>
<p>Now that we have added our first asset, we can take a moment to understand what happens to this asset in the Content Pipeline workflow:</p>
<ol>
<li>You create source files for your game assets such as images, audio, fonts, effects, and 3D models.</li>
<li>Using the MGCB Editor, add these assets your content project (the <code>Content.mgcb</code> file).</li>
<li>When you perform a build of your project, the <code>MonoGame.Content.Builder.Task</code> NuGet reference will:
<ol>
<li>Compile the assets defined in the content project using the <strong>MonoGame Content Builder (MGCB)</strong> tool into <code>.xnb</code> files.</li>
<li>Copy the compiled <code>.xnb</code> files from the content project's build folder to your game project's build folder.</li>
</ol>
</li>
<li>At runtime, you load the compiled assets using the <a href="xref:Microsoft.Xna.Framework.Content.ContentManager">ContentManager</a>.</li>
</ol>
<p>The following diagram demonstrates this workflow:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/content-pipeline-workflow-full.png" alt="Figure 5-7: MonoGame Content Pipeline Workflow diagram showing the process flow from source files (Images, Audio, Fonts, Effects, Models) through the MGCB Editor to generate the Content.mgcb file, which is then processed by MonoGame.Content.Builder.Tasks to create compiled .xnb assets (Xnb formats for each type), which are finally loaded by the ContentManager at runtime"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-7: MonoGame Content Pipeline Workflow diagram showing the process flow from source files (Images, Audio, Fonts, Effects, Models) through the MGCB Editor to generate the Content.mgcb file, which is then processed by MonoGame.Content.Builder.Tasks to create compiled .xnb assets (Xnb formats for each type), which are finally loaded by the ContentManager at runtime</strong></td>
</tr>
</tbody>
</table>
<p>The Content Pipeline offers significant advantages:</p>
<ul>
<li>Assets are pre-processed and optimized for your target platform.</li>
<li>Image files can be compiled using formats like DXT compression, which GPU's understand natively.</li>
<li>Asset loading is simplified and consistent across platforms.</li>
</ul>
<h2 id="the-contentmanager-class">The ContentManager Class</h2>
<p>To load assets in your game code, MonoGame provides the <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> class. The <a href="xref:Microsoft.Xna.Framework.Game"><strong>Game</strong></a> already has a <a href="xref:Microsoft.Xna.Framework.Game.Content"><strong>Content</strong></a> property which is a ready-to-ue instance of the <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a></p>
<h3 id="contentmanager-methods">ContentManager Methods</h3>
<p>They key methods for asset loading are:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Content.ContentManager.Load%60%601(System.String)"><strong>Load&lt;T&gt;(string)</strong></a></td>
<td><code>T</code></td>
<td>Loads the assets of type <code>T</code> that has been processed by the content pipeline.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Content.ContentManager.Unload"><strong>Unload</strong></a></td>
<td><code>void</code></td>
<td>Unloads all assets that have been loaded by that content manager instance.</td>
</tr>
</tbody>
</table>
<div class="TIP">
<h5>Tip</h5>
<p>When an asset is loaded for the first time, the <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> internally caches it.  Loading the same asset again will return the cached version, avoiding extra disk reads.</p>
</div>
<h2 id="understanding-content-paths">Understanding Content Paths</h2>
<p>When loading content, you need to specify the path to the asset, minus the extension.  This path is relative to the ContentManager's <a href="xref:Microsoft.Xna.Framework.Content.ContentManager.RootDirectory"><strong>RootDirectory</strong></a> property, which is set to &quot;Content&quot; by default in the <code>Game1</code> constructor.</p>
<p>For example, with our newly dded logo in the &quot;images&quot; folder,the path would be &quot;images/logo&quot; (without the file extension).  The reason for this relates to the build process.  When you build your project, the <em>MonoGame.Content.Builder.Tasks</em> NuGet reference <a href="#understanding-the-content-pipeline-workflow">compiles your assets and copies them to the game's output folder</a>.</p>
<p>This creates a folder structure in your output directory similar to:</p>
<pre><code class="lang-sh">DungeonSlime/
    └── bin/
        └── Debug/
            └── net8.0/
                ├── DungeonSlime.exe
                └── Content/
                    └── images/
                        └── logo.xnb
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Notice that the compile asset has an .xnb extension, but when loading the asset in code, you refer to it without any extension.</p>
</div>
<h2 id="loading-and-displaying-your-first-asset">Loading and Displaying Your First Asset</h2>
<p>Now that we have the MonoGame logo added as an asset in the content project, we can modify the game to display the logo.  In the <em>DungeonSlime</em> project open the <code>Game1.cs</code> file and perform the following:</p>
<ol>
<li><p>Add a field to store the logo texture by inserting this line after the class declaration:</p>
<pre><code class="lang-cs">// The MonoGame logo texture
private Texture2D _logo;
</code></pre>
</li>
<li><p>In the <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> method, add this line to load the logo texture:</p>
<pre><code class="lang-cs">_logo = Content.Load&lt;Texture2D&gt;(&quot;images/logo&quot;);
</code></pre>
</li>
<li><p>Finally, in the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> method, add these lines before the <code>base.Draw(gameTime);</code> call:</p>
<pre><code class="lang-cs">// Begin the sprite batch to prepare for rendering.
SpriteBatch.Begin();

// Draw the logo texture
SpriteBatch.Draw(_logo, Vector2.Zero, Color.White);

// Always end the sprite batch when finished.
SpriteBatch.End();
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>We will go more into detail about the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> in the next chapter.</p>
</div>
</li>
</ol>
<p>The complete updated <code>Game1.cs</code> file should now look like this</p>
<pre><code class="lang-csharp" highlight-lines="10-11,27,44-51">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;

namespace DungeonSlime;

public class Game1 : Core
{
    // The MonoGame logo texture
    private Texture2D _logo;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        _logo = Content.Load&lt;Texture2D&gt;(&quot;images/logo&quot;);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // TODO: Add your update logic here

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin();

        // Draw the logo texture
        SpriteBatch.Draw(_logo, Vector2.Zero, Color.White);

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>Running the game now will show the MonoGame logo displayed in the upper-left corner of the game window.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-drawn.png" alt="Figure 5-8: The MonoGame logo drawn to the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-8: The MonoGame logo drawn to the game window</strong></td>
</tr>
</tbody>
</table>
<h2 id="adding-build-in-asset-types">Adding Build-In Asset Types</h2>
<p>The MGCB Editor can also create certain built-in asset types.  In this section we will explore these types and this functionality.  If not already open, <a href="#opening-the-mgcb-editor">open the MGCB Editor</a> and perform the following:</p>
<ol>
<li><p>Select the <em>Content</em> node.</p>
</li>
<li><p>Right-click it and choose <em>Add</em> &gt; <em>New Item...</em> from the context menu.</p>
</li>
<li><p>In the dialog that appears, you will see the available built-in types.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/new-file-popup.png" alt="Figure 5-9: New file pop-up"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-9: New file pop-up</strong></td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>The available built-in types include:</p>
<ul>
<li><strong>Effect (.fx)</strong>: A shader file that creates custom visual effects by controlling how graphics are rendered on the GPU.</li>
<li><strong>SpriteFont Description (.spritefont)</strong>: A configuration file that defines how text will be displayed in your game, including character set and font properties.</li>
<li><strong>Sprite Effect (.fx)</strong>: A shader specifically designed for use with 2D sprites to create special visual effects.</li>
<li><strong>Xml Content (.xml)</strong>: A structured data file for storing game information like levels, dialogues, or configuration settings.</li>
<li><strong>LocalizedSpriteFont Description (.spritefont)</strong>: A configuration file for creating fonts with support for multiple languages.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Each built-in asset type comes with a template that includes the minimum required structure and settings.</p>
</div>
<p>For now, click the &quot;Cancel&quot; button on the new file dialog.  We will explore these built-in types further in later chapters when we need them.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>You learned about the advantages of loading assets using the <strong>Content Pipeline</strong>.</li>
<li>You opened the MGCB Editor and explored its interface.</li>
<li>You created a folder structure to organize your game assets.</li>
<li>You added an image file asset to the content project.</li>
<li>You understood the Content Pipeline workflow and how MonoGame automates the process.</li>
<li>You loaded and displayed your first asset using the <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a>.</li>
</ul>
<p>In the next chapter, we will explore working with textures in more detail and learning about different rendering options.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What are the two main ways of loading a texture, and what are the pros and cons of each approach?</p>
<div class="question-answer"><p>The two main ways to load a texture in MonoGame are:</p>
<ol>
<li><p>Directly from file using <a href="xref:Microsoft.Xna.Framework.Graphics.Texture2D.FromFile(Microsoft.Xna.Framework.Graphics.GraphicsDevice,System.String)"><strong>Texture2D.FromFile</strong></a>.   This method requires manually setting up file copying, offers no pre-processing benefits, and can have a higher memory footprint.</p>
</li>
<li><p>Using the content pipeline with <a href="xref:Microsoft.Xna.Framework.Content.ContentManager.Load%60%601(System.String)"><strong>Content.Load<texture2d></texture2d></strong></a>.  Using the content pipeline optimizes textures into formats for the target platform(s), automatically handles compiling and copying assets during build, and reduces memory footprint, but requires additional setup using the MGCB Editor.</p>
</li>
</ol>
</div>
</li>
<li><p>During the MonoGame content pipeline workflow, assets are compiled and then copied to the project output folder.  What is responsible for performing this task?</p>
<div class="question-answer"><p>The <em>MonoGame.Content.Builder.Tasks</em> NuGet reference.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
