<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-06-working-with-textures">Chapter 06: Working with Textures</h1>
<p class="text-secondary">Learn how to load and render textures using the MonoGame content pipeline and SpriteBatch.</p>
<p>Textures are images that are used in your game to represent the visual graphics to the player, commonly referred to as <em>Sprites</em>.  In <a href="../05_content_pipeline/index.html#loading-assets">Chapter 05</a>, you went through the steps of using the <strong>Content Pipeline</strong> to load the MonoGame <em>logo.png</em> texture and rendering it to the screen.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Learn how to render a texture with the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>.</li>
<li>Explorer how to manipulate the way the texture is rendered using the parameters of the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)"><strong>SpriteBatch.Draw</strong></a> method.</li>
</ul>
<h2 id="drawing-a-texture">Drawing a Texture</h2>
<p>When rendering in MonoGame, <em>render states</em>, properties of the <a href="xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice"><strong>GraphicsDevice</strong></a> that affect how rendering is performed, need to be set.  When rendering 2D sprites, the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> class simplifies rendering by managing these render states for you.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Although the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> makes it easier to manage the render states for the <a href="xref:Microsoft.Xna.Framework.Graphics.GraphicsDevice"><strong>GraphicsDevice</strong></a>, it can also change states that you may have set manually, such as when you are performing 3D rendering.  Keep this in mind when mixing 2D and 3D rendering.</p>
</div>
<p>Three methods are are used when rendering with the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>:</p>
<ol>
<li><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a> prepares the Graphics Device for rendering, including the render states.</li>
<li><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Color)"><strong>SpriteBatch.Draw</strong></a> tells the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> what to render. This is usually called multiple times before <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> and batches the draw calls for efficiency.</li>
<li><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> submits the draw calls that were batched to the graphics device to be rendered.</li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>The order of method calls when rendering using the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a> is important.  <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a> must be called before any <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Color)"><strong>SpriteBatch.Draw</strong></a> calls are made.  When finished, <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> must be called before another <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a> can be called.  If these methods are called out of order, an exception will be thrown.</p>
</div>
<p>As mentioned in <a href="../03_the_game1_file/index.html#the-game-loop">Chapter 03</a>, all rendering should be done inside the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> method. The <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> method's responsibility is to render the game state that was calculated in <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>; it should not contain any game logic or complex calculations.</p>
<p>At the end of <a href="../05_content_pipeline/index.html#loading-assets">Chapter 05</a>, you added the following code to <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> in the <em>Game1.cs</em> file:</p>
<pre><code class="lang-csharp">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(_logo, Vector2.Zero, Color.White);

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>These lines initialize the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>, draw the logo at <a href="xref:Microsoft.Xna.Framework.Vector2.Zero"><strong>Vector2.Zero</strong></a> (0, 0), and complete the batch. When you ran the game and the logo appeared in the window's upper-left corner:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-drawn.png" alt="Figure 6-1: The MonoGame logo drawn to the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-1: The MonoGame logo drawn to the game window</strong></td>
</tr>
</tbody>
</table>
<p>The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)"><strong>SpriteBatch.Draw</strong></a> method we just used can be given the following parameters:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>texture</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Graphics.Texture2D"><strong>Texture2D</strong></a></td>
<td>The <a href="xref:Microsoft.Xna.Framework.Graphics.Texture2D"><strong>Texture2D</strong></a> to draw.</td>
</tr>
<tr>
<td><em>position</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>The X and Y coordinates at which the texture will be rendered, with the texture's origin being the upper-left corner of the image.</td>
</tr>
<tr>
<td><em>color</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Color"><strong>Color</strong></a></td>
<td>The color mask (tint) to apply to the image drawn. Specifying <a href="xref:Microsoft.Xna.Framework.Color.White"><strong>Color.White</strong></a> will render the texture with no tint.</td>
</tr>
</tbody>
</table>
<p>Try adjusting the position and color parameters and see how they can affect the image being drawn.</p>
<p>MonoGame uses a coordinate system where (0, 0) is at the screen's upper-left corner. X values increase moving right, and Y values increase moving down. Understanding this, let's try to center the logo on the game window.</p>
<p>To center content on the screen, we need to find the window's center point. We can access this using the <a href="xref:Microsoft.Xna.Framework.GameWindow.ClientBounds"><strong>Window.ClientBounds</strong></a> property from the <a href="xref:Microsoft.Xna.Framework.Game"><strong>Game</strong></a> class, which represents the rectangular bounds of the game window.  <a href="xref:Microsoft.Xna.Framework.GameWindow.ClientBounds"><strong>Window.ClientBounds</strong></a> exposes both  <a href="xref:Microsoft.Xna.Framework.Rectangle.Width"><strong>Width</strong></a> and <a href="xref:Microsoft.Xna.Framework.Rectangle.Height"><strong>Height</strong></a> properties for the window's dimensions in pixels.  By dividing these dimensions in half, we can can calculate the window's center coordinates.  Let's update our <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Color)"><strong>Draw</strong></a> method to use this:</p>
<pre><code class="lang-csharp" highlight-lines="9-16">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,          // texture
        new Vector2(    // position
            Window.ClientBounds.Width, 
            Window.ClientBounds.Height) * 0.5f,
        Color.White     // color
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>In the example above, we multiply the <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a> created by <code>0.5f</code> to halve the value instead of dividing it by <code>2.0f</code>. If you are not used to seeing this, it might seem strange at first, but it is actually an optimization technique. CPUs are able to perform multiplication operations much faster than division operations and reading <code>* 0.5f</code> is easily understood to be the same thing as <code>/ 2.0f</code> when reading.</p>
</div>
<p>We have now set the position to half the window's dimensions, which should center the logo. Let's run the game to see the result.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-off-center.png" alt="Figure 6-2: Attempting to draw the MonoGame logo centered on the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-2: Attempting to draw the MonoGame logo centered on the game window</strong></td>
</tr>
</tbody>
</table>
<p>The logo is not centered as we expected it to be.  Even though we set the <em>position</em> parameter to the center of the game window, the texture starts drawing from its <em>origin</em>, which is the upper-left corner in this example.  So when we set the position to the screen's center, we are actually placing the logo's upper-left corner at that point, not its center.</p>
<p>One way to correct this is to subtract half the width and height of the texture from the game window's center position like so:</p>
<pre><code class="lang-csharp" highlight-lines="12-14">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,          // texture
        new Vector2(    // position
            (Window.ClientBounds.Width * 0.5f) - (_logo.Width * 0.5f),
            (Window.ClientBounds.Height * 0.5f) - (_logo.Height * 0.5f)),
        Color.White     // color
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>This offsets the position so that it correctly centers the image to the game window.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-centered.png" alt="Figure 6-3: The MonoGame logo drawn centered on the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-3: The MonoGame logo drawn centered on the game window</strong></td>
</tr>
</tbody>
</table>
<p>While this works, there is a better approach.  There is a different overload of the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)"><strong>SpriteBatch.Draw</strong></a> method that provides additional parameters for complete control over the draw operation. Update your code to:</p>
<pre><code class="lang-csharp" highlight-lines="10-22">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
            (Window.ClientBounds.Width * 0.5f) - (_logo.Width * 0.5f),
            (Window.ClientBounds.Height * 0.5f) - (_logo.Height * 0.5f)),
        null,               // sourceRectangle
        Color.White,        // color
        0.0f,               // rotation
        Vector2.Zero,       // origin
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f                // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>This overload produces the same centered result but exposes all parameters that control rendering for a draw operation.  Unlike engines that abstract much of these details away, MonoGame provides explicit control for a flexible custom rendering pipeline.  Here is what each parameter does:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>texture</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Graphics.Texture2D"><strong>Texture2D</strong></a></td>
<td>The <a href="xref:Microsoft.Xna.Framework.Graphics.Texture2D"><strong>Texture2D</strong></a> to draw.</td>
</tr>
<tr>
<td><em>position</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>The X and Y coordinate position at which the texture will be rendered, relative to the <em>origin</em> parameter.</td>
</tr>
<tr>
<td><em>sourceRectangle</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a></td>
<td>An optional region within the texture to be rendered in order to draw only a portion of the texture. Specifying <code>null</code> will render the entire texture.</td>
</tr>
<tr>
<td><em>color</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Color"><strong>Color</strong></a></td>
<td>The color mask (tint) to apply to the image drawn. Specifying <a href="xref:Microsoft.Xna.Framework.Color.White"><strong>Color.White</strong></a> will render the texture with no tint.</td>
</tr>
<tr>
<td><em>rotation</em></td>
<td><code>float</code></td>
<td>The amount of rotation, in radians, to apply to the texture when rendering. Specifying <code>0.0f</code> will render the image with no rotation.</td>
</tr>
<tr>
<td><em>origin</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a></td>
<td>The X and Y coordinate origin point of the texture when rendering. This will affect the offset of the texture when rendered as well being the origin in which the texture is rotated around and scaled from.</td>
</tr>
<tr>
<td><em>scale</em></td>
<td><code>float</code></td>
<td>The amount to scale the image across the x- and y-axes. Specifying <code>1.0f</code> will render the image at its default size with no scaling.</td>
</tr>
<tr>
<td><em>effects</em></td>
<td><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects"><strong>SpriteEffects</strong></a></td>
<td>A <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects"><strong>SpriteEffects</strong></a> enum value to that specifies if the texture should be rendered flipped across the horizontal axis, the vertical axis, or both axes.</td>
</tr>
<tr>
<td><em>layerDepth</em></td>
<td><code>float</code></td>
<td>Specifies the depth at which the texture is rendered. Textures with a higher layer depth value are drawn on top of those with a lower layer depth value. <strong>Note: This value will only apply when using <code>SpriteSortMode.FrontToBack</code> or <code>SpriteSortMode.BackToFront</code>. We'll cover this in a moment.</strong></td>
</tr>
</tbody>
</table>
<h3 id="rotation">Rotation</h3>
<p>First let's explore the <code>rotation</code> parameter.  This value is the amount of rotation to apply to the sprite when rendering it.  Let's rotate the texture 90° to make it vertical. Since rotation is measured in radians, not degrees, we can use the built-in math library in MonoGame to make the conversion for us by calling <a href="xref:Microsoft.Xna.Framework.MathHelper.ToRadians(System.Single)"><strong>MathHelper.ToRadians</strong></a>.  Update the code to:</p>
<pre><code class="lang-csharp" highlight-lines="17">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,                      // texture
        new Vector2(                // position
            (Window.ClientBounds.Width * 0.5f) - (_logo.Width * 0.5f),
            (Window.ClientBounds.Height * 0.5f) - (_logo.Height * 0.5f)),
        null,                       // sourceRectangle
        Color.White,                // color
        MathHelper.ToRadians(90),   // rotation
        Vector2.Zero,               // origin
        1.0f,                       // scale
        SpriteEffects.None,         // effects
        0.0f                        // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>Running the code now shows the rotated image, but not in the expected position:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-rotated-offcenter.png" alt="Figure 6-4: Attempting to draw the MonoGame logo rotated 90° and centered on the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-4: Attempting to draw the MonoGame logo rotated 90° and centered on the game window</strong></td>
</tr>
</tbody>
</table>
<p>The reason the sprite did not rotate as expected is because of the <code>origin</code> parameter.</p>
<h3 id="origin">Origin</h3>
<p>The <code>origin</code> parameter specifies the point of origin in which the sprite is rendered from, rotated from, and scaled from.  By default, if no origin is set, it will be <a href="xref:Microsoft.Xna.Framework.Vector2.Zero"><strong>Vector2.Zero</strong></a>, the upper-left corner of the sprite.  To visualize this, see Figure 6-5 below.  The red square represents where the origin is for the sprite, and we can see how it's rotated around this origin point.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/top-left-origin-rotation-example.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-5: Demonstration of how a sprite is rotated around its origin</strong></td>
</tr>
</tbody>
</table>
<p>To resolve the rotation issue we had, we need to need to change two things:</p>
<ol>
<li>Set the <code>origin</code> parameter to the center of the sprite instead of defaulting to the upper-left corner.</li>
<li>Change the <code>position</code> parameter back to the center of the screen.</li>
</ol>
<p>Update the code to:</p>
<pre><code class="lang-csharp" highlight-lines="12-14,18-20">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,                      // texture
        new Vector2(                // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        null,                       // sourceRectangle
        Color.White,                // color
        MathHelper.ToRadians(90),   // rotation
        new Vector2(                // origin
            _logo.Width,
            _logo.Height) * 0.5f,
        1.0f,                       // scale
        SpriteEffects.None,         // effects
        0.0f                        // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>By moving the sprite's origin point to its center, this not only corrects the point of rotation, but also allows us to use the screen center position directly without needing additional position offset calculations.  Running the game now shows the log properly centered and rotated 90°.</p>
<div class="NOTE">
<h5>Note</h5>
<p>When setting the <code>origin</code> parameter, it is based on the sprites width and height, so the center origin will be half the width and half the height of the sprite.</p>
</div>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-rotated-centered.png" alt="Figure 6-6: The MonoGame logo drawn rotated 90° and centered on the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-6: The MonoGame logo drawn rotated 90° and centered on the game window</strong></td>
</tr>
</tbody>
</table>
<h3 id="scale">Scale</h3>
<p>The <code>scale</code> parameter specifies the amount of scaling to apply to the sprite when it is rendered.  The default value is <code>1.0f</code>, which can be read as &quot;rendering the sprite at 1x the size&quot;.  Increasing this will scale up the size of the sprite and decreasing it will scale down the sprite.</p>
<p>For this example, let's first reset the rotation back to <code>0.0f</code> (removing the 90° rotation we applied above) so we can clearly see the scaling effect.  Then we will set the scale of the logo sprite to <code>1.5f</code></p>
<pre><code class="lang-csharp" highlight-lines="17,21">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
       _logo,              // texture
       new Vector2(        // position
           Window.ClientBounds.Width,
           Window.ClientBounds.Height) * 0.5f,
       null,               // sourceRectangle
       Color.White,        // color
       0.0f,               // rotation
       new Vector2(        // origin
           _logo.Width,
           _logo.Height) * 0.5f,
       1.5f,               // scale
       SpriteEffects.None, // effects
       0.0f                // layerDepth          
   );

   // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-scaled-1.5x.png" alt="Figure 6-7: The MonoGame logo drawn scaled at 1.5x the size"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-7: The MonoGame logo drawn scaled at 1.5x the size</strong></td>
</tr>
</tbody>
</table>
<p>Note that the sprite scaled up from the center.  This is because we still have the <code>origin</code> parameter set as the center of the sprite.  If we instead adjusted the code so the <code>origin</code> parameter was back in the upper-left corner like so:</p>
<pre><code class="lang-csharp" highlight-lines="18-19">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        null,               // sourceRectangle
        Color.White,        // color
        0.0f,               // rotation
        Vector2.Zero,       // origin
        1.5f,               // scale
        SpriteEffects.None, // effects
        0.0f                //layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>Then the scaling is applied from the origin in the upper-left corner producing the following result:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-scaled-1.5x-zero-origin.png" alt="Figure 6-8: The MonoGame logo drawn scaled at 1.5x the size with the origin set in the upper-left corner"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-8: The MonoGame logo drawn scaled at 1.5x the size with the origin set in the upper-left corner</strong></td>
</tr>
</tbody>
</table>
<p>Scaling can also be applied to the x- and y-axes independently by providing it with a <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a> value instead of a float value.  For instance, let's scale the x-axis of the sprite by 1.5x and reduce the scale of the y-axis to 0.5x:</p>
<pre><code class="lang-csharp" highlight-lines="21">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,                      // texture
        new Vector2(                // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        null,                       // sourceRectangle
        Color.White,                // color
        0.0f,                       // rotation
        new Vector2(                // origin
            _logo.Width,
            _logo.Height) * 0.5f,
        new Vector2(1.5f, 0.5f),    // scale
        SpriteEffects.None,         // effects
        0.0f                        // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>Which will produce the following result:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-scaled-1.5x-0.5x.png" alt="Figure 6-9: The MonoGame logo drawn scaled at 1.5x the size on the x-axis and 0.5x on the y-axis"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-9: The MonoGame logo drawn scaled at 1.5x the size on the x-axis and 0.5x on the y-axis</strong></td>
</tr>
</tbody>
</table>
<h3 id="spriteeffects">SpriteEffects</h3>
<p>The <code>effects</code> parameter is used to flip the sprite when rendered on either the horizontal or vertical axis, or both. This value for this parameter will be one of the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects"><strong>SpriteEffects</strong></a> enum values.</p>
<table>
<thead>
<tr>
<th>SpriteEffect</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects.None"><strong>SpriteEffects.None</strong></a></td>
<td>No effect is applied and the sprite is rendered normally.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects.FlipHorizontally"><strong>SpriteEffects.FlipHorizontally</strong></a></td>
<td>The sprite is rendered flipped along the horizontal axis.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects.FlipVertically"><strong>SpriteEffects.FlipVertically</strong></a></td>
<td>The sprite is rendered flipped along the vertical axis.</td>
</tr>
</tbody>
</table>
<p>For this example, let's reset the scale back to <code>1.0f</code> and apply the  <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects.FlipHorizontally"><strong>SpriteEffects.FlipHorizontally</strong></a> value to the sprite:</p>
<pre><code class="lang-csharp" highlight-lines="21,22">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,                          // texture
        new Vector2(                    // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        null,                           // sourceRectangle
        Color.White,                    // color
        0.0f,                           // rotation
        new Vector2(                    // origin
            _logo.Width,
            _logo.Height) * 0.5f,
        1.0f,                           // scale
        SpriteEffects.FlipHorizontally, // effects
        0.0f                            // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>Which will produce the following result:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-flipped-horizontally.png" alt="Figure 6-10: The MonoGame logo flipped horizontally"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-10: The MonoGame logo flipped horizontally</strong></td>
</tr>
</tbody>
</table>
<p>The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects"><strong>SpriteEffects</strong></a> enum value also uses the <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-flagsattribute"><code>[Flag]</code></a> attribute, which means we can combine both horizontal and vertical flipping together.  To do this, we use the <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#logical-or-operator-">bitwise OR operator</a> <code>|</code>.  Update the <code>effect</code> parameter value to the following:</p>
<pre><code class="lang-csharp" highlight-lines="22-23">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,                              // texture
        new Vector2(                        // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        null,                               // sourceRectangle
        Color.White,                        // color
        0.0f,                               // rotation
        new Vector2(                        // origin
            _logo.Width,
            _logo.Height) * 0.5f,
        1.0f,                               // scale
        SpriteEffects.FlipHorizontally |    // effects
        SpriteEffects.FlipVertically,
        0.0f                                // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>Now the sprite is flipped both horizontally and vertically</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-flipped-horizontally-and-vertically.png" alt="Figure 6-11: The MonoGame logo flipped horizontally and vertically"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-11: The MonoGame logo flipped horizontally and vertically</strong></td>
</tr>
</tbody>
</table>
<h3 id="color-and-opacity">Color and Opacity</h3>
<p>The <code>color</code> parameter applies a color mask to the sprite when it's rendered.  Note that this is not setting the actual color of the image, just a mask that is applied, like a tint.  The default value is <a href="xref:Microsoft.Xna.Framework.Color.White"><strong>Color.White</strong></a>.  So if we're setting it to <a href="xref:Microsoft.Xna.Framework.Color.White"><strong>Color.White</strong></a>, why does this not affect the tinting of the sprite drawn?</p>
<p>When the <code>color</code> parameter is applied, each color channel (Red, Green, Blue) of the sprite is multiplied by the corresponding channel in the <code>color</code> parameter, where each channel is represented as a value between <code>0.0f</code> and <code>1.0f</code>.  For <a href="xref:Microsoft.Xna.Framework.Color.White"><strong>Color.White</strong></a>, all color channels are set to <code>1.0f</code> (255 in byte form), so the multiplication looks like this:</p>
<pre><code class="lang-sh">Final Red = Sprite Red * 1.0f
Final Green = Sprite Green * 1.0f
Final Blue = Sprite Blue * 1.0f;
</code></pre>
<p>Since multiplying by <code>1.0f</code> doesn't change the value, <a href="xref:Microsoft.Xna.Framework.Color.White"><strong>Color.White</strong></a> essentially preserves the original colors of the sprite.</p>
<p>For this example, let's reset the <code>effects</code>  parameter back to <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects.None"><strong>SpriteEffects.None</strong></a> and update the <code>color</code> parameter to use <a href="xref:Microsoft.Xna.Framework.Color.Green"><strong>Color.Green</strong></a>:</p>
<pre><code class="lang-csharp" highlight-lines="16,22">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        null,               // sourceRectangle
        Color.Green,        // color
        0.0f,               // rotation
        new Vector2(        // origin
            _logo.Width,
            _logo.Height) * 0.5f,
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>This produces the following result:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-green-tint.png" alt="Figure 6-12: The MonoGame logo with a green color tint applied"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-12: The MonoGame logo with a green color tint applied</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>The icon and the word &quot;GAME&quot; in the logo look black after using a <a href="xref:Microsoft.Xna.Framework.Color.Green"><strong>Color.Green</strong></a> because the Red, Blue Green components of that color are (<code>0.0f</code>, <code>0.5f</code>, <code>0.0f</code>).  The Orange color used in the logo is <a href="xref:Microsoft.Xna.Framework.Color.MonoGameOrange"><strong>Color.MonoGameOrange</strong></a>, which has the component values of (<code>0.9f</code>, <code>0.23f</code>, <code>0.0f</code>).  When multiplying the component values, the result is (<code>0.0f</code>, <code>0.125f</code>, <code>0.0f</code>) which would be Red 0, Green 31, Blue 0 in byte values.  So it's not quite fully black, but it is very close.</p>
<p>This is why it's important to understand how the <code>color</code> parameter values are applied to the sprite when it is rendered.</p>
</div>
<p>To adjust the opacity of a sprite, we can multiply the <code>color</code> parameter value by a value between <code>0.0f</code> (fully transparent) and <code>1.0f</code> (fully opaque).  For instance, if we wanted to render the logo with 50% transparency we can multiply the <code>color</code> parameter by <code>0.5f</code> like this:</p>
<pre><code class="lang-csharp" highlight-lines="16">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw the texture
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        null,               // sourceRectangle
        Color.White * 0.5f, // color
        0.0f,               // rotation
        new Vector2(        // origin
            _logo.Width,
            _logo.Height) * 0.5f,
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>Which will produce the following result:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-half-transparency.png" alt="Figure 6-13: The MonoGame logo with half transparency"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-13: The MonoGame logo with half transparency</strong></td>
</tr>
</tbody>
</table>
<h3 id="source-rectangle">Source Rectangle</h3>
<p>The <code>sourceRectangle</code> parameter specifies a specific boundary within the texture that should be rendered.  So far, we've just set this parameter to <code>null</code>, which specifies that the full texture should be rendered.  If we only wanted to render a portion of the texture as the sprite, we can set this parameter value.</p>
<p>For instance, take the logo image we've been using.  We can break it down into two distinct regions; the MonoGame icon and the MonoGame wordmark.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/logo-texture-regions.png" alt="Figure 6-14: The MonoGame logo broken down into the icon and wordmark regions"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-14: The MonoGame logo broken down into the icon and wordmark regions</strong></td>
</tr>
</tbody>
</table>
<p>We can see from Figure 6-14 above that the actual icon starts at position (0, 0) and is 128px wide and 128px tall. Likewise, the wordmark starts at position (150, 34) and is 458px wide and 58px tall. Knowing the starting position and the width and height of the region gives us a defined rectangle that we can use as the <code>sourceRectangle</code>.</p>
<p>Let's see this in action by drawing the icon and the wordmark separately from the same texture. Update the code to the following:</p>
<pre><code class="lang-csharp" highlight-lines="6-7,9-10,15-30,32-47">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // The bounds of the icon within the texture.
    Rectangle iconSourceRect = new Rectangle(0, 0, 128, 128);

    // The bounds of the word mark within the texture.
    Rectangle wordmarkSourceRect = new Rectangle(150, 34, 458, 58);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw only the icon portion of the texture.
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        iconSourceRect,     // sourceRectangle
        Color.White,        // color
        0.0f,               // rotation
        new Vector2(        // origin
            iconSourceRect.Width,
            iconSourceRect.Height) * 0.5f,
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f                // layerDepth
    );

    // Draw only the word mark portion of the texture.
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
          Window.ClientBounds.Width,
          Window.ClientBounds.Height) * 0.5f,
        wordmarkSourceRect, // sourceRectangle
        Color.White,        // color
        0.0f,               // rotation
        new Vector2(        // origin
          wordmarkSourceRect.Width,
          wordmarkSourceRect.Height) * 0.5f,
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f                // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>The following changes were made:</p>
<ul>
<li>Two new <a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a> values called <code>iconSourceRect</code> and <code>wordmarkSourceRect</code> that represent the boundaries of the MonoGame icon and wordmark regions within the logo texture were added.</li>
<li>The <em>sourceRectangle</em> parameter of the <code>_spriteBatch.Draw</code> was updated to use the new <code>iconSourceRect</code> value. <strong>Notice that we are still telling it to draw the <code>_logo</code> for the <em>texture</em>, we've just supplied it with a source rectangle this time.</strong></li>
<li>The <em>origin</em> parameter was updated to use the width and height of the <code>iconSourceRect</code>. Since the overall dimensions of what we'll be rendering has changed due to supplying a source rectangle, the origin needs to be adjusted to those dimensions as well.</li>
<li>Finally, a second <code>_spriteBatch.Draw</code> call is made, this time using the <code>wordmarkSourceRect</code> as the source rectangle so that the wordmark is drawn.</li>
</ul>
<p>If you run the game now, you should see the following:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/icon-wordmark-centered.png" alt="Figure 6-15: The MonoGame icon and wordmark, from the logo texture, centered in the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 6-15: The MonoGame icon and wordmark, from the logo texture, centered in the game window</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>Making use of the <code>sourceRectangle</code> parameter to draw different sprites from the same texture is optimization technique that we'll explore further in the next chapter.</p>
</div>
<h3 id="layer-depth">Layer Depth</h3>
<p>The final parameter to discuss is the <code>layerDepth</code> parameter. Notice that in Figure 6-15 above, the word mark is rendered on top of the icon.  This is because of the order the draw calls were made; first the icon was rendered, then the word mark was rendered.</p>
<p>The <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a> method contains several optional parameters, one of which is the <code>sortMode</code> parameter.  By default, this value is <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.Deferred"><strong>SpriteSortMode.Deferred</strong></a>, which means what is drawn is done so in the order of the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.DrawString(Microsoft.Xna.Framework.Graphics.SpriteFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> calls.  Each subsequent call will be drawn visually on top of the previous call.</p>
<p>When <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.Deferred"><strong>SpriteSortMode.Deferred</strong></a> is used, then the <code>layerDepth</code> parameter in the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.DrawString(Microsoft.Xna.Framework.Graphics.SpriteFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> call is essentially ignored.  For instance, in the first <code>_spriteBatch.Draw</code> method call, update the <code>layerDepth</code> parameter to <code>1.0f</code>.</p>
<pre><code class="lang-csharp" highlight-lines="29">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // The bounds of the icon within the texture.
    Rectangle iconSourceRect = new Rectangle(0, 0, 128, 128);

    // The bounds of the word mark within the texture.
    Rectangle wordmarkSourceRect = new Rectangle(150, 34, 458, 58);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin();

    // Draw only the icon portion of the texture.
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        iconSourceRect,     // sourceRectangle
        Color.White,        // color
        0.0f,               // rotation
        new Vector2(        // origin
            iconSourceRect.Width,
            iconSourceRect.Height) * 0.5f,
        1.0f,               // scale
        SpriteEffects.None, // effects
        1.0f                // layerDepth
    );

    // Draw only the word mark portion of the texture.
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
          Window.ClientBounds.Width,
          Window.ClientBounds.Height) * 0.5f,
        wordmarkSourceRect, // sourceRectangle
        Color.White,        // color
        0.0f,               // rotation
        new Vector2(        // origin
          wordmarkSourceRect.Width,
          wordmarkSourceRect.Height) * 0.5f,
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f                // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>Doing this should tell it to render on a layer above the wordmark since the icon is at <code>1.0f</code> and the wordmark is at <code>0.0f</code> for the <code>layerDepth</code>.  However, if you run the game now, you'll see that no change actually happens; the wordmark is still drawn on top of the icon.</p>
<p>To make use of the <code>layerDepth</code> parameter, you need to set the <code>sortMode</code> to either <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.BackToFront"><strong>SpriteSortMode.BackToFront</strong></a> or <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.FrontToBack"><strong>SpriteSortMode.FrontToBack</strong></a>.</p>
<table>
<thead>
<tr>
<th>Sort Mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.BackToFront"><strong>SpriteSortMode.BackToFront</strong></a></td>
<td>Sprites are sorted by depth in back-to-front order prior to drawing.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.FrontToBack"><strong>SpriteSortMode.FrontToBack</strong></a></td>
<td>Sprites are sorted by depth in front-to-back order prior to drawing.</td>
</tr>
</tbody>
</table>
<p>Let's see this in action.  We've already set the <code>layerDepth</code> parameter of the icon to <code>1.0f</code>.  Find the <code>_spriteBatch.Begin()</code> method call and update it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="13">protected override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // The bounds of the icon within the texture.
    Rectangle iconSourceRect = new Rectangle(0, 0, 128, 128);

    // The bounds of the word mark within the texture.
    Rectangle wordmarkSourceRect = new Rectangle(150, 34, 458, 58);

    // Begin the sprite batch to prepare for rendering.
    SpriteBatch.Begin(sortMode: SpriteSortMode.FrontToBack);

    // Draw only the icon portion of the texture.
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
            Window.ClientBounds.Width,
            Window.ClientBounds.Height) * 0.5f,
        iconSourceRect,     // sourceRectangle
        Color.White,        // color
        0.0f,               // rotation
        new Vector2(        // origin
            iconSourceRect.Width,
            iconSourceRect.Height) * 0.5f,
        1.0f,               // scale
        SpriteEffects.None, // effects
        1.0f                // layerDepth
    );

    // Draw only the word mark portion of the texture.
    SpriteBatch.Draw(
        _logo,              // texture
        new Vector2(        // position
          Window.ClientBounds.Width,
          Window.ClientBounds.Height) * 0.5f,
        wordmarkSourceRect, // sourceRectangle
        Color.White,        // color
        0.0f,               // rotation
        new Vector2(        // origin
          wordmarkSourceRect.Width,
          wordmarkSourceRect.Height) * 0.5f,
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f                // layerDepth
    );

    // Always end the sprite batch when finished.
    SpriteBatch.End();

    base.Draw(gameTime);
}
</code></pre>
<p>Now we're telling it to use the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.FrontToBack"><strong>SpriteSortMode.FrontToBack</strong></a> sort mode, which will sort the draw calls so that those with a higher <code>layerDepth</code> will be drawn on top of those with a lower one.  Even though we didn't change the order of the <code>_spriteBatch.Draw</code> calls, if you run the game now, you will see the following:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/icon-on-top-of-wordmark.png" alt="Figure 5-17: The MonoGame icon drawn on top of the wordmark"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 5-17: The MonoGame icon drawn on top of the wordmark</strong></td>
</tr>
</tbody>
</table>
<p>There are also two additional <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode"><strong>SpriteSortMode</strong></a> values that can be used.  These, however, are situational and can have draw backs when using them, so understanding what they are for is important.</p>
<p>The first is <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.Texture"><strong>SpriteSortMode.Texture</strong></a>.  This works similar to <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.Deferred"><strong>SpriteSortMode.Deferred</strong></a> in that draw calls happen in the order they are made.  However, before the draw calls are made, they are sorted by texture.  This can be helpful when using multiple textures to reduce texture swapping, however it can have unintended results with layering if you're not careful.</p>
<p>The second is <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.Immediate"><strong>SpriteSortMode.Immediate</strong></a>.  When using this sort mode, when a draw call is made, it is immediately flushed to the GPU and rendered to the screen, ignoring the layer depth, instead of batched and drawn when <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> is called. Using this can cause performance issues and should only be used when necessary.  We'll discuss an example of using this in a later chapter when we discuss shaders, since with <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode.Immediate"><strong>SpriteSortMode.Immediate</strong></a> you can adjust shader parameters for each individual draw call.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Let's review what you accomplished in this chapter:</p>
<ul>
<li>You learned about the different parameters of the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)"><strong>SpriteBatch.Draw</strong></a> method and how they affect sprite rendering.</li>
<li>You learned how the <code>rotation</code> parameter works and how to convert between degrees and radians using <a href="xref:Microsoft.Xna.Framework.MathHelper.ToRadians(System.Single)"><strong>MathHelper.ToRadians</strong></a>.</li>
<li>You learned how the <code>origin</code> parameter affects sprite positioning, rotation, and scaling.</li>
<li>You learned how to use the <code>scale</code> parameter to resize sprites uniformly or along individual axes.</li>
<li>You explored the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteEffects"><strong>SpriteEffects</strong></a> enum to flip sprites horizontally and vertically.</li>
<li>You learned how the <code>color</code> parameter can be used to tint sprites and adjust their opacity.</li>
<li>You used the <code>sourceRectangle</code> parameter to draw specific regions from a texture.</li>
<li>You explored sprite layering using the <code>layerDepth</code> parameter and different <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode"><strong>SpriteSortMode</strong></a> options.</li>
</ul>
<p>In the next chapter, we'll take what we've learned about working with textures and learn techniques to optimize rendering to reduce texture swapping.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is the purpose of the <code>origin</code> parameter in SpriteBatch.Draw, and how does it affect position, rotation and scaling?</p>
<div class="question-answer"><p>The <code>origin</code> parameter determines the reference point for the sprite's position, rotation, and scaling. When set to <a href="xref:Microsoft.Xna.Framework.Vector2.Zero"><strong>Vector2.Zero</strong></a>, the sprite rotates and scales from its upper-left corner. When set to the center of the sprite, the sprite rotates and scales from its center. The origin point also affects where the sprite is positioned relative to the <code>position</code> parameter.</p>
</div>
</li>
<li><p>How can you adjust a sprite's opacity using <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.DrawString(Microsoft.Xna.Framework.Graphics.SpriteFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a>?</p>
<div class="question-answer"><p>A sprite's opacity can be adjusted by multiplying the <code>color</code> parameter by a value between <code>0.0f</code> (fully transparent) and <code>1.0f</code> (fully opaque). For example, <code>Color.White * 0.5f</code> will render the sprite at 50% opacity.</p>
</div>
</li>
<li><p>How can you flip a sprite horizontally and vertically at the same time using SpriteEffects?</p>
<div class="question-answer"><p>To flip a sprite both horizontally and vertically, you can combine the SpriteEffects values using the bitwise OR operator (<code>|</code>):</p>
<pre><code class="lang-cs">SpriteEffects.FlipHorizontally | SpriteEffects.FlipVertically
</code></pre>
</div>
</li>
<li><p>When using the <code>sourceRectangle</code> parameter, what information do you need to specify, and what is its purpose?</p>
<div class="question-answer"><p>The <code>sourceRectangle</code> parameter requires a <a href="xref:Microsoft.Xna.Framework.Rectangle"><strong>Rectangle</strong></a> value where the x- and y-coordinates specify the upper-left corner of the region within the texture and the width and height, in pixels, of the region.</p>
<p>Its purpose is to specify a specific region within a texture to draw, allowing multiple sprites to be drawn from different parts of the same texture.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
