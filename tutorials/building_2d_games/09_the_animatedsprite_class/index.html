<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-09-the-animatedsprite-class">Chapter 09: The AnimatedSprite Class</h1>
<p class="text-secondary">Create an AnimatedSprite class that builds upon our Sprite class to support frame-based animations.</p>
<p>While packing images into a texture atlas and managing them through our <code>Sprite</code> class improves performance and organization, games need animation to bring their visuals to life. 2D animation in games works much like a flip book; a sequence of individual images (<em>frames</em>) displayed in rapid succession creates the illusion of movement. Each frame represents a specific point in the sprite's animation, and when these frames are cycled through quickly, our eyes perceive fluid motion.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The term &quot;frame&quot; in animation refers to a single image in an animation sequence. This is different from a game frame, which represents one complete render cycle of your game.</p>
</div>
<p>In MonoGame, we can create these animations by cycling through different regions of our texture atlas, with each region representing a single frame of the animation. For example, Figure 9-1 below shows three frames that make up a bat's wing-flapping animation:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/bat-animation-example.gif" alt="Figure 9-1: Animation example of a bat flapping its wings"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 9-1: Animation example of a bat flapping its wings</strong></td>
</tr>
</tbody>
</table>
<p>By drawing each frame sequentially over time, we create the illusion that the bat is flapping its wings. The speed at which we switch between frames determines how smooth or rapid the animation appears.</p>
<p>In this chapter, we will build off of the <code>Sprite</code> class we created in <a href="../08_the_sprite_class/index.html">Chapter 08</a> to create an <code>AnimatedSprite</code> class we can use to bring animations to life.</p>
<h2 id="the-animation-class">The Animation Class</h2>
<p>Before we can create animated sprites, we need a way to manage animation data. We will create an <code>Animation</code> class to encapsulate this information. In the <em>Graphics</em> folder within the <em>MonoGameLibrary</em> project, add a new file named <em>Animation.cs</em> with this initial structure:</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;

namespace MonoGameLibrary.Graphics;

public class Animation 
{

}
</code></pre><h3 id="animation-properties">Animation Properties</h3>
<p>An animation requires two key pieces of information: the sequence of frames to display and the timing between them. Add these properties to the <code>Animation</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// The texture regions that make up the frames of this animation.  The order of the regions within the collection
/// are the order that the frames should be displayed in.
/// &lt;/summary&gt;
public List&lt;TextureRegion&gt; Frames { get; set; }

/// &lt;summary&gt;
/// The amount of time to delay between each frame before moving to the next frame for this animation.
/// &lt;/summary&gt;
public TimeSpan Delay { get; set; }
</code></pre>
<p>The <code>Frames</code> property stores the collection of texture regions that make up the animation sequence. The order of regions in this collection is important; they will be displayed in the same sequence they are added, creating the animation's movement. For example, in our bat animation, the frames would be ordered to show the wings moving up, then fully extended, then down.</p>
<p>The <code>Delay</code> property defines how long each frame should be displayed before moving to the next one. This timing control allows us to adjust the speed of our animations; a shorter delay creates faster animations, while a longer delay creates slower ones.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Using <code>TimeSpan</code> for the delay allows us to specify precise timing intervals, making it easier to synchronize animations with game time. In other scenarios, you could opt to use <code>float</code> values instead.</p>
</div>
<h3 id="animation-constructors">Animation Constructors</h3>
<p>The <code>Animation</code> class will provide two ways to create an animation.  Add the following constructors:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new animation.
/// &lt;/summary&gt;
public Animation()
{
    Frames = new List&lt;TextureRegion&gt;();
    Delay = TimeSpan.FromMilliseconds(100);
}

/// &lt;summary&gt;
/// Creates a new animation with the specified frames and delay.
/// &lt;/summary&gt;
/// &lt;param name=&quot;frames&quot;&gt;An ordered collection of the frames for this animation.&lt;/param&gt;
/// &lt;param name=&quot;delay&quot;&gt;The amount of time to delay between each frame of this animation.&lt;/param&gt;
public Animation(List&lt;TextureRegion&gt; frames, TimeSpan delay)
{
    Frames = frames;
    Delay = delay;
}
</code></pre>
<p>The default constructor creates an animation with an empty collection of frames and a default delay of 100 milliseconds between each frame.  The parameterized constructor allows you to specify the frames of animation and the delay for the animation.</p>
<div class="TIP">
<h5>Tip</h5>
<p>The default 100 milliseconds delay provides a good starting point for most animations, roughly equivalent to 10 animation frame changes per second.</p>
</div>
<h2 id="creating-animations-with-the-textureatlas-class">Creating Animations With The TextureAtlas Class</h2>
<p>The <code>TextureAtlas</code> class we created in <a href="../07_optimizing_texture_rendering/index.html#the-textureatlas-class">Chapter 07</a> can do more than just manage texture regions and create sprites; it can also store and manage animation data to create animated sprites with.  The <em>atlas.png</em> image we are currently using contains the frames of animation for both a slime and a bat, as well as sprites for other things. We will first update our <em>atlas-definition.xml</em> file to include all regions in the atlas, as well as add new <code>&lt;Animation&gt;</code> elements to define the animations.  Open the <em>atlas-definition.xml</em> file and replace the contents with the following:</p>
<pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextureAtlas&gt;
    &lt;Texture&gt;images/atlas&lt;/Texture&gt;
    &lt;Regions&gt;
        &lt;Region name=&quot;slime-1&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;slime-2&quot; x=&quot;0&quot; y=&quot;20&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;bat-1&quot; x=&quot;20&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;bat-2&quot; x=&quot;20&quot; y=&quot;20&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
        &lt;Region name=&quot;bat-3&quot; x=&quot;40&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; /&gt;
    &lt;/Regions&gt;
    &lt;Animations&gt;
        &lt;Animation name=&quot;slime-animation&quot; delay=&quot;200&quot;&gt;
            &lt;Frame region=&quot;slime-1&quot; /&gt;
            &lt;Frame region=&quot;slime-2&quot; /&gt;
        &lt;/Animation&gt;
        &lt;Animation name=&quot;bat-animation&quot; delay=&quot;200&quot;&gt;
            &lt;Frame region=&quot;bat-1&quot; /&gt;
            &lt;Frame region=&quot;bat-2&quot; /&gt;
            &lt;Frame region=&quot;bat-1&quot; /&gt;
            &lt;Frame region=&quot;bat-3&quot; /&gt;
        &lt;/Animation&gt;
    &lt;/Animations&gt;
&lt;/TextureAtlas&gt;
</code></pre>
<p>The key changes here are:</p>
<ul>
<li>Regions have been added for all regions within the atlas.</li>
<li>The slime and bat regions have been renamed to reflect the frame number of the animation.</li>
<li>A new <code>&lt;Animations&gt;</code> element has been added that defines <code>&lt;Animation&gt;</code> elements.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>In the bat animation, we reuse frame &quot;bat-1&quot; in the sequence (bat-1, bat-2, bat-1, bat-3). This creates a smoother wing-flapping animation by returning to the neutral position between up and down wing positions.</p>
</div>
<p>Now that we have a fully configured XML configuration for the atlas, we need to update the <code>TextureAtlas</code> class to manage animation data.  Open the <em>TextureAtlas.cs</em> file and make the following changes:</p>
<ol>
<li><p>Add the following using statement so we can reference the <code>TimeSpan</code> struct:</p>
<pre><code class="lang-csharp" highlight-lines="1">using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
</code></pre></li>
<li><p>Add storage for animations</p>
<pre><code class="lang-csharp">// Stores animations added to this atlas.
private Dictionary&lt;string, Animation&gt; _animations;
</code></pre></li>
<li><p>Update the constructors so that the animations dictionary is initialized:</p>
<pre><code class="lang-csharp" highlight-lines="7,18">/// &lt;summary&gt;
/// Creates a new texture atlas.
/// &lt;/summary&gt;
public TextureAtlas()
{
    _regions = new Dictionary&lt;string, TextureRegion&gt;();
    _animations = new Dictionary&lt;string, Animation&gt;();
}

/// &lt;summary&gt;
/// Creates a new texture atlas instance using the given texture.
/// &lt;/summary&gt;
/// &lt;param name=&quot;texture&quot;&gt;The source texture represented by the texture atlas.&lt;/param&gt;
public TextureAtlas(Texture2D texture)
{
    Texture = texture;
    _regions = new Dictionary&lt;string, TextureRegion&gt;();
    _animations = new Dictionary&lt;string, Animation&gt;();
}
</code></pre></li>
<li><p>Add methods to manage animations, similar to those that we use to manage regions:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Adds the given animation to this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;animationName&quot;&gt;The name of the animation to add.&lt;/param&gt;
/// &lt;param name=&quot;animation&quot;&gt;The animation to add.&lt;/param&gt;
public void AddAnimation(string animationName, Animation animation)
{
    _animations.Add(animationName, animation);
}

/// &lt;summary&gt;
/// Gets the animation from this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;animationName&quot;&gt;The name of the animation to retrieve.&lt;/param&gt;
/// &lt;returns&gt;The animation with the specified name.&lt;/returns&gt;
public Animation GetAnimation(string animationName)
{
    return _animations[animationName];
}

/// &lt;summary&gt;
/// Removes the animation with the specified name from this texture atlas.
/// &lt;/summary&gt;
/// &lt;param name=&quot;animationName&quot;&gt;The name of the animation to remove.&lt;/param&gt;
/// &lt;returns&gt;true if the animation is removed successfully; otherwise, false.&lt;/returns&gt;
public bool RemoveAnimation(string animationName)
{
    return _animations.Remove(animationName);
}
</code></pre></li>
<li><p>Update the <code>FromFile</code> method to parse the new <code>&lt;Animation&gt;</code> animation definitions from the XML configuration file</p>
<pre><code class="lang-csharp" highlight-lines="55-95">/// &lt;summary&gt;
/// Creates a new texture atlas based a texture atlas xml configuration file.
/// &lt;/summary&gt;
/// &lt;param name=&quot;content&quot;&gt;The content manager used to load the texture for the atlas.&lt;/param&gt;
/// &lt;param name=&quot;fileName&quot;&gt;The path to the xml file, relative to the content root directory..&lt;/param&gt;
/// &lt;returns&gt;The texture atlas created by this method.&lt;/returns&gt;
public static TextureAtlas FromFile(ContentManager content, string fileName)
{
    TextureAtlas atlas = new TextureAtlas();

    string filePath = Path.Combine(content.RootDirectory, fileName);

    using (Stream stream = TitleContainer.OpenStream(filePath))
    {
        using (XmlReader reader = XmlReader.Create(stream))
        {
            XDocument doc = XDocument.Load(reader);
            XElement root = doc.Root;

            // The &lt;Texture&gt; element contains the content path for the Texture2D to load.
            // So we will retrieve that value then use the content manager to load the texture.
            string texturePath = root.Element(&quot;Texture&quot;).Value;
            atlas.Texture = content.Load&lt;Texture2D&gt;(texturePath);

            // The &lt;Regions&gt; element contains individual &lt;Region&gt; elements, each one describing
            // a different texture region within the atlas.  
            //
            // Example:
            // &lt;Regions&gt;
            //      &lt;Region name=&quot;spriteOne&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;32&quot; height=&quot;32&quot; /&gt;
            //      &lt;Region name=&quot;spriteTwo&quot; x=&quot;32&quot; y=&quot;0&quot; width=&quot;32&quot; height=&quot;32&quot; /&gt;
            // &lt;/Regions&gt;
            //
            // So we retrieve all of the &lt;Region&gt; elements then loop through each one
            // and generate a new TextureRegion instance from it and add it to this atlas.
            var regions = root.Element(&quot;Regions&quot;)?.Elements(&quot;Region&quot;);

            if (regions != null)
            {
                foreach (var region in regions)
                {
                    string name = region.Attribute(&quot;name&quot;)?.Value;
                    int x = int.Parse(region.Attribute(&quot;x&quot;)?.Value ?? &quot;0&quot;);
                    int y = int.Parse(region.Attribute(&quot;y&quot;)?.Value ?? &quot;0&quot;);
                    int width = int.Parse(region.Attribute(&quot;width&quot;)?.Value ?? &quot;0&quot;);
                    int height = int.Parse(region.Attribute(&quot;height&quot;)?.Value ?? &quot;0&quot;);

                    if (!string.IsNullOrEmpty(name))
                    {
                        atlas.AddRegion(name, x, y, width, height);
                    }
                }
            }

            // The &lt;Animations&gt; element contains individual &lt;Animation&gt; elements, each one describing
            // a different animation within the atlas.
            //
            // Example:
            // &lt;Animations&gt;
            //      &lt;Animation name=&quot;animation&quot; delay=&quot;100&quot;&gt;
            //          &lt;Frame region=&quot;spriteOne&quot; /&gt;
            //          &lt;Frame region=&quot;spriteTwo&quot; /&gt;
            //      &lt;/Animation&gt;
            // &lt;/Animations&gt;
            //
            // So we retrieve all of the &lt;Animation&gt; elements then loop through each one
            // and generate a new Animation instance from it and add it to this atlas.
            var animationElements = root.Element(&quot;Animations&quot;).Elements(&quot;Animation&quot;);

            if (animationElements != null)
            {
                foreach (var animationElement in animationElements)
                {
                    string name = animationElement.Attribute(&quot;name&quot;)?.Value;
                    float delayInMilliseconds = float.Parse(animationElement.Attribute(&quot;delay&quot;)?.Value ?? &quot;0&quot;);
                    TimeSpan delay = TimeSpan.FromMilliseconds(delayInMilliseconds);

                    List&lt;TextureRegion&gt; frames = new List&lt;TextureRegion&gt;();

                    var frameElements = animationElement.Elements(&quot;Frame&quot;);

                    if (frameElements != null)
                    {
                        foreach (var frameElement in frameElements)
                        {
                            string regionName = frameElement.Attribute(&quot;region&quot;).Value;
                            TextureRegion region = atlas.GetRegion(regionName);
                            frames.Add(region);
                        }
                    }

                    Animation animation = new Animation(frames, delay);
                    atlas.AddAnimation(name, animation);
                }
            }

            return atlas;
        }
    }
}
</code></pre></li>
</ol>
<p>The updated <code>FromFile</code> method now handles both region and animation definitions from the XML configuration. For animations, it:</p>
<ul>
<li>Reads the <code>&lt;Animations&gt;</code> section from the XML.</li>
<li>For each animation:
<ul>
<li>Gets the name and frame delay.</li>
<li>Collects the referenced texture regions.</li>
<li>Creates and stores a new <code>Animation</code> instance.</li>
</ul>
</li>
</ul>
<h2 id="the-animatedsprite-class">The AnimatedSprite Class</h2>
<p>With our <code>Animation</code> class handling animation data, and the <code>TextureAtlas</code> updated to store the animation data, we can now create a class that represents an animated sprites. Since an animated sprite is essentially a sprite that changes its texture region over time, we can build upon our existing <code>Sprite</code> class through inheritance.</p>
<div class="NOTE">
<h5>Note</h5>
<p>By inheriting from <code>Sprite</code>, our <code>AnimatedSprite</code> class automatically gets all the rendering properties (position, rotation, scale, etc.) while adding animation-specific functionality.</p>
</div>
<p>The key to this design is the <code>Sprite.Region</code> property. Our <code>Sprite</code> class already knows how to render whatever region is currently set, so our <code>AnimatedSprite</code> class just needs to update this region property to the correct animation frame at the right time.</p>
<p>Now we will create the initial structure for our <code>AnimatedSprite</code> class. In the <em>Graphics</em> folder within the <em>MonoGameLibrary</em> project, add a new file named <em>AnimatedSprite.cs</em>:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;

namespace MonoGameLibrary.Graphics;

public class AnimatedSprite : Sprite 
{

}
</code></pre><h3 id="animatedsprite-members">AnimatedSprite Members</h3>
<p>An animated sprite needs to track both its current animation state and timing information. Add the following members to the <code>AnimatedSprite</code> class:</p>
<pre><code class="lang-csharp">private int _currentFrame;
private TimeSpan _elapsed;
private Animation _animation;

/// &lt;summary&gt;
/// Gets or Sets the animation for this animated sprite.
/// &lt;/summary&gt;
public Animation Animation
{
    get =&gt; _animation;
    set
    {
        _animation = value;
        Region = _animation.Frames[0];
    }
}
</code></pre>
<p>The class uses three private fields to manage its animation state:</p>
<ul>
<li><code>_currentFrame</code>: Tracks which frame of the animation is currently being displayed.</li>
<li><code>_elapsed</code>: Keeps track of how much time has passed since the last frame change.</li>
<li><code>_animation</code>: Stores the current animation being played.</li>
</ul>
<p>The <code>Animation</code> property provides access to the current animation while ensuring the sprite always starts with the first frame when a new animation is set. When you assign a new animation, the property's setter automatically updates the sprite's region to display the first frame of that animation.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Starting with the first frame when setting a new animation ensures consistent behavior when switching between different animations.</p>
</div>
<h3 id="animatedsprite-constructors">AnimatedSprite Constructors</h3>
<p>The <code>AnimatedSprite</code> class will provide two ways to create an animated sprite.  Add the following constructors:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new animated sprite.
/// &lt;/summary&gt;
public AnimatedSprite() { }

/// &lt;summary&gt;
/// Creates a new animated sprite with the specified frames and delay.
/// &lt;/summary&gt;
/// &lt;param name=&quot;animation&quot;&gt;The animation for this animated sprite.&lt;/param&gt;
public AnimatedSprite(Animation animation)
{
    Animation = animation;
}
</code></pre>
<p>The default constructor creates an empty animated sprite that can be configured later. The parameterized constructor creates an animated sprite with a specified animation, which automatically sets the sprite's initial region to the first frame of that animation through the <code>Animation</code> property.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Both constructors inherit from the base <code>Sprite</code> class, so an <code>AnimatedSprite</code> will have all the same rendering properties (position, rotation, scale, etc.) as a regular sprite.</p>
</div>
<h3 id="animatedsprite-methods">AnimatedSprite Methods</h3>
<p>The <code>AnimatedSprite</code> class needs a way to update its animation state over time. This is handled by a single <code>Update</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates this animated sprite.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the game timing values provided by the framework.&lt;/param&gt;
public void Update(GameTime gameTime)
{
    _elapsed += gameTime.ElapsedGameTime;

    if (_elapsed &gt;= _animation.Delay)
    {
        _elapsed -= _animation.Delay;
        _currentFrame++;

        if (_currentFrame &gt;= _animation.Frames.Count)
        {
            _currentFrame = 0;
        }

        Region = _animation.Frames[_currentFrame];
    }
}
</code></pre>
<p>The <code>Update</code> method manages the animation timing and frame progression:</p>
<ol>
<li>Accumulates the time passed since the last update in <code>_elapsed</code>.</li>
<li>When enough time has passed (defined by the animation's delay):
<ul>
<li>Resets the elapsed time counter</li>
<li>Advances to the next frame</li>
<li>Loops back to the first frame if we have reached the end</li>
<li>Updates the sprite's region to display the current frame</li>
</ul>
</li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>Unlike the <code>Sprite</code> class which only needs a <code>Draw</code> method, the <code>AnimatedSprite</code> requires this additional <code>Update</code> method to handle frame changes over time. This follows MonoGame's update/draw pattern we first saw in <a href="../03_the_game1_file/index.html">Chapter 03</a></p>
</div>
<p>The <code>Draw</code> method inherited from the base <code>Sprite</code> class remains unchanged, as it will automatically use whatever frame is currently set as the sprite's region.</p>
<h2 id="creating-animatedsprites-with-the-textureatlas-class">Creating AnimatedSprites With The TextureAtlas Class</h2>
<p>Similar to the update we did to the <code>TextureAtlas</code> class in <a href="../08_the_sprite_class/index.html#create-sprites-with-the-textureatlas-class">Chapter 08</a>, creating an <code>AnimatedSprite</code> from the atlas would require</p>
<ol>
<li>Get the animation by name.</li>
<li>Store it in a variable.</li>
<li>Create a new animated sprite with that animation.</li>
</ol>
<p>We can simplify this process by adding an animated spirte creation method to the <code>TextureAtlas</code> class. Open <em>TextureAtlas.cs</em> and add the following method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new animated sprite using the animation from this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;animationName&quot;&gt;The name of the animation to use.&lt;/param&gt;
/// &lt;returns&gt;A new AnimatedSprite using the animation with the specified name.&lt;/returns&gt;
public AnimatedSprite CreateAnimatedSprite(string animationName)
{
    Animation animation = GetAnimation(animationName);
    return new AnimatedSprite(animation);
}
</code></pre><h2 id="using-the-animatedsprite-class">Using the AnimatedSprite Class</h2>
<p>We can now adjust our game now to use the <code>AnimatedSprite</code> class to see our sprites come to life. Replaces the contents of <em>Game1.cs</em> with the following:</p>
<pre><code class="lang-csharp" highlight-lines="11-15,34-40,48-52">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, Vector2.One);

        // Draw the bat sprite 10px to the right of the slime.
        _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0));

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>Here are the key changes in this implementation:</p>
<ul>
<li>The <code>_slime</code> and <code>_bat</code> members were changed from <code>Sprite</code>  to <code>AnimatedSprite</code>.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> the <code>_slime</code> and <code>_bat</code> sprites are now created using the new <code>TextureAtlas.CreateAnimatedSprite</code> method.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>, the animations are updated based on the game time using the <code>AnimatedSprite.Update</code> method.</li>
</ul>
<p>Running the game now shows both sprites animating automatically:</p>
<ul>
<li>The slime bounces between two frames</li>
<li>The bat's wings flap in a continuous cycle</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/slime-bat-animated.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 9-2: The slime and bat sprite animating</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Created an <code>Animation</code> class to manage frame sequences and timing.</li>
<li>Extended the <code>TextureAtlas</code> class to support animation definitions.</li>
<li>Built an <code>AnimatedSprite</code> class that inherits from <code>Sprite</code>.</li>
<li>Applied inheritance to add animation capabilities while maintaining existing sprite functionality.</li>
<li>Used XML configuration to define animations separately from code.</li>
</ul>
<p>Now that we can efficiently manage and render sprites and animations, in the next chapter we will start taking a look at user input.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>Why did we create a separate <code>Animation</code> class instead of putting animation properties directly in <code>AnimatedSprite</code>?</p>
<div class="question-answer"><p>Separating animation data into its own class allows multiple <code>AnimatedSprite</code> instances to share the same animation definition. This is more efficient than each sprite having its own copy of the frame sequence and timing information.</p>
</div>
</li>
<li><p>What is the benefit of using <code>TimeSpan</code> for animation delays instead of float values?</p>
<div class="question-answer"><p><code>TimeSpan</code> provides precise timing control and makes it easier to synchronize animations with game time. It also makes the delay values more explicit (milliseconds vs arbitrary numbers) and helps prevent timing errors.</p>
</div>
</li>
<li><p>Why does the <code>AnimatedSprite</code> class need an <code>Update</code> method while the base <code>Sprite</code> class does not?</p>
<div class="question-answer"><p>The <code>AnimatedSprite</code> needs to track elapsed time and change frames based on the animation's timing. This requires updating its state over time, while a regular sprite's appearance remains static until explicitly changed.</p>
</div>
</li>
<li><p>In the <code>TextureAtlas</code> XML configuration, why might you want to reuse a frame in an animation sequence, like we did with the bat animation?</p>
<div class="question-answer"><p>Reusing frames in an animation sequence can create smoother animations by providing transition states. In the bat animation, reusing the neutral position (bat-1) between wing movements creates a more natural flapping motion without requiring additional sprite frames.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
