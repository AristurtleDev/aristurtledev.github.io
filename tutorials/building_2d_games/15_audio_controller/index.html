<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-15-audio-controller">Chapter 15: Audio Controller</h1>
<p class="text-secondary">Learn how to create a reusable audio controller class to manage sound effects and music, including volume control, muting/unmuting, and proper resource cleanup.</p>
<p>While playing sounds and music using the simplified sound API is straightforward, a game needs to handle various audio states and resource cleanup including:</p>
<ul>
<li>Track and manage sound effect instances that are created.</li>
<li>Dispose of sound effect instances when they are finished.</li>
<li>Handle volume control for songs and sound effects.</li>
<li>Manage audio states (pause/resume, mute/unmute).</li>
</ul>
<p>In this chapter you will:</p>
<ul>
<li>Learn how to create a central audio management system.</li>
<li>Implement proper resource tracking and cleanup for sound effects.</li>
<li>Build methods to control audio state (play/pause, mute/unmute).</li>
<li>Add global volume control for different audio types.</li>
<li>Integrate the audio controller with your game's core systems.</li>
<li>Implement keyboard shortcuts for audio control.</li>
</ul>
<p>By the end of this chapter, you'll have an audio control system that can be easily reused in future game projects.</p>
<h2 id="the-audiocontroller-class">The AudioController Class</h2>
<p>To get started, in the <em>MonoGameLibrary</em> project:</p>
<ol>
<li><p>Create a new folder named <em>Audio</em>.</p>
</li>
<li><p>Add a new class file named <em>AudioController.cs</em> to the <em>Audio</em> folder you just created.</p>
</li>
<li><p>Add the following code as the initial structure for the class</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Media;

namespace MonoGameLibrary.Audio;

public class AudioController : IDisposable
{

}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>AudioController</code> class will implement the <code>IDisposable</code> interface,  This interface is part of .NET and provides a standardized implementation for an object to release resources.  Implementing <code>IDisposable</code> allows other code to properly clean up the resources held by our audio controller when it's no longer needed.  For more information on <code>IDisposable</code>, you can read the <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose">Implement a Dispose Method</a> article on Microsoft Learn.</p>
</div>
</li>
</ol>
<h3 id="audiocontroller-properties-and-fields">AudioController Properties and Fields</h3>
<p>The <code>AudioController</code> will need to track sound effect instances created for cleanup and track the state and volume levels of songs and sound effects when toggling between mute states.  Add the following fields and properties:</p>
<pre><code class="lang-csharp">    // Tracks sound effect instances created so they can be paused, unpaused, and/or disposed.
    private readonly List&lt;SoundEffectInstance&gt; _activeSoundEffectInstances;

    // Tracks the volume for song playback when muting and unmuting.
    private float _previousSongVolume;

    // Tracks the volume for sound effect playback when muting and unmuting.
    private float _previousSoundEffectVolume;
    
    /// &lt;summary&gt;
    /// Gets a value that indicates if audio is muted.
    /// &lt;/summary&gt;
    public bool IsMuted { get; private set; }

/// &lt;summary&gt;
    /// Gets or Sets the global volume of songs.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// If IsMuted is true, the getter will always return back 0.0f and the
    /// setter will ignore setting the volume.
    /// &lt;/remarks&gt;
    public float SongVolume
    {
        get
        {
            if(IsMuted)
            {
                return 0.0f;
            }

            return MediaPlayer.Volume;
        }
        set
        {
            if(IsMuted)
            {
                return;
            }

            MediaPlayer.Volume = Math.Clamp(value, 0.0f, 1.0f);
        }
    }

    /// &lt;summary&gt;
    /// Gets or Sets the global volume of sound effects.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// If IsMuted is true, the getter will always return back 0.0f and the
    /// setter will ignore setting the volume.
    /// &lt;/remarks&gt;
    public float SoundEffectVolume
    {
        get
        {
            if(IsMuted)
            {
                return 0.0f;
            }

            return SoundEffect.MasterVolume;
        }
        set
        {
            if(IsMuted)
            {
                return;
            }

            SoundEffect.MasterVolume = Math.Clamp(value, 0.0f, 1.0f);
        }
    }    

    /// &lt;summary&gt;
    /// Gets a value that indicates if this audio controller has been disposed.
    /// &lt;/summary&gt;
    public bool IsDisposed {get; private set; }
</code></pre><h3 id="audiocontroller-constructor">AudioController Constructor</h3>
<p>The constructor just initializes the collection used to track the sound effect instances.  Add the following constructor and finalizer:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new audio controller instance.
/// &lt;/summary&gt;
public AudioController()
{
    _activeSoundEffectInstances = new List&lt;SoundEffectInstance&gt;();
}

// Finalizer called when object is collected by the garbage collector
~AudioController() =&gt; Dispose(false);
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>AudioController</code> class implements a <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers">finalizer</a> method <code>~AudioManager()</code>.  This method is called when an instance of the class is collected by the garbage collector and is here as part of the <code>IDisposable</code> implementation.</p>
</div>
<h3 id="audiocontroller-methods">AudioController Methods</h3>
<p>The <code>AudioController</code> will need methods to:</p>
<ul>
<li>Update it to check for resources to clean up.</li>
<li>Playing sound effects and songs</li>
<li>State management (play/pause, mute/unmute)</li>
<li>Volume control</li>
<li>Implement the <code>IDisposable</code> interface.</li>
</ul>
<h4 id="audiocontroller-update">AudioController Update</h4>
<p>The <code>Update</code> method will check for existing sound effect instances that have expired and properly dispose of them.  Add the following method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates this audio controller
/// &lt;/summary&gt;
public void Update()
{
    int index = 0;

    while (index &lt; _activeSoundEffectInstances.Count)
    {
        SoundEffectInstance instance = _activeSoundEffectInstances[index];

        if (instance.State == SoundState.Stopped &amp;&amp; !instance.IsDisposed)
        {
            instance.Dispose();
        }

        _activeSoundEffectInstances.RemoveAt(index);
    }
}
</code></pre><h4 id="audiocontroller-playback">AudioController Playback</h4>
<p>While the MonoGame simplified audio API allows sound effects to be played in a fire and forget manner, doing it this way doesn't work if you need to pause them because the game paused.  Instead, we can add playback methods through the <code>AudioController</code> that can track the sound effect instances and pause them if needed, as well as checking the media player state before playing a song.  Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Plays the given sound effect.
/// &lt;/summary&gt;
/// &lt;param name=&quot;soundEffect&quot;&gt;The sound effect to play.&lt;/param&gt;
/// &lt;returns&gt;The sound effect instance created by this method.&lt;/returns&gt;
public SoundEffectInstance PlaySoundEffect(SoundEffect soundEffect)
{
    return PlaySoundEffect(soundEffect, 1.0f, 1.0f, 0.0f, false);
}

/// &lt;summary&gt;
/// Plays the given sound effect with the specified properties.
/// &lt;/summary&gt;
/// &lt;param name=&quot;soundEffect&quot;&gt;The sound effect to play.&lt;/param&gt;
/// &lt;param name=&quot;volume&quot;&gt;The volume, ranging from 0.0 (silence) to 1.0 (full volume).&lt;/param&gt;
/// &lt;param name=&quot;pitch&quot;&gt;The pitch adjustment, ranging from -1.0 (down an octave) to 0.0 (no change) to 1.0 (up an octave).&lt;/param&gt;
/// &lt;param name=&quot;pan&quot;&gt;The panning, ranging from -1.0 (left speaker) to 0.0 (centered), 1.0 (right speaker).&lt;/param&gt;
/// &lt;param name=&quot;isLooped&quot;&gt;Whether the the sound effect should loop after playback.&lt;/param&gt;
/// &lt;returns&gt;The sound effect instance created by playing the sound effect.&lt;/returns&gt;
/// &lt;returns&gt;The sound effect instance created by this method.&lt;/returns&gt;
public SoundEffectInstance PlaySoundEffect(SoundEffect soundEffect, float volume, float pitch, float pan, bool isLooped)
{
    // Create an instance from the sound effect given.
    SoundEffectInstance soundEffectInstance = soundEffect.CreateInstance();

    // Apply the volume, pitch, pan, and loop values specified.
    soundEffectInstance.Volume = volume;
    soundEffectInstance.Pitch = pitch;
    soundEffectInstance.Pan = pan;
    soundEffectInstance.IsLooped = isLooped;

    // Tell the instance to play
    soundEffectInstance.Play();

    // Add it to the active instances for tracking
    _activeSoundEffectInstances.Add(soundEffectInstance);

    return soundEffectInstance;
}

/// &lt;summary&gt;
/// Plays the given song.
/// &lt;/summary&gt;
/// &lt;param name=&quot;song&quot;&gt;The song to play.&lt;/param&gt;
/// &lt;param name=&quot;isRepeating&quot;&gt;Optionally specify if the song should repeat.  Default is true.&lt;/param&gt;
public void PlaySong(Song song, bool isRepeating = true)
{
    // Check if the media player is already playing, if so, stop it.
    // If we don't stop it, this could cause issues on some platforms
    if (MediaPlayer.State == MediaState.Playing)
    {
        MediaPlayer.Stop();
    }

    MediaPlayer.Play(song);
    MediaPlayer.IsRepeating = isRepeating;
}
</code></pre><h4 id="audiocontroller-state-control">AudioController State Control</h4>
<p>The <code>AudioController</code> provides methods to control the state of audio playback including pausing and resuming audio as well as muting and unmuting.  Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Pauses all audio.
/// &lt;/summary&gt;
public void PauseAudio()
{
    // Pause any active songs playing
    MediaPlayer.Pause();

    // Pause any active sound effects
    foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances)
    {
        soundEffectInstance.Pause();
    }
}

/// &lt;summary&gt;
/// Resumes play of all previous paused audio.
/// &lt;/summary&gt;
public void ResumeAudio()
{
    // Resume paused music
    MediaPlayer.Resume();

    // Resume any active sound effects
    foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances)
    {
        soundEffectInstance.Resume();
    }
}

/// &lt;summary&gt;
/// Mutes all audio.
/// &lt;/summary&gt;
public void MuteAudio()
{
    // Store the volume so they can be restored during ResumeAudio
    _previousSongVolume = MediaPlayer.Volume;
    _previousSoundEffectVolume = SoundEffect.MasterVolume;

    // Set all volumes to 0
    MediaPlayer.Volume = 0.0f;
    SoundEffect.MasterVolume = 0.0f;

    IsMuted = true;
}

/// &lt;summary&gt;
/// Unmutes all audio to the volume level prior to muting.
/// &lt;/summary&gt;
public void UnmuteAudio()
{
    // Restore the previous volume values
    MediaPlayer.Volume = _previousSongVolume;
    SoundEffect.MasterVolume = _previousSoundEffectVolume;

    IsMuted = false;
}

/// &lt;summary&gt;
/// Toggles the current audio mute state.
/// &lt;/summary&gt;
public void ToggleMute()
{
    if (IsMuted)
    {
        UnmuteAudio();
    }
    else
    {
        MuteAudio();
    }
}
</code></pre><h4 id="audiocontroller-idisposable-implementation">AudioController IDisposable Implementation</h4>
<p>Finally, the <code>AudioController</code> implements the <code>IDisposable</code> interface.  Add the following methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Disposes of this audio controller and cleans up resources.
/// &lt;/summary&gt;
public void Dispose()
{
    Dispose(true);
    GC.SuppressFinalize(this);
}

/// &lt;summary&gt;
/// Disposes this audio controller and cleans up resources.
/// &lt;/summary&gt;
/// &lt;param name=&quot;disposing&quot;&gt;Indicates whether managed resources should be disposed.&lt;/param&gt;
protected void Dispose(bool disposing)
{
    if(IsDisposed)
    {
        return;
    }

    if (disposing)
    {
        foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances)
        {
            soundEffectInstance.Dispose();
        }
        _activeSoundEffectInstances.Clear();
    }

    IsDisposed = true;
}
</code></pre>
<p>Games often use limited system resources like audio channels. When we're done with these resources, we need to clean them up properly. In .NET, the standard way to handle resource cleanup is through the <code>IDisposable</code> interface.</p>
<p>Think of <code>IDisposable</code> like a cleanup checklist that runs when you're finished with something:</p>
<ol>
<li>The interface provides a <code>Dispose</code> method that contains all cleanup logic.</li>
<li>When called, <code>Dispose</code> releases any resources the class was using.</li>
<li>Even if you forget to call <code>Dispose</code>, the finalizer acts as a backup cleanup mechanism.</li>
</ol>
<p>For our <code>AudioController</code>, implementing <code>IDisposable</code> means we can ensure all sound effect instances are properly stopped and disposed when our game ends, preventing resource leaks.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Fore more information on <code>IDisposable</code> and the <code>Dispose</code> method, check out the <a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose">Implementing a Dispose Method</a> article on Microsoft Learn.</p>
</div>
<h2 id="implementing-the-audiocontroller-class">Implementing the AudioController Class</h2>
<p>Now that we have the audio controller class complete, let's update the game to use it.  We'll do this in two steps:</p>
<ol>
<li>First, update the <code>Core</code> class to add the <code>AudioController</code> globally.</li>
<li>Update the <code>Game1</code> class to use the global audio controller from <code>Core</code>.</li>
</ol>
<h3 id="updating-the-core-class">Updating the Core Class</h3>
<p>The <code>Core</code> class serves as our the base game class, so we'll update it first to add and expose the <code>AudioController</code> globally.  Open the <em>Core.cs</em> file in the <em>MonoGameLibrary</em> project and update it to the following:</p>
<pre><code class="lang-csharp" highlight-lines="6,50-53,112-113,116-122,129-130">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary.Audio;
using MonoGameLibrary.Input;

namespace MonoGameLibrary;

public class Core : Game
{
    internal static Core s_instance;

    /// &lt;summary&gt;
    /// Gets a reference to the Core instance.
    /// &lt;/summary&gt;
    public static Core Instance =&gt; s_instance;

    /// &lt;summary&gt;
    /// Gets the graphics device manager to control the presentation of graphics.
    /// &lt;/summary&gt;
    public static GraphicsDeviceManager Graphics { get; private set; }

    /// &lt;summary&gt;
    /// Gets the graphics device used to create graphical resources and perform primitive rendering.
    /// &lt;/summary&gt;
    public static new GraphicsDevice GraphicsDevice { get; private set; }

    /// &lt;summary&gt;
    /// Gets the sprite batch used for all 2D rendering.
    /// &lt;/summary&gt;
    public static SpriteBatch SpriteBatch { get; private set; }

    /// &lt;summary&gt;
    /// Gets the content manager used to load global assets.
    /// &lt;/summary&gt;
    public static new ContentManager Content { get; private set; }

    /// &lt;summary&gt;
    /// Gets a reference to to the input management system.
    /// &lt;/summary&gt;
    public static InputManager Input { get; private set; }

    /// &lt;summary&gt;
    /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed.
    /// &lt;/summary&gt;
    public static bool ExitOnEscape { get; set; }

    /// &lt;summary&gt;
    /// Gets a reference to the audio control system.
    /// &lt;/summary&gt;
    public static AudioController Audio { get; private set; }

    /// &lt;summary&gt;
    /// Creates a new Core instance.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;The title to display in the title bar of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;width&quot;&gt;The initial width, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;height&quot;&gt;The initial height, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;fullScreen&quot;&gt;Indicates if the game should start in fullscreen mode.&lt;/param&gt;
    public Core(string title, int width, int height, bool fullScreen)
    {
        // Ensure that multiple cores are not created.
        if (s_instance != null)
        {
            throw new InvalidOperationException($&quot;Only a single Core instance can be created&quot;);
        }

        // Store reference to engine for global member access.
        s_instance = this;

        // Create a new graphics device manager.
        Graphics = new GraphicsDeviceManager(this);

        // Set the graphics defaults
        Graphics.PreferredBackBufferWidth = width;
        Graphics.PreferredBackBufferHeight = height;
        Graphics.IsFullScreen = fullScreen;

        // Apply the graphic presentation changes
        Graphics.ApplyChanges();

        // Set the window title
        Window.Title = title;

        // Set the core's content manager to a reference of hte base Game's
        // content manager.
        Content = base.Content;

        // Set the root directory for content
        Content.RootDirectory = &quot;Content&quot;;

        // Mouse is visible by default
        IsMouseVisible = true;
    }

    protected override void Initialize()
    {
        base.Initialize();

        // Set the core's graphics device to a reference of the base Game's
        // graphics device.
        GraphicsDevice = base.GraphicsDevice;

        // Create the sprite batch instance.
        SpriteBatch = new SpriteBatch(GraphicsDevice);

        // Create a new input manager
        Input = new InputManager();

        // Create a new audio controller.
        Audio = new AudioController();
    }

    protected override void UnloadContent()
    {
        // Dispose of the audio controller.
        Audio.Dispose();

        base.UnloadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the input manager.
        Input.Update(gameTime);

        // Update the audio controller.
        Audio.Update();

        if (ExitOnEscape &amp;&amp; Input.Keyboard.IsKeyDown(Keys.Escape))
        {
            Exit();
        }

        base.Update(gameTime);
    }
}
</code></pre>
<p>The key changes made here are:</p>
<ol>
<li>Added the <code>using MonoGameLibrary.Audio;</code> directive to access the <code>AudioController</code> class.</li>
<li>Added a static <code>Audio</code> property to provide global access to the audio controller.</li>
<li>Created the new audio controller instance in the <code>Initialize</code> method.</li>
<li>Added an override for the <code>UnloadContent</code> method where we dispose of the audio controller.</li>
<li>The audio controller is updated in the <code>Update</code> method.</li>
</ol>
<h3 id="updating-the-game1-class">Updating the Game1 Class</h3>
<p>Next, update the <code>Game1</code> class to use the audio controller for audio playback.  Open <em>Game1.cs</em> and make the following updates:</p>
<pre><code class="lang-csharp" highlight-lines="45-46,77-78,104-105,199-200,218-219,272-290">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime animated sprite.
    private AnimatedSprite _slime;

    // Defines the bat animated sprite.
    private AnimatedSprite _bat;

    // Tracks the position of the slime.
    private Vector2 _slimePosition;

    // Speed multiplier when moving.
    private const float MOVEMENT_SPEED = 5.0f;

    // Tracks the position of the bat.
    private Vector2 _batPosition;

    // Tracks the velocity of the bat.
    private Vector2 _batVelocity;

    // Defines the tilemap to draw.
    private Tilemap _tilemap;

    // Defines the bounds of the room that the slime and bat are contained within.
    private Rectangle _roomBounds;

    // The sound effect to play when the bat bounces off the edge of the screen.
    private SoundEffect _bounceSoundEffect;

    // The sound effect to play when the slime eats a bat.
    private SoundEffect _collectSoundEffect;

    // The background theme song
    private Song _themeSong;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        base.Initialize();

        Rectangle screenBounds = GraphicsDevice.PresentationParameters.Bounds;

        _roomBounds = new Rectangle(
            (int)_tilemap.TileWidth,
            (int)_tilemap.TileHeight,
            screenBounds.Width - (int)_tilemap.TileWidth * 2,
            screenBounds.Height - (int)_tilemap.TileHeight * 2
        );

        // Initial slime position will be the center tile of the tile map.
        int centerRow = _tilemap.Rows / 2;
        int centerColumn = _tilemap.Columns / 2;
        _slimePosition = new Vector2(centerColumn * _tilemap.TileWidth, centerRow * _tilemap.TileHeight);

        // Initial bat position will the in the top left corner of the room
        _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top);

        // Assign the initial random velocity to the bat.
        AssignRandomBatVelocity();

        // Start playing the background music
        Audio.PlaySong(_themeSong);
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime animated sprite from the atlas.
        _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat animated sprite from the atlas.
        _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);

        // Create the tilemap from the XML configuration file.
        _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);
        _tilemap.Scale = new Vector2(4.0f, 4.0f);

        // Load the bounce sound effect
        _bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

        // Load the collect sound effect
        _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

        // Load the background theme music
        _themeSong = Content.Load&lt;Song&gt;(&quot;audio/theme&quot;);

        base.LoadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // Update the slime animated sprite.
        _slime.Update(gameTime);

        // Update the bat animated sprite.
        _bat.Update(gameTime);

        // Check for keyboard input and handle it.
        CheckKeyboardInput();

        // Check for gamepad input and handle it.
        CheckGamePadInput();

        // Creating a bounding circle for the slime
        Circle slimeBounds = new Circle(
            (int)(_slimePosition.X + (_slime.Width * 0.5f)),
            (int)(_slimePosition.Y + (_slime.Height * 0.5f)),
            (int)(_slime.Width * 0.5f)
        );

        // Use distance based checks to determine if the slime is within the
        // bounds of the game screen, and if it's outside that screen edge,
        // move it back inside.
        if (slimeBounds.Left &lt; _roomBounds.Left)
        {
            _slimePosition.X = _roomBounds.Left;
        }
        else if (slimeBounds.Right &gt; _roomBounds.Right)
        {
            _slimePosition.X = _roomBounds.Right - _slime.Width;
        }

        if (slimeBounds.Top &lt; _roomBounds.Top)
        {
            _slimePosition.Y = _roomBounds.Top;
        }
        else if (slimeBounds.Bottom &gt; _roomBounds.Bottom)
        {
            _slimePosition.Y = _roomBounds.Bottom - _slime.Height;
        }

        // Calculate the new position of the bat based on the velocity
        Vector2 newBatPosition = _batPosition + _batVelocity;

        // Create a bounding circle for the bat
        Circle batBounds = new Circle(
            (int)(newBatPosition.X + (_bat.Width * 0.5f)),
            (int)(newBatPosition.Y + (_bat.Height * 0.5f)),
            (int)(_bat.Width * 0.5f)
        );

        Vector2 normal = Vector2.Zero;

        // Use distance based checks to determine if the bat is within the
        // bounds of the game screen, and if it's outside that screen edge,
        // reflect it about the screen edge normal
        if (batBounds.Left &lt; _roomBounds.Left)
        {
            normal.X = Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Left;
        }
        else if (batBounds.Right &gt; _roomBounds.Right)
        {
            normal.X = -Vector2.UnitX.X;
            newBatPosition.X = _roomBounds.Right - _bat.Width;
        }

        if (batBounds.Top &lt; _roomBounds.Top)
        {
            normal.Y = Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Top;
        }
        else if (batBounds.Bottom &gt; _roomBounds.Bottom)
        {
            normal.Y = -Vector2.UnitY.Y;
            newBatPosition.Y = _roomBounds.Bottom - _bat.Height;
        }

        // If the normal is anything but Vector2.Zero, this means the bat had
        // moved outside the screen edge so we should reflect it about the
        // normal.
        if (normal != Vector2.Zero)
        {
            _batVelocity = Vector2.Reflect(_batVelocity, normal);

            // Play the bounce sound effect
            Audio.PlaySoundEffect(_bounceSoundEffect);
        }

        _batPosition = newBatPosition;

        if (slimeBounds.Intersects(batBounds))
        {
            // Choose a random row and column based on the total number of each
            int column = Random.Shared.Next(1, _tilemap.Columns - 1);
            int row = Random.Shared.Next(1, _tilemap.Rows - 1);

            // Change the bat position by setting the x and y values equal to
            // the column and row multiplied by the width and height.
            _batPosition = new Vector2(column * _bat.Width, row * _bat.Height);

            // Assign a new random velocity to the bat
            AssignRandomBatVelocity();

            // Play the collect sound effect
            Audio.PlaySoundEffect(_collectSoundEffect);
        }

        base.Update(gameTime);
    }

    private void AssignRandomBatVelocity()
    {
        // Generate a random angle
        float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2);

        // Convert angle to a direction vector
        float x = (float)Math.Cos(angle);
        float y = (float)Math.Sin(angle);
        Vector2 direction = new Vector2(x, y);

        // Multiply the direction vector by the movement speed
        _batVelocity = direction * MOVEMENT_SPEED;
    }

    private void CheckKeyboardInput()
    {
        // If the space key is held down, the movement speed increases by 1.5
        float speed = MOVEMENT_SPEED;
        if (Input.Keyboard.IsKeyDown(Keys.Space))
        {
            speed *= 1.5f;
        }

        // If the W or Up keys are down, move the slime up on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.W) || Input.Keyboard.IsKeyDown(Keys.Up))
        {
            _slimePosition.Y -= speed;
        }

        // if the S or Down keys are down, move the slime down on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.S) || Input.Keyboard.IsKeyDown(Keys.Down))
        {
            _slimePosition.Y += speed;
        }

        // If the A or Left keys are down, move the slime left on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.A) || Input.Keyboard.IsKeyDown(Keys.Left))
        {
            _slimePosition.X -= speed;
        }

        // If the D or Right keys are down, move the slime right on the screen.
        if (Input.Keyboard.IsKeyDown(Keys.D) || Input.Keyboard.IsKeyDown(Keys.Right))
        {
            _slimePosition.X += speed;
        }

        // If the M key is pressed, toggle mute state for audio.
        if (Input.Keyboard.WasKeyJustPressed(Keys.M))
        {
            Audio.ToggleMute();
        }

        // If the + button is pressed, increase the volume.
        if (Input.Keyboard.WasKeyJustPressed(Keys.OemPlus))
        {
            Audio.SongVolume += 0.1f;
            Audio.SoundEffectVolume += 0.1f;
        }

        // If the - button was pressed, decrease the volume.
        if (Input.Keyboard.WasKeyJustPressed(Keys.OemMinus))
        {
            Audio.SongVolume -= 0.1f;
            Audio.SoundEffectVolume -= 0.1f;
        }
    }

    private void CheckGamePadInput()
    {
        GamePadInfo gamePadOne = Input.GamePads[(int)PlayerIndex.One];

        // If the A button is held down, the movement speed increases by 1.5
        // and the gamepad vibrates as feedback to the player.
        float speed = MOVEMENT_SPEED;
        if (gamePadOne.IsButtonDown(Buttons.A))
        {
            speed *= 1.5f;
            GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
        }
        else
        {
            GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
        }

        // Check thumbstick first since it has priority over which gamepad input
        // is movement.  It has priority since the thumbstick values provide a
        // more granular analog value that can be used for movement.
        if (gamePadOne.LeftThumbStick != Vector2.Zero)
        {
            _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
            _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
        }
        else
        {
            // If DPadUp is down, move the slime up on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadUp))
            {
                _slimePosition.Y -= speed;
            }

            // If DPadDown is down, move the slime down on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadDown))
            {
                _slimePosition.Y += speed;
            }

            // If DPapLeft is down, move the slime left on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
            {
                _slimePosition.X -= speed;
            }

            // If DPadRight is down, move the slime right on the screen.
            if (gamePadOne.IsButtonDown(Buttons.DPadRight))
            {
                _slimePosition.X += speed;
            }
        }
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the tilemap
        _tilemap.Draw(SpriteBatch);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, _slimePosition);

        // Draw the bat sprite.
        _bat.Draw(SpriteBatch, _batPosition);

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes made here are:</p>
<ol>
<li>The <code>_themeSong</code> field is added to store a reference to the background song to play.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>, the background theme song is loaded using hte content manager.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a>, the audio manager is used to play the background theme song.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> the audio manager is used to play the bounce and collect sound effects.</li>
<li>In <code>CheckKeyboardInput</code> the following checks were added
<ol>
<li>If the M key on the keyboard is pressed, it will toggle mute for all audio.</li>
<li>If the + key is pressed, the song and sound effect volumes are increased by <code>0.1f</code>.</li>
<li>If the - key is pressed, the song and sound effect volumes are decreased by <code>0.1f</code>.</li>
</ol>
</li>
</ol>
<p>Running the game now will produce the same result as the previous chapter, only now the lifetime of sound effects and the state management of audio is done through the new audio controller.  You can also mute and unumte the audio with the M key and increase and decrease the volume using the + and - keys.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 15-1: Gameplay with audio.</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>Let's review what you accomplished in this chapter:</p>
<ul>
<li>Created a reusable <code>AudioController</code> class to centralize audio management.</li>
<li>Learned about proper resource management for audio using the <code>IDisposable</code> pattern.</li>
<li>Implemented tracking and cleanup of sound effect instances.</li>
<li>Added global volume control for both sound effects and music.</li>
<li>Created methods to toggle audio states (play/pause, mute/unmute).</li>
<li>Updated the <code>Core</code> class to provide global access to the audio controller.</li>
<li>Added keyboard controls to adjust volume and toggle mute state.</li>
</ul>
<p>The <code>AudioController</code> class you created is a significant improvement over directly using MonoGame's audio APIs. It handles common audio management tasks that would otherwise need to be implemented repeatedly in different parts of your game. By centralizing these functions, you make your code more maintainable and provide a consistent audio experience across your game.</p>
<p>In the next chapter, we'll start exploring fonts and adding text to the game.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
