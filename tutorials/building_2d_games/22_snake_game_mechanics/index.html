<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-22-snake-game-mechanics">Chapter 22: Snake Game Mechanics</h1>
<p class="text-secondary">Learn how to implement classic snake-like game mechanics and organize game objects into reusable components.</p>
<p>In the previous chapters, we have built all the fundamental systems needed for our game: <a href="../07_optimizing_texture_rendering/index.html">graphics</a>, <a href="../11_input_management/index.html">input</a>, <a href="../12_collision_detection/index.html">collision detection</a>, <a href="../15_audio_controller/index.html">audio</a>, <a href="../17_scenes/index.html">scene management</a>, and a <a href="../19_user_interface_fundamentals/index.html">user interface</a>.  Now it is time to transform our demo into a complete experience by implementing classic snake-like game mechanics. Before we do that, we first need to define what mechanics make a snake game.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Understand the core mechanics that define a classic snake-like game.</li>
<li>Learn how to implement grid-based movement with timed intervals.</li>
<li>Create a segmented character that grows when collecting objects.</li>
<li>Implement a unified input controller for game actions.</li>
<li>Build the <code>SlimeSegment</code> struct for storing segment data.</li>
<li>Create the <code>Slime</code> class to manage all snake-like behavior for the slime.</li>
<li>Create the <code>Bat</code> class as the collectable object.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>This chapter will not focus much on MonoGame itself, but rather our implementation of the mechanics to transform our current game into a snake-like game.</p>
</div>
<h2 id="understanding-snake-game-mechanics">Understanding Snake Game Mechanics</h2>
<p>In a classic snake-like game, the mechanics follow a set of simple but engaging rules:</p>
<ol>
<li>The player controls a snake by telling it to move in one of four cardinal directions (up, down, left, and right).</li>
<li>The snake cannot reverse into itself, only moving forward or perpendicular to its current direction.</li>
<li>The actual movement of the snake occurs at regular timed intervals, creating a grid-based movement pattern.</li>
<li>When the snake eats food, it grows longer by adding a new segment to its tail.</li>
<li>If the snake collides with a wall or its own body, the game ends.</li>
</ol>
<p>The mechanics create an increasingly challenging experience as the snake grows longer, requiring planning and reflexes to avoid collision.</p>
<h3 id="directions">Directions</h3>
<p>In snake, players input a cardinal direction (up, down, left, and right), to indicate which direction the snake will move during the next movement cycle.  When direction input occurs, it must be checked against the current direction to determine if the move is valid.</p>
<p>For example, if the snake is moving to the right, an invalid input would allow a player to move it to the left.  Doing so would cause the head of the snake to reverse direction and immediately collide with the first body segment. This means the only valid inputs are those where the next direction would be the same as the current direction or perpendicular to the current direction.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/snake_directions.png" alt="Figure 22-1: An example snake with four segments, the head segment highlighted in orange, moving to the right.  Arrows show that the only valid movements for the head segment are up or down (perpendicular) or to continue to the right."></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 22-1: An example snake with four segments, the head segment highlighted in orange, moving to the right.  Arrows show that the only valid movements for the head segment are up or down (perpendicular) or to continue to the right.</strong></td>
</tr>
</tbody>
</table>
<h3 id="movement-cycle">Movement Cycle</h3>
<p>Instead of moving every update frame as a directional input is being pressed, the snake instead only moves during regular timed intervals.  A timer is used to determine how much time has passed since the last movement cycle, and when it reaches a set threshold, the next movement cycle occurs.  During this movement cycle, the snake should move forward in the direction that was input by the player between the last and current movement cycles.  This creates the grid-based movement system typically found in snake-like games.</p>
<p>There are various methods for handling the movement, such as iterating through each segment of the snake and updating the position of that segment to move forward.  Methods such as this though are wasteful, since visually the only parts of the snake that move on the screen are the head and the tail.</p>
<p>Instead, a more common approach is to:</p>
<ol>
<li><p>Make a copy of the head segment.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/snake_copy_head.png" alt="Figure 22-2: From a snake with four segments, a copy of the head segment is made, represented by the orange block"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 22-2 From a snake with four segments, a copy of the head segment is made, represented by the orange block</strong></td>
</tr>
</tbody>
</table>
</li>
<li><p>Update the properties of the copy so that it is positioned where the original head segment would have moved to.</p>
</li>
<li><p>Insert the copy at the front of the segment collection.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/snake_insert_head.png" alt="Figure 22-3: The copy of the head segment, represented by the orange block, is inserted at the front of the segment collection as the new head, which now makes it five segments (one too many)"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 22-3: The copy of the head segment, represented by the orange block, is inserted at the front of the segment collection as the new head, which now makes it five segments (one too many)</strong></td>
</tr>
</tbody>
</table>
</li>
<li><p>Remove the tail segment.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/snake_remove_tail.png" alt="Figure 22-4: The tail segment of the snake is removed, bringing it back to the original four segments, giving the illusion that the entire snake moved forward "></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 22-4: The tail segment of the snake is removed, bringing it back to the original four segments, giving the illusion that the entire snake moved forward</strong></td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>By doing this, no matter how many segments the snake body has, we only ever need to update two of them, the head and the tail.</p>
<h3 id="growth">Growth</h3>
<p>The next core mechanic for a snake-like game is the growth of the snake.  Typically, somewhere in the game is an objective for the snake to eat, such as an apple.  When the head of the snake reaches this objective, a new segment is added to the snake's body, making it longer, the player's score is increased, and a new objective is spawned at a random location within the game.</p>
<p>This mechanic also acts as an artificial difficulty curve for the game.  As the body of the snake grows longer, it requires planning to avoid creating situations where the snake becomes trapped by its own body making it impossible to avoid a collision.</p>
<h3 id="game-over">Game Over</h3>
<p>The challenge in a snake-like game is to avoid colliding with either a wall or another segment of the snake body.  Doing so will cause a game over condition as the snake can no longer continue moving forward.</p>
<h2 id="implementing-snake-like-mechanics-in-our-game">Implementing Snake-Like Mechanics In Our Game</h2>
<p>Now that we have a foundational set of rules in place for the mechanics of a snake-like game, we will implement them into the current demo we have been building up. Our game will adapt these mechanics to fit them into our existing game structure:</p>
<ul>
<li>Instead of a snake, we will use the slime and create a chain of slime segments that follow the slime at the front.</li>
<li>The player will control the direction of the slime segment</li>
<li>The bat will serve as the objective to acquire to grow the slime segment.</li>
<li>Collisions with either the walls of the room or a slime segment will result in a game over state.</li>
</ul>
<p>As we implement these mechanics, we are also going to be creating classes that encapsulate the properties and functions of existing implementations in the game scene, such as the slime and the bat.  For example, currently, the game scene tracks fields for the <code>AnimatedSprite</code> and the position of the slime, as well as updating, input handling, and drawing the slime.  These can be moved into their dedicated classes encapsulating the functionality and also cleaning up the code in the game scene that has grown quite large.</p>
<h3 id="the-gamecontroller-class">The GameController Class</h3>
<p>Currently, we have two methods dedicated to handling input in the game scene, <code>CheckKeyboardInput</code> and <code>CheckGamePadInput</code>, both of these methods essentially perform the same logic across different input devices. This presents an opportunity to improve our code.</p>
<p>To simplify input handling for the game, we can create a dedicated class that consolidates the input methods, providing a unified input profile for the game.  This pattern is widely used in game development to separate the &quot;what&quot; (game actions) from the &quot;how&quot; (specific input devices and buttons).</p>
<p>Create a new file named <code>GameController.cs</code> in the root of the <code>DungeonSlime</code> project (your main game project) and add the following code:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Input;

namespace DungeonSlime;

/// &lt;summary&gt;
/// Provides a game-specific input abstraction that maps physical inputs
/// to game actions, bridging our input system with game-specific functionality.
/// &lt;/summary&gt;
public static class GameController
{
    private static KeyboardInfo s_keyboard =&gt; Core.Input.Keyboard;
    private static GamePadInfo s_gamePad =&gt; Core.Input.GamePads[(int)PlayerIndex.One];

    /// &lt;summary&gt;
    /// Returns true if the player has triggered the &quot;move up&quot; action.
    /// &lt;/summary&gt;
    public static bool MoveUp()
    {
        return s_keyboard.WasKeyJustPressed(Keys.Up) ||
               s_keyboard.WasKeyJustPressed(Keys.W) ||
               s_gamePad.WasButtonJustPressed(Buttons.DPadUp) ||
               s_gamePad.WasButtonJustPressed(Buttons.LeftThumbstickUp);
    }

    /// &lt;summary&gt;
    /// Returns true if the player has triggered the &quot;move down&quot; action.
    /// &lt;/summary&gt;
    public static bool MoveDown()
    {
        return s_keyboard.WasKeyJustPressed(Keys.Down) ||
               s_keyboard.WasKeyJustPressed(Keys.S) ||
               s_gamePad.WasButtonJustPressed(Buttons.DPadDown) ||
               s_gamePad.WasButtonJustPressed(Buttons.LeftThumbstickDown);
    }

    /// &lt;summary&gt;
    /// Returns true if the player has triggered the &quot;move left&quot; action.
    /// &lt;/summary&gt;
    public static bool MoveLeft()
    {
        return s_keyboard.WasKeyJustPressed(Keys.Left) ||
               s_keyboard.WasKeyJustPressed(Keys.A) ||
               s_gamePad.WasButtonJustPressed(Buttons.DPadLeft) ||
               s_gamePad.WasButtonJustPressed(Buttons.LeftThumbstickLeft);
    }

    /// &lt;summary&gt;
    /// Returns true if the player has triggered the &quot;move right&quot; action.
    /// &lt;/summary&gt;
    public static bool MoveRight()
    {
        return s_keyboard.WasKeyJustPressed(Keys.Right) ||
               s_keyboard.WasKeyJustPressed(Keys.D) ||
               s_gamePad.WasButtonJustPressed(Buttons.DPadRight) ||
               s_gamePad.WasButtonJustPressed(Buttons.LeftThumbstickRight);
    }

    /// &lt;summary&gt;
    /// Returns true if the player has triggered the &quot;pause&quot; action.
    /// &lt;/summary&gt;
    public static bool Pause()
    {
        return s_keyboard.WasKeyJustPressed(Keys.Escape) ||
               s_gamePad.WasButtonJustPressed(Buttons.Start);
    }

    /// &lt;summary&gt;
    /// Returns true if the player has triggered the &quot;action&quot; button,
    /// typically used for menu confirmation.
    /// &lt;/summary&gt;
    public static bool Action()
    {
        return s_keyboard.WasKeyJustPressed(Keys.Enter) ||
               s_gamePad.WasButtonJustPressed(Buttons.A);
    }
}
</code></pre>
<p>The <code>GameController</code> class implements an important design pattern in game development known as <strong>&quot;Input Abstraction&quot;</strong> or the <strong>&quot;Command&quot;</strong> pattern.  This pattern separates what happens in the game (the actions) from how players trigger those actions (the inputs).</p>
<p>This separation provides several benefits, including:</p>
<ol>
<li><strong>Input Device Independence</strong>: The game logic does not need to know which input device the player is using. Whether they are playing with a keyboard, gamepad, or touch screen, the game only cares that a &quot;move up&quot; action was triggered, not which specific button or key caused it.</li>
<li><strong>Simplified Input Handling</strong>: Instead of checking multiple input combinations throughout the codebase, game objects can simply ask &quot;Should I move up?&quot; through a clean API call.</li>
<li><strong>Easy Rebinding</strong>: If you want to add key rebinding features, you only need to modify the <code>GameController</code> class, not every piece of code that uses input.</li>
<li><strong>Consistent Input Logic</strong>: The rules for determining if an action occurred (like checking if a button was just pressed version being held down) are defined in one place.</li>
<li><strong>Cross-Platform Compatibility</strong>: When porting to different platforms with different input methods, you only need to update the <code>GameController</code> class to map the new input devices to your existing game actions.</li>
</ol>
<p>By implementing this pattern in our game, we are not only making our current input handling cleaner, but we are also establishing a foundation that would make it easier to add features like input customization or support for new input devices in the future.</p>
<p>With our input handling system in place, now we can turn our attention to implementing the core mechanics of our snake-like game. First, we need to create a structure that will represent each segment of the slime's body.</p>
<h3 id="the-slimesegment-struct">The SlimeSegment Struct</h3>
<p>We will need to implement a structure that can represent each segment of the slime, this structure will store the position and movement data for each segment.</p>
<p>In the <em>DungeonSlime</em> project (your main game project), create a new directory named <code>GameObjects</code>. We will be putting all of our code related to the objects within the game here.
Then create a new file named <code>SlimeSegment.cs</code> inside the <code>GameObjects</code> directory you just created and add the following code:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;

namespace DungeonSlime.GameObjects;

public struct SlimeSegment
{
    /// &lt;summary&gt;
    /// The position this slime segment is at before the movement cycle occurs.
    /// &lt;/summary&gt;
    public Vector2 At;

    /// &lt;summary&gt;
    /// The position this slime segment should move to during the next movement cycle.
    /// &lt;/summary&gt;
    public Vector2 To;

    /// &lt;summary&gt;
    /// The direction this slime segment is moving.
    /// &lt;/summary&gt;
    public Vector2 Direction;

    /// &lt;summary&gt;
    /// The opposite direction this slime segment is moving.
    /// &lt;/summary&gt;
    public Vector2 ReverseDirection =&gt; new Vector2(-Direction.X, -Direction.Y);
}
</code></pre>
<p>This structure contains fields to track:</p>
<ul>
<li><code>At</code>: The current position of the segment.</li>
<li><code>To</code>: The position the segment will move to during the next movement cycle if it is the head segment.</li>
<li><code>Direction</code>: A normalized vector representing the direction the segment is moving in.</li>
<li><code>ReverseDirection</code>: A computed property that returns the opposite of the <code>Direction</code> property.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>We are implementing this as a struct rather than a class because SlimeSegment is a small, simple data container with value semantics. Structs are more efficient for small data structures since they are allocated on the <a href="https://learn.microsoft.com/en-us/dotnet/standard/automatic-memory-management">stack rather than the heap</a>, reducing garbage collection overhead. Since our game will potentially create many segments as the snake grows, using a struct can provide better performance, especially when we will be copying segment data during movement operations.</p>
</div>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Structs work best with value types (like int, float, <a href="xref:Microsoft.Xna.Framework.Vector2"><strong>Vector2</strong></a>); using reference types in structs can cause boxing operations that negate the performance benefits. For more information on structs, refer to the <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct">Structure Types - C# Reference</a> documentation on Microsoft Learn.</p>
</div>
<p>By tracking both the current (<code>At</code>) and target (<code>To</code>) positions, we can implement smooth visual movement between grid positions, creating more fluid animations than the traditional stutter step movement seen in classic snake games.  We will explore this concept a little further in this chapter.</p>
<h3 id="the-slime-class">The Slime Class</h3>
<p>Next, we can implement a class to encapsulate the properties and functionality of our snake-like slime.</p>
<p>In the <code>GameObjects</code> directory of the <em>DungeonSlime</em> project (your main game project), create a new file named <code>Slime.cs</code> and add the following initial code:</p>
<pre><code class="lang-csharp">using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace DungeonSlime.GameObjects;

public class Slime
{

}
</code></pre>
<p>This code sets up the basic structure for our <code>Slime</code> class. We have added the necessary using statements to access MonoGame's framework components and placed the class in the <code>DungeonSlime.GameObjects</code> namespace to keep our code organized. The empty class will serve as our foundation, and we will build it up piece by piece in the following sections.</p>
<p>Each section below should be added to the <code>Slime</code> class in the order presented. As we go through each part, the class will gradually take shape to handle all the snake-like behavior we need.</p>
<div class="NOTE">
<h5>Note</h5>
<p>When adding these sections one by one, you may see compiler errors until all sections are in place. This is normal, as some parts of the code will reference fields or methods that have not been added yet. Once all sections are complete, these errors will resolve.</p>
</div>
<h4 id="slime-fields">Slime Fields</h4>
<p>Add the following fields to the <code>Slime</code> class:</p>
<pre><code class="lang-csharp">// A constant value that represents the amount of time to wait between
// movement updates.
private static readonly TimeSpan s_movementTime = TimeSpan.FromMilliseconds(200);

// The amount of time that has elapsed since the last movement update.
private TimeSpan _movementTimer;

// Normalized value (0-1) representing progress between movement ticks for visual interpolation
private float _movementProgress;

// The next direction to apply to the head of the slime chain during the
// next movement update.
private Vector2 _nextDirection;

// The number of pixels to move the head segment during the movement cycle.
private float _stride;

// Tracks the segments of the slime chain.
private List&lt;SlimeSegment&gt; _segments;

// The AnimatedSprite used when drawing each slime segment
private AnimatedSprite _sprite;
</code></pre>
<p>Each of these fields is responsible for:</p>
<ul>
<li><code>s_movementTime</code>: This constant represents how long the slime waits between movement cycles (300ms). This creates the classic snake game's grid-based movement feel, where the snake moves at regular intervals rather than continuously.</li>
<li><code>_movementTime</code>: This field accumulates elapsed time until it reaches the movement threshold. When it does, the slime moves one grid cell and the timer resets.</li>
<li><code>_movementProgress</code>: This normalized value (0-1) represents progress between movement ticks and is used for visual interpolation. It allows us to smoothly animate the slime's movement between grid positions.</li>
<li><code>_nextDirection</code>: This stores the direction that will be applied to the head segment during the next movement cycle.</li>
<li><code>_stride</code>: This represents the total number of pixels the head segment should move during movement cycles.</li>
<li><code>_segments</code>: This collection holds all the <code>SlimeSegment</code> structures that make up the slime's body. The first segment is the head, and the rest form the trailing body.</li>
<li><code>_sprite</code>: This stores the <code>AnimatedSprite</code> that is used to draw each segment of the slime.</li>
</ul>
<p>These fields implement core snake-like mechanics - the timed interval movement, direction control, and the segmented body that forms the snake.</p>
<h4 id="slime-events">Slime Events</h4>
<p>Next, add the following event to the <code>Slime</code> class after the fields:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Event that is raised if it is detected that the head segment of the slime
/// has collided with a body segment.
/// &lt;/summary&gt;
public event EventHandler BodyCollision;
</code></pre>
<p>This event will allow the <code>Slime</code> class to notify the game scene when the head of the slime collides with another segment, triggering a game over.</p>
<h4 id="slime-constructor">Slime Constructor</h4>
<p>After the event, add the following constructor to the <code>Slime</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new Slime using the specified animated sprite.
/// &lt;/summary&gt;
/// &lt;param name=&quot;sprite&quot;&gt;The AnimatedSprite to use when drawing the slime.&lt;/param&gt;
public Slime(AnimatedSprite sprite)
{
    _sprite = sprite;
}
</code></pre>
<p>This is a simple constructor that requires the slime to be given the <code>AnimatedSprite</code> that will be used to draw each of the slime segments.</p>
<h4 id="slime-initialization">Slime Initialization</h4>
<p>Add the following <code>Initialization</code> method to the <code>Slime</code> class after the constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Initializes the slime, can be used to reset it back to an initial state.
/// &lt;/summary&gt;
/// &lt;param name=&quot;startingPosition&quot;&gt;The position the slime should start at.&lt;/param&gt;
/// &lt;param name=&quot;stride&quot;&gt;The total number of pixels to move the head segment during each movement cycle.&lt;/param&gt;
public void Initialize(Vector2 startingPosition, float stride)
{
    // Initialize the segment collection.
    _segments = new List&lt;SlimeSegment&gt;();

    // Set the stride
    _stride = stride;

    // Create the initial head of the slime chain.
    SlimeSegment head = new SlimeSegment();
    head.At = startingPosition;
    head.To = startingPosition + new Vector2(_stride, 0);
    head.Direction = Vector2.UnitX;

    // Add it to the segment collection.
    _segments.Add(head);

    // Set the initial next direction as the same direction the head is
    // moving.
    _nextDirection = head.Direction;

    // Zero out the movement timer.
    _movementTimer = TimeSpan.Zero;
}
</code></pre>
<p>With this method, we can initialize, or reset the state of slime.  It:</p>
<ul>
<li>Instantiates a new segment collection.</li>
<li>Creates the initial head segment and positions it at the specific <code>startingPosition</code>.</li>
<li>Sets the initial direction to be to the right.</li>
<li>Initialize the movement timer to zero.</li>
</ul>
<h4 id="slime-input-handling">Slime Input Handling</h4>
<p>Next, add the <code>HandleInput</code> method to process player input after the <code>Initialize</code> method:</p>
<pre><code class="lang-csharp">private void HandleInput()
{
    Vector2 potentialNextDirection = _nextDirection;

    if (GameController.MoveUp())
    {
        potentialNextDirection = -Vector2.UnitY;
    }
    else if (GameController.MoveDown())
    {
        potentialNextDirection = Vector2.UnitY;
    }
    else if (GameController.MoveLeft())
    {
        potentialNextDirection = -Vector2.UnitX;
    }
    else if (GameController.MoveRight())
    {
        potentialNextDirection = Vector2.UnitX;
    }

    // Only allow direction change if it is not reversing the current
    // direction.  This prevents the slime from backing into itself.
    float dot = Vector2.Dot(potentialNextDirection, _segments[0].Direction);
    if (dot &gt;= 0)
    {
        _nextDirection = potentialNextDirection;
    }
}
</code></pre>
<p>This method implements the following:</p>
<ol>
<li>Determine if the player is attempting to change directions instead of directly moving the slime.  This direction change will be applied later during the movement cycle update.</li>
<li>Uses <a href="xref:Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)"><strong>Vector2.Dot</strong></a> to prevent the slime from reversing into itself, causing an immediate collision and game over state.</li>
<li>Updates the <code>_nextDirection</code> value only if the direction input is valid.</li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>The dot product measures how much two vectors point in the same direction. It is:</p>
<ul>
<li>Positive if they are pointing in the same direction.</li>
<li>Negative if they are pointing in opposite directions.</li>
<li>Zero when they are perpendicular.</li>
</ul>
<p>By using dot product here, this effectively implements the classic snake-like game rule that you cannot turn 180° into yourself.</p>
</div>
<h4 id="slime-movement-cycle">Slime Movement Cycle</h4>
<p>To handle the snake-like movement cycle of the slime, we will create a method called <code>Move</code>.</p>
<p>Add the following method to the <code>Slime</code> class after the <code>HandleInput</code> method:</p>
<pre><code class="lang-csharp">private void Move()
{
    // Capture the value of the head segment
    SlimeSegment head = _segments[0];

    // Update the direction the head is supposed to move in to the
    // next direction cached.
    head.Direction = _nextDirection;

    // Update the head's &quot;at&quot; position to be where it was moving &quot;to&quot;
    head.At = head.To;

    // Update the head's &quot;to&quot; position to the next tile in the direction
    // it is moving.
    head.To = head.At + head.Direction * _stride;

    // Insert the new adjusted value for the head at the front of the
    // segments and remove the tail segment. This effectively moves
    // the entire chain forward without needing to loop through every
    // segment and update its &quot;at&quot; and &quot;to&quot; positions.
    _segments.Insert(0, head);
    _segments.RemoveAt(_segments.Count - 1);

    // Iterate through all of the segments except the head and check
    // if they are at the same position as the head. If they are, then
    // the head is colliding with a body segment and a body collision
    // has occurred.
    for (int i = 1; i &lt; _segments.Count; i++)
    {
        SlimeSegment segment = _segments[i];

        if (head.At == segment.At)
        {
            if(BodyCollision != null)
            {
                BodyCollision.Invoke(this, EventArgs.Empty);
            }

            return;
        }
    }
}
</code></pre>
<p>This method performs the core snake-like movement cycle logic by:</p>
<ol>
<li>Copying the value of the current head segment.</li>
<li>Updating the copy's position (<code>At</code>) to where the head was moving to and updating the position it is moving to (<code>To</code>).</li>
<li>Insert the copy into the front of the segment collection and remove the tail.</li>
<li>Check if the head is now in the same position as any body segments, which would cause a collision and trigger a game over.</li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>By inserting a new head segment at the front of the chain and removing the last segment, this creates the illusion of the entire chain moving forward as one, even though we are only actually moving the head forward and removing the tail.</p>
<p>This follows the common snake movement pattern as discussed in the <a href="#movement-cycle">Understanding Snake Game Mechanics: Movement Cycle</a> section above.</p>
</div>
<h4 id="slime-growth">Slime Growth</h4>
<p>To handle the snake-like growth of the slime, we will create a new method called <code>Grow</code>.</p>
<p>Add the following method to the <code>Slime</code> class after the <code>Move</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Informs the slime to grow by one segment.
/// &lt;/summary&gt;
public void Grow()
{
    // Capture the value of the tail segment
    SlimeSegment tail = _segments[_segments.Count - 1];

    // Create a new tail segment that is positioned a grid cell in the
    // reverse direction from the tail moving to the tail.
    SlimeSegment newTail = new SlimeSegment();
    newTail.At = tail.To + tail.ReverseDirection * _stride;
    newTail.To = tail.At;
    newTail.Direction = Vector2.Normalize(tail.At - newTail.At);

    // Add the new tail segment
    _segments.Add(newTail);
}
</code></pre>
<p>Th <code>Grow</code> method works as follows:</p>
<ol>
<li>First it creates a copy of the current tail value.</li>
<li>It then adjusts the values of the copy so that it is now positioned behind the current tail by using the <code>ReverseDirection</code> value of the tail.</li>
<li>Finally, it inserts this new tail into the segments collection.</li>
</ol>
<h4 id="slime-update">Slime Update</h4>
<p>With most of the core snake-like mechanics now added to the <code>Slime</code> class within their own methods we can now work on what happens while the slime is operating.</p>
<p>Add the following <code>Update</code> method to the <code>Slime</code> class after the <code>Grow</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the slime.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the timing values for the current update cycle.&lt;/param&gt;
public void Update(GameTime gameTime)
{
    // Update the animated sprite.
    _sprite.Update(gameTime);

    // Handle any player input
    HandleInput();

    // Increment the movement timer by the frame elapsed time.
    _movementTimer += gameTime.ElapsedGameTime;

    // If the movement timer has accumulated enough time to be greater than
    // the movement time threshold, then perform a full movement.
    if (_movementTimer &gt;= s_movementTime)
    {
        _movementTimer -= s_movementTime;
        Move();
    }

    // Update the movement lerp offset amount
    _movementProgress = (float)(_movementTimer.TotalSeconds / s_movementTime.TotalSeconds);
}
</code></pre>
<p>This update method:</p>
<ol>
<li>Updates the slime's <code>AnimatedSprite</code> to ensure the sprite animations occur.</li>
<li>Calls <code>HandleInput</code> to check for player input.</li>
<li>Increments the movement timer by the amount of time that has elapsed between the game's update cycles.</li>
<li>Performs a check to see if the movement timer has accumulated more time than the threshold to perform a movement cycle update.  If it has then:
1. The movement timer is reduced by the threshold time.
2. The <code>Move</code> method is called to perform a movement cycle update.</li>
<li>Finally, the movement progress amount is calculated by dividing the number of seconds accumulated for the movement timer by the number of seconds for the threshold.  This gives us a normalized value between 0.0 and 1.0 that we can use for visual interpolation for fluid movement.</li>
</ol>
<div class="TIP">
<h5>Tip</h5>
<p>In games, frame rates can vary based on system performance, causing inconsistent update intervals.  If we simply reset the movement timer to zero after each movement cycle, we would lose any excess time that accumulated beyond the movement threshold.</p>
<p>For example:</p>
<ul>
<li>Our movement threshold is 200ms.</li>
<li>The game runs at 60fps (16.67ms per frame).</li>
<li>After 12 frames, we have accumulated 200.04ms.</li>
<li>If we reset to zero, we lose 0.04ms.</li>
<li>Over time, these small losses can add up and cause inconsistent movement.</li>
</ul>
<p>By subtracting the threshold instead of resetting to zero, we &quot;bank&quot; the excess time (0.06ms in this example) for the next movement cycle.  This ensures that:</p>
<ol>
<li>Movement happens exactly at the intended frequency, maintaining consistent game speed.</li>
<li>The visual smoothness of movement remains intact even if the game occasionally drops frames.</li>
<li>Players experience the same game timing regardless of their hardware's performance.</li>
</ol>
<p>This technique is standard practice in game development, especially for timing-sensitive mechanics like rhythmic games, animations, and movement systems.  It is a simple solution that significantly improves gameplay consistency.</p>
</div>
<h4 id="slime-draw">Slime Draw</h4>
<p>We also need a method to handle drawing the slime and all of its segments.</p>
<p>Add the following <code>Draw</code> method after the <code>Update</code> method to the <code>Slime</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Draws the slime.
/// &lt;/summary&gt;
public void Draw()
{
    // Iterate through each segment and draw it
    foreach (SlimeSegment segment in _segments)
    {
        // Calculate the visual position of the segment at the moment by
        // lerping between its &quot;at&quot; and &quot;to&quot; position by the movement
        // offset lerp amount
        Vector2 pos = Vector2.Lerp(segment.At, segment.To, _movementProgress);

        // Draw the slime sprite at the calculated visual position of this
        // segment
        _sprite.Draw(Core.SpriteBatch, pos);
    }
}
</code></pre>
<p>This draw method iterates each segment of the slime and calculates the visual position to draw each segment at by performing <a href="https://www.corykoseck.com/2018/08/29/programming-in-c-lerp/">linear interpolation (lerp)</a> to determine the position of the segment between its current position (<code>At</code>) and the position it is moving to (<code>To</code>) based on the <code>_movementProgress</code> calculation.</p>
<div class="NOTE">
<h5>Note</h5>
<p><a href="xref:Microsoft.Xna.Framework.Vector2.Lerp(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)"><strong>Vector2.Lerp</strong></a> performs a linear interpolation between two vectors, creating a smooth transition from start to end based on an amount parameter.  The formula is:</p>
<p><span class="math">\(\text{result} = \text{start} + (\text{end} - \text{start}) \cdot \text{amount}\)</span></p>
<p>Where the amount parameter ranges from 0.0 (returns the start position) to 1.0 (returns the end position).  Values between 0.0 and 1.0 give positions along the straight line between start and end.</p>
<p>In our game, this is used to create a visual fluid movement illusion by interpolating between a segment's current position (<code>At</code>) and its target position (<code>To</code>) based on the elapsed time, rather than having the segments abruptly jump from one grid position to the next after each movement update.</p>
</div>
<h4 id="slime-bounds">Slime Bounds</h4>
<p>For the game scene to detect collisions between the slime and other elements (walls or the bat), we need a method to calculate the current collision bounds.</p>
<p>Add the following method to the <code>Slime</code> class after the <code>Draw</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a Circle value that represents collision bounds of the slime.
/// &lt;/summary&gt;
/// &lt;returns&gt;A Circle value.&lt;/returns&gt;
public Circle GetBounds()
{
    SlimeSegment head = _segments[0];

    // Calculate the visual position of the head at the moment of this
    // method call by lerping between the &quot;at&quot; and &quot;to&quot; position by the
    // movement offset lerp amount
    Vector2 pos = Vector2.Lerp(head.At, head.To, _movementProgress);

    // Create the bounds using the calculated visual position of the head.
    Circle bounds = new Circle(
        (int)(pos.X + (_sprite.Width * 0.5f)),
        (int)(pos.Y + (_sprite.Height * 0.5f)),
        (int)(_sprite.Width * 0.5f)
    );

    return bounds;
}
</code></pre>
<p>This method takes the current head segment (the first segment in our collection), calculates its visual position using linear interpolation, and then creates a <code>Circle</code> value to represent its collision boundary. Using the interpolated position ensures that collision detection aligns with what the player sees on screen.</p>
<div class="NOTE">
<h5>Note</h5>
<p>We only need collision bounds for the slime's head for interactions with the bat and walls, as this matches the classic snake game mechanic where only the head's collisions matter for gameplay. For detecting collisions between the head and body segments, we use a simpler position-based check in the <code>Move</code> method since those positions are always aligned to the grid.</p>
</div>
<p>With all these methods in place, our Slime class now fully implements the snake-like mechanics we need.</p>
<p>It handles:</p>
<ul>
<li>Movement on a grid.</li>
<li>Prevents invalid direction changes</li>
<li>Detects self-collisions</li>
<li>Provides smooth visual movement between grid positions.</li>
</ul>
<p>This encapsulation allows us to manage all slime-related behavior in one place while exposing only the necessary interfaces to the game scene.</p>
<p>Now that we have our player-controlled character implemented, we can create the object that the slime will try to collect; the bat.</p>
<h3 id="the-bat-class">The Bat Class</h3>
<p>In the <code>GameObjects</code> directory of the <em>DungeonSlime</em> project (your main game project), create a new file named <code>Bat.cs</code> and add the following initial code:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace DungeonSlime.GameObjects;

public class Bat
{

}
</code></pre>
<p>This code establishes the foundation for our <code>Bat</code> class. We have included the necessary using statements for MonoGame components, audio functionality, and our library references. The class is placed in the same <code>DungeonSlime.GameObjects</code> namespace as our Slime class to maintain a consistent organization.</p>
<p>Now we will build this class step by step, adding all the functionality needed for the bat to serve as the collectible object in our game.  Add each of the following sections to the <code>Bat</code> class in the order they are presented.</p>
<div class="NOTE">
<h5>Note</h5>
<p>As with the Slime class, you may encounter compiler errors until all sections are in place. These errors will be resolved once all components of the class have been added.</p>
</div>
<h4 id="bat-fields">Bat Fields</h4>
<p>Add the following fields to the <code>Bat</code> class:</p>
<pre><code class="lang-csharp">private const float MOVEMENT_SPEED = 5.0f;

// The velocity of the bat that defines the direction and how much in that
// direction to update the bats position each update cycle.
private Vector2 _velocity;

// The AnimatedSprite used when drawing the bat.
private AnimatedSprite _sprite;

// The sound effect to play when the bat bounces off the edge of the room.
private SoundEffect _bounceSoundEffect;
</code></pre>
<p>Each of these fields is responsible for:</p>
<ul>
<li><code>MOVEMENT_SPEED</code>: This constant represents the factor to multiply the velocity vector by to determine how fast the bat is moving.</li>
<li><code>_velocity</code>: A vector that defines the direction and how much in that direction to update the position of the bat each update cycle.</li>
<li><code>_sprite</code>: This stores the <code>AnimatedSprite</code> that is used to draw the bat.</li>
<li><code>_bounceSoundEffect</code>: This store the <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect"><strong>SoundEffect</strong></a> to play when the bat is told to bounce.</li>
</ul>
<h4 id="bat-properties">Bat Properties</h4>
<p>Next, add the following property to the <code>Bat</code> class after the fields:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or Sets the position of the bat.
/// &lt;/summary&gt;
public Vector2 Position { get; set;}
</code></pre>
<p>This property exposes the position of the bat so it can be used for calculations in the game scene when determining where to place the bat after the slime eats it.</p>
<h4 id="bat-constructor">Bat Constructor</h4>
<p>After the property, add the following constructor to the <code>Bat</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new Bat using the specified animated sprite and sound effect.
/// &lt;/summary&gt;
/// &lt;param name=&quot;sprite&quot;&gt;The AnimatedSprite ot use when drawing the bat.&lt;/param&gt;
/// &lt;param name=&quot;bounceSoundEffect&quot;&gt;The sound effect to play when the bat bounces off a wall.&lt;/param&gt;
public Bat(AnimatedSprite sprite, SoundEffect bounceSoundEffect)
{
    _sprite = sprite;
    _bounceSoundEffect = bounceSoundEffect;
}
</code></pre>
<p>This is a simple constructor that requires the bat to be given the <code>AnimatedSprite</code> that will be used to draw the bat and the <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect"><strong>SoundEffect</strong></a> to be played when the bat bounces off a wall.</p>
<h4 id="bat-randomize-velocity">Bat Randomize Velocity</h4>
<p>Currently, we have the <code>AssignRandomVelocity</code> method in the <code>GameScene</code> that we call to randomize the velocity of the bat after it has been eaten by the slime.  We can take this method out of the <code>GameScene</code> class and put it directly into the <code>Bat</code> class itself.</p>
<p>Add the following method to the <code>Bat</code> class after the constructor:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Randomizes the velocity of the bat.
/// &lt;/summary&gt;
public void RandomizeVelocity()
{
    // Generate a random angle
    float angle = (float)(Random.Shared.NextDouble() * MathHelper.TwoPi);

    // Convert the angle to a direction vector
    float x = (float)Math.Cos(angle);
    float y = (float)Math.Sin(angle);
    Vector2 direction = new Vector2(x, y);

    // Multiply the direction vector by the movement speed to get the
    // final velocity
    _velocity = direction * MOVEMENT_SPEED;
}
</code></pre><h4 id="bat-bounce">Bat Bounce</h4>
<p>We are also going to take the logic from the <code>GameScene</code> class that bounces the bat off the walls and move it into a dedicated method in the <code>Bat</code> class.</p>
<p>Add the following method to the <code>Bat</code> class after the <code>RandomizeVelocity</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Handles a bounce event when the bat collides with a wall or boundary.
/// &lt;/summary&gt;
/// &lt;param name=&quot;normal&quot;&gt;The normal vector of the surface the bat is bouncing against.&lt;/param&gt;
public void Bounce(Vector2 normal)
{
    Vector2 newPosition = Position;

    // Adjust the position based on the normal to prevent sticking to walls.
    if(normal.X != 0)
    {
        // We are bouncing off a vertical wall (left/right).
        // Move slightly away from the wall in the direction of the normal.
        newPosition.X += normal.X * (_sprite.Width * 0.1f);
    }

    if(normal.Y != 0)
    {
        // We are bouncing off a horizontal wall (top/bottom).
        // Move slightly way from the wall in the direction of the normal.
        newPosition.Y += normal.Y * (_sprite.Height * 0.1f);
    }

    // Apply the new position
    Position = newPosition;

    // Apply reflection based on the normal.
    _velocity = Vector2.Reflect(_velocity, normal);

    // Play the bounce sound effect.
    Core.Audio.PlaySoundEffect(_bounceSoundEffect);
}
</code></pre>
<p>This method only takes a single parameter, the <a href="../12_collision_detection/index.html#bounce-collision-response">normal vector</a> of the surface the bat is bouncing against.  Based on the X and Y components of the normal vector, we can determine which wall the bat bounced against and adjust the position of the bat so that it does not stick to the wall.</p>
<h4 id="bat-bounds">Bat Bounds</h4>
<p>Similar to the <a href="#slime-bounds"><code>Slime</code> class</a>, for the game scene to detect collision between the bat and other elements, we need a method to calculate the current collision bounds of the bat.</p>
<p>Add the following method to the <code>Bat</code> class after the <code>Bounce</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Returns a Circle value that represents collision bounds of the bat.
/// &lt;/summary&gt;
/// &lt;returns&gt;A Circle value.&lt;/returns&gt;
public Circle GetBounds()
{
    int x = (int)(Position.X + _sprite.Width * 0.5f);
    int y = (int)(Position.Y + _sprite.Height * 0.5f);
    int radius = (int)(_sprite.Width * 0.25f);

    return new Circle(x, y, radius);
}
</code></pre><h4 id="bat-update">Bat Update</h4>
<p>The <code>Bat</code> class will also need to be updated.</p>
<p>Add the following <code>Update</code> method to the <code>Bat</code> class after the <code>GetBounds</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Updates the bat.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the timing values for the current update cycle.&lt;/param&gt;
public void Update(GameTime gameTime)
{
    // Update the animated sprite
    _sprite.Update(gameTime);

    // Update the position of the bat based on the velocity.
    Position += _velocity;
}
</code></pre>
<p>This method simply updates the bat's <code>AnimatedSprite</code> to ensure animations occur and adjusts the position of the bat based on the current velocity.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The continuous movement of the bat contrasts with the grid-based interval movement of the slime, creating different gameplay dynamics for the player to consider.  This makes catching the bat challenging without requiring any complex behaviors.</p>
</div>
<h4 id="bat-draw">Bat Draw</h4>
<p>Finally, we need a method to draw the bat.</p>
<p>Add the following <code>Draw</code> method to the <code>Bat</code> class after the <code>Update</code> method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Draws the bat.
/// &lt;/summary&gt;
public void Draw()
{
    _sprite.Draw(Core.SpriteBatch, Position);
}
</code></pre>
<p>This method simply draws the bat's <code>AnimatedSprite</code> at the bat's current position.</p>
<p>With the <code>Bat</code> class complete, we have now encapsulated all the behavior needed for the collectible element in our game. The bat moves continuously around the screen and can bounce off walls, adding a twist on the classic snake-like mechanic by creating a target for the player to chase.</p>
<h2 id="conclusion">Conclusion</h2>
<div class="NOTE">
<h5>Note</h5>
<p>To the observant, you should notice that the main game screen has not been updated and therefore nothing has changed if we run the game at this point.  In the next chapter we will finalize the gameplay.</p>
</div>
<p>In this chapter, we have learned about and implemented the core mechanics of a class snake-like game.  We created:</p>
<ul>
<li>A <a href="#the-gamecontroller-class"><code>GameController</code></a> class that provides a unified input interface, separating game actions from specific input devices.</li>
<li>A <a href="#the-slimesegment-struct"><code>SlimeSegment</code></a> struct to efficiently store and manage individual segments of our snake-like character.</li>
<li>A <a href="#the-slime-class"><code>Slime</code></a> class that implements grid-based movement, segment management and self-collision detection.</li>
<li>A <a href="#the-bat-class"><code>Bat</code></a> class that serves as the collectible object with continuous movement and wall bouncing.</li>
</ul>
<p>These implementations encapsulate the core gameplay mechanics into reusable, maintainable objects.</p>
<p>In the next chapter, we will build on these mechanics by updating the <code>GameScene</code> to implement game state management and a new UI element for the game over state to create a complete game experience.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>Why must a snake-like game prevent the player from reversing direction?</p>
<div class="question-answer"><p>Preventing reverse movement is necessary because it would cause an immediate collision between the snake's head and the first body segment, resulting in an unfair game over.</p>
</div>
</li>
<li><p>How does the movement cycle for a snake work, and why is it more efficient than updating each segment individually?</p>
<div class="question-answer"><p>The snake movement cycle works by:</p>
<ol>
<li>Creating a copy of the head segment.</li>
<li>Positioning the copy one grid cell ahead in the current direction</li>
<li>Inserting this copy at the front of the segment collection</li>
<li>Removing the last segment.</li>
</ol>
<p>This approach is more efficient because it only requires manipulating two segments (adding a new head and removing the tail) regardless of how long the snake becomes, rather than iterating through and updating every segment individually.</p>
</div>
</li>
<li><p>What are the benefits of using the Input Abstraction pattern implemented in the <code>GameController</code> class?</p>
<div class="question-answer"><p>The Input Abstraction pattern provides several benefits:</p>
<ul>
<li>Input device independence, allowing the game to handle keyboard, gamepad, or other inputs through a unified interface</li>
<li>Simplified input handling through clean API calls rather than checking multiple input combinations</li>
<li>Easier implementation of key rebinding features by only needing to modify the GameController class</li>
<li>Consistent input logic defined in a single location</li>
<li>Better cross-platform compatibility by centralizing platform-specific input handling</li>
</ul>
</div>
</li>
<li><p>How does the implementation use <a href="xref:Microsoft.Xna.Framework.Vector2.Lerp(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)"><strong>Vector2.Lerp</strong></a> to create smooth visual movement, and why is this important?</p>
<div class="question-answer"><p>The implementation uses <a href="xref:Microsoft.Xna.Framework.Vector2.Lerp(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)"><strong>Vector2.Lerp</strong></a> to interpolate between a segment's current position (<code>At</code>) and its target position (<code>To</code>) based on a normalized movement progress value. This creates smooth visual movement by drawing the segments at intermediate positions between grid points rather than abruptly jumping from one grid position to the next.</p>
<p>This is important because it provides more fluid animation while maintaining the logical grid-based movement, enhancing the visual quality of the game without changing the core mechanics.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
