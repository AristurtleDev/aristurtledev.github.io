<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-17-scene-management">Chapter 17: Scene Management</h1>
<p class="text-secondary">Learn how to implement scene management to handle different game screens like menus, gameplay, and transitions between scenes.</p>
<p>In game development, a scene (sometimes called a screen or state) represents a distinct section of the game.  Each scene typically has its own update and draw logic, as well as its own set of game objects.  Common examples of scenes include title screens, menus, gameplay screens, game over screens, and more.  Scenes help organize the game's code by separating different parts of the game into self-contained modules.  This makes the code more manageable as the game grows in complexity and offers several advantages:</p>
<ol>
<li><strong>Improved organization</strong>: Each scene contains only the code and assets relevant to that part of the game.</li>
<li><strong>Memory management</strong>: Load assets only when needed and unload them when leaving a scene.</li>
<li><strong>Simplified state handling</strong>: Each scene maintains its own state without affecting others.</li>
<li><strong>Code reusability</strong>: Create reusable scene templates for common game screens.</li>
</ol>
<p>Our game logic is currently contained within the single <code>Game1</code> class.  Adding more screens to it would make the code harder to manage, so instead we need to start thinking about breaking it down into scenes.  In this chapter, you will:</p>
<ul>
<li>Learn the concept of scene management and its benefits</li>
<li>Create a base Scene class with a consistent lifecycle</li>
<li>Implement scene transitions using a manager</li>
<li>Create a title scene and gameplay scene for our game</li>
<li>Refactor our existing game to use the scene system</li>
</ul>
<p>We will being by first defining the lifecycle of a scene that will be followed.</p>
<h2 id="scene-lifecycle">Scene Lifecycle</h2>
<p>In Chapter 03, you learned the basic <a href="../03_the_game1_file/index.html#exploring-the-game1-class">lifecycle of the <code>Game</code> class</a>.  To be consistent, we can borrow from this lifecycle and adapt it for our scenes. The order of operations for this lifecycle will be:</p>
<ol>
<li>A scene is created and set as the active scene.</li>
<li>The active scene is first initialized and content loaded.</li>
<li>The active scene is updated and drawn each cycle.</li>
<li>When transitioning to a new scene, or when the scene ends:
<ol>
<li>The current scene is unloaded and disposed of.</li>
<li>The new scene is initialized and content loaded.</li>
<li>The new scene becomes the active scene and the cycle begins again until the game is told to exit.</li>
</ol>
</li>
</ol>
<h2 id="the-scene-base-class">The Scene Base Class</h2>
<p>The base <code>Scene</code> class is an abstract class for scenes that provides common functionality for all scenes.  In our actual game, we'll create concrete implementations of this, like a title scene.</p>
<p>To get started, in the <em>MonoGameLibrary</em> project:</p>
<ol>
<li><p>Create a new directory named <em>Scenes</em>.</p>
</li>
<li><p>Add a new class file named <em>Scene.cs</em> to the <em>Scenes</em> directory you just created.</p>
</li>
<li><p>Add the following code as the initial structure for the class:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;

namespace MonoGameLibrary.Scenes;

public abstract class Scene : IDisposable
{

}
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Just like with the <code>AudioController</code> in <a href="../14_audio_controller/index.md#audiocontroller-idisposable-implementation">Chapter 14</a>, each <code>Scene</code> implements the <code>IDisposable</code> interface.  This provides a standardized in method to release the resources held by a scene when it is no longer needed.</p>
</div>
</li>
</ol>
<h3 id="scene-properties">Scene Properties</h3>
<p>Add the following properties to the <code>Scene</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets the ContentManager used for loading scene-specific assets.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Assets loaded through this ContentManager will be automatically unloaded when this scene ends.
/// &lt;/remarks&gt;
protected ContentManager Content { get; }

/// &lt;summary&gt;
/// Gets a value that indicates if the scene has been disposed of.
/// &lt;/summary&gt;
public bool IsDisposed { get; private set; }
</code></pre>
<ul>
<li>The <code>Content</code> property is the scene's personal <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> that can be used to load scene specific content that will be unloaded when the scene ends.  This helps manage memory usage by only loading what is needed for a specific scene.</li>
<li>The <code>IsDisposed</code> property is used to track if the scene has been disposed of since it implements the <code>IDisposable</code> interface.</li>
</ul>
<h3 id="scene-constructor">Scene Constructor</h3>
<p>Add the following constructor and finalizer to the <code>Scene</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new scene instance.
/// &lt;/summary&gt;
public Scene()
{
    // Create a content manager for the scene
    Content = new ContentManager(Core.Content.ServiceProvider);

    // Set the root directory for content to the same as the root directory
    // for the game's content.
    Content.RootDirectory = Core.Content.RootDirectory;
}

// Finalizer, called when object is cleaned up by garbage collector.
~Scene() =&gt; Dispose(false);
</code></pre>
<ul>
<li>The constructor initializes the scene's content manager and sets the root directory to match that of the base game's content manager.</li>
<li>The finalizer is called by the garbage collector automatically when a scene object is collected which just calls the <code>Dispose</code> method to ensure resources are disposed of properly.</li>
</ul>
<h3 id="scene-methods">Scene Methods</h3>
<p>Add the following methods to the <code>Scene</code> class:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Initializes the scene.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// When overriding this in a derived class, ensure that base.Initialize()
/// still called as this is when LoadContent is called.
/// &lt;/remarks&gt;
public virtual void Initialize()
{
    LoadContent();
}

/// &lt;summary&gt;
/// Override to provide logic to load content for the scene.
/// &lt;/summary&gt;
public virtual void LoadContent() { }

/// &lt;summary&gt;
/// Unloads scene-specific content.
/// &lt;/summary&gt;
public virtual void UnloadContent()
{
    Content.Unload();
}

/// &lt;summary&gt;
/// Updates this scene.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the timing values for the current frame.&lt;/param&gt;
public virtual void Update(GameTime gameTime) { }

/// &lt;summary&gt;
/// Draws this scene.
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the timing values for the current frame.&lt;/param&gt;
public virtual void Draw(GameTime gameTime) { }
</code></pre>
<p>These methods are setup similar to how the <code>Game</code> class works to keep the workflow consistent:</p>
<ul>
<li><code>Initialize</code> is called only once when the scene becomes the active scene.  It can be overridden by the derived class to provide scene specific initialization logic.  It also calls the <code>LoadContent</code> method the same way the <code>Game</code> class is done for consistency.</li>
<li><code>LoadContent</code> is called only once, at the end of the <code>Initialize</code> method.  It can be overridden by the derived class to load scene specific content.</li>
<li><code>UnloadContent</code> is called only once when a scene is ending due to a transition to a new scene.  It can be overridden by the derived class to perform unloading of any scene specific content.</li>
<li><code>Update</code> is called once at the start of every game cycle. It can be overidden to provide the update logic for the scene.</li>
<li><code>Draw</code> is called once every game cycle, directly after <code>Update</code>.  It can be overridden to provide the draw logic for the scene.</li>
</ul>
<h4 id="idisposable-implementation">IDisposable Implementation</h4>
<p>Add the following methods to the <code>Scene</code> class to complete the implementation of the <code>IDisposable</code> interface:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Disposes of this scene.
/// &lt;/summary&gt;
public void Dispose()
{
    Dispose(true);
    GC.SuppressFinalize(this);
}

/// &lt;summary&gt;
/// Disposes of this scene.
/// &lt;/summary&gt;
/// &lt;param name=&quot;disposing&quot;&gt;'
/// Indicates whether managed resources should be disposed.  This value is only true when called from the main
/// Dispose method.  When called from the finalizer, this will be false.
/// &lt;/param&gt;
protected virtual void Dispose(bool disposing)
{
    if (IsDisposed)
    {
        return;
    }

    if (disposing)
    {
        UnloadContent();
        Content.Dispose();
    }
}
</code></pre><h2 id="scene-management">Scene Management</h2>
<p>With the base <code>Scene</code> class defined, the <code>Core</code> class needs to be updated to handle management of the scenes, including update, drawing, and changing scenes.  Open the <em>Core.cs</em> file in the <em>MonoGameLibrary</em> project and make the following changes:</p>
<pre><code class="lang-csharp" highlight-lines="8,21-25,144-155,160-169,171-179,181-205">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary.Audio;
using MonoGameLibrary.Input;
using MonoGameLibrary.Scenes;

namespace MonoGameLibrary;

public class Core : Game
{
    internal static Core s_instance;

    /// &lt;summary&gt;
    /// Gets a reference to the Core instance.
    /// &lt;/summary&gt;
    public static Core Instance =&gt; s_instance;

    // The scene that is currently active.
    private static Scene s_activeScene;

    // The next scene to switch to, if there is one.
    private static Scene s_nextScene;

    /// &lt;summary&gt;
    /// Gets the graphics device manager to control the presentation of graphics.
    /// &lt;/summary&gt;
    public static GraphicsDeviceManager Graphics { get; private set; }

    /// &lt;summary&gt;
    /// Gets the graphics device used to create graphical resources and perform primitive rendering.
    /// &lt;/summary&gt;
    public static new GraphicsDevice GraphicsDevice { get; private set; }

    /// &lt;summary&gt;
    /// Gets the sprite batch used for all 2D rendering.
    /// &lt;/summary&gt;
    public static SpriteBatch SpriteBatch { get; private set; }

    /// &lt;summary&gt;
    /// Gets the content manager used to load global assets.
    /// &lt;/summary&gt;
    public static new ContentManager Content { get; private set; }

    /// &lt;summary&gt;
    /// Gets a reference to to the input management system.
    /// &lt;/summary&gt;
    public static InputManager Input { get; private set; }

    /// &lt;summary&gt;
    /// Gets or Sets a value that indicates if the game should exit when the esc key on the keyboard is pressed.
    /// &lt;/summary&gt;
    public static bool ExitOnEscape { get; set; }

    /// &lt;summary&gt;
    /// Gets a reference to the audio control system.
    /// &lt;/summary&gt;
    public static AudioController Audio { get; private set; }

    /// &lt;summary&gt;
    /// Creates a new Core instance.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;title&quot;&gt;The title to display in the title bar of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;width&quot;&gt;The initial width, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;height&quot;&gt;The initial height, in pixels, of the game window.&lt;/param&gt;
    /// &lt;param name=&quot;fullScreen&quot;&gt;Indicates if the game should start in fullscreen mode.&lt;/param&gt;
    public Core(string title, int width, int height, bool fullScreen)
    {
        // Ensure that multiple cores are not created.
        if (s_instance != null)
        {
            throw new InvalidOperationException($&quot;Only a single Core instance can be created&quot;);
        }

        // Store reference to engine for global member access.
        s_instance = this;

        // Create a new graphics device manager.
        Graphics = new GraphicsDeviceManager(this);

        // Set the graphics defaults
        Graphics.PreferredBackBufferWidth = width;
        Graphics.PreferredBackBufferHeight = height;
        Graphics.IsFullScreen = fullScreen;

        // Apply the graphic presentation changes
        Graphics.ApplyChanges();

        // Set the window title
        Window.Title = title;

        // Set the core's content manager to a reference of hte base Game's
        // content manager.
        Content = base.Content;

        // Set the root directory for content
        Content.RootDirectory = &quot;Content&quot;;

        // Mouse is visible by default
        IsMouseVisible = true;
    }

    protected override void Initialize()
    {
        base.Initialize();

        // Set the core's graphics device to a reference of the base Game's
        // graphics device.
        GraphicsDevice = base.GraphicsDevice;

        // Create the sprite batch instance.
        SpriteBatch = new SpriteBatch(GraphicsDevice);

        // Create a new input manager
        Input = new InputManager();

        // Create a new audio controller.
        Audio = new AudioController();
    }

    protected override void UnloadContent()
    {
        // Dispose of the audio controller.
        Audio.Dispose();

        base.UnloadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        // Update the input manager.
        Input.Update(gameTime);

        // Update the audio controller.
        Audio.Update();

        if (ExitOnEscape &amp;&amp; Input.Keyboard.WasKeyJustPressed(Keys.Escape))
        {
            Exit();
        }

        // if there is a next scene waiting to be switch to, then transition
        // to that scene
        if (s_nextScene != null)
        {
            TransitionScene();
        }

        // If there is an active scene, update it.
        if (s_activeScene != null)
        {
            s_activeScene.Update(gameTime);
        }

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        // If there is an active scene, draw it.
        if (s_activeScene != null)
        {
            s_activeScene.Draw(gameTime);
        }

        base.Draw(gameTime);
    }

    public static void ChangeScene(Scene next)
    {
        // Only set the next scene value if it is not the same
        // instance as the currently active scene.
        if (s_activeScene != next)
        {
            s_nextScene = next;
        }
    }

    private static void TransitionScene()
    {
        // If there is an active scene, dispose of it
        if (s_activeScene != null)
        {
            s_activeScene.Dispose();
        }

        // Force the garbage collector to collect to ensure memory is cleared
        GC.Collect();

        // Change the currently active scene to the new scene
        s_activeScene = s_nextScene;

        // Null out the next scene value so it doesn't trigger a change over and over.
        s_nextScene = null;

        // If the active scene now is not null, initialize it.
        // Remember, just like with Game, the Initialize call also calls the
        // Scene.LoadContent
        if (s_activeScene != null)
        {
            s_activeScene.Initialize();
        }
    }
}
</code></pre>
<p>The key changes here are:</p>
<ol>
<li>The <code>using MonoGameLibrary.Scenes;</code> using directive was added so we have access to the <code>Scene</code> class.</li>
<li>The fields <code>_activeScene</code> and <code>_nextScene</code> were added to track which scene is currently active and which scene, if any, to switch to.</li>
<li>In <code>Update</code>:
<ol>
<li>A check is made to see if there is a next scene, and if so, <code>TransitionScene</code> is called to gracefully switch from the current to the next.</li>
<li>A check is made to see if there is an active scene, and if so, updates it.</li>
</ol>
</li>
<li>An override for the <code>Draw</code> method was added where a check is made to see if there is an active scene, and if so, draws it.</li>
<li>The <code>ChangeScene</code> method was added which can be called when we want to tell the core to change from one scene to another one.</li>
<li>The <code>TransitionScene</code> method was add that gracefully transitions from the current scene to the next scene by
<ol>
<li>A check is made to see if there is an active scene, and if so, disposes it.</li>
<li>The garbage collector is told to perform a collection to clear out memory from the disposal of the current scene.</li>
<li>The next scene is set as the current scene.</li>
<li>A check is made to see if there is now a current scene, and if so, initializes it.</li>
</ol>
</li>
</ol>
<div class="TIP">
<h5>Tip</h5>
<p>Notice that we use a two-step process for scene transitions with separate <code>_activeScene</code> and <code>_nextScene</code> fields. This design allows the current scene to complete its update/draw cycle before the transition occurs, preventing potential issues that could arise from changing scenes in the middle of processing. The actual transition happens at a controlled point in the game loop, ensuring clean disposal of the old scene before initializing the new one.</p>
</div>
<h2 id="updating-the-game">Updating the Game</h2>
<p>With the scene architecture in place, the game can now be updated so that it is broken down into scenes. We'll create two scenes; a title scene and a gameplay scene.</p>
<h3 id="the-title-scene">The Title Scene</h3>
<p>The title scene serves as the game's initial starting point, making the first impression on the player when they first launch the game.  For our game, this scene will display stylized text for the title of the game and a prompt for an action for the user to perform to start the game.  The stylized text is a graphic that was created and added to the texture atlas which features the title of the game with a drop shadow effect on the text.  So first, let's update the texture atlas to the new version with the title graphic.  Download the new texture atlas below by right-clicking the following image and saving it as <em>atlas.png</em> in the <em>Content/images</em> directory of the game project, overwriting the existing one:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/atlas.png" alt="Figure 17-1: The texture atlas for our game updated to include the title sprite"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 17-1: The texture atlas for our game updated to include the title sprite</strong></td>
</tr>
</tbody>
</table>
<p>Next, open the <em>atlas-definition.xml</em> file and add the region for the title sprite:</p>
<pre><code class="lang-xml" highlight-lines="10">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextureAtlas&gt;
    &lt;Texture&gt;images/atlas&lt;/Texture&gt;
    &lt;Regions&gt;
        &lt;Region name=&quot;slime-1&quot; x=&quot;320&quot; y=&quot;0&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
        &lt;Region name=&quot;slime-2&quot; x=&quot;320&quot; y=&quot;80&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
        &lt;Region name=&quot;bat-1&quot; x=&quot;320&quot; y=&quot;160&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
        &lt;Region name=&quot;bat-2&quot; x=&quot;320&quot; y=&quot;240&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
        &lt;Region name=&quot;bat-3&quot; x=&quot;400&quot; y=&quot;0&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt;
        &lt;Region name=&quot;title-card&quot; x=&quot;0&quot; y=&quot;320&quot; width=&quot;751&quot; height=&quot;240&quot; /&gt;
    &lt;/Regions&gt;
    &lt;Animations&gt;
        &lt;Animation name=&quot;slime-animation&quot; delay=&quot;200&quot;&gt;
            &lt;Frame region=&quot;slime-1&quot; /&gt;
            &lt;Frame region=&quot;slime-2&quot; /&gt;
        &lt;/Animation&gt;
        &lt;Animation name=&quot;bat-animation&quot; delay=&quot;200&quot;&gt;
            &lt;Frame region=&quot;bat-1&quot; /&gt;
            &lt;Frame region=&quot;bat-2&quot; /&gt;
            &lt;Frame region=&quot;bat-1&quot; /&gt;
            &lt;Frame region=&quot;bat-3&quot; /&gt;
        &lt;/Animation&gt;
    &lt;/Animations&gt;
&lt;/TextureAtlas&gt;
</code></pre>
<p>With the atlas now updated, create the <code>TitleScene</code> class file.  In the main game project:</p>
<ol>
<li><p>Create a new directory named <em>Scenes</em>.  We'll put all of our game specific scenes here.</p>
</li>
<li><p>Add a new class file named <em>TitleScene.cs</em> to the <em>Scenes</em> directory you just created.</p>
</li>
<li><p>Add the following code as the initial structure for the class.</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Scenes;

namespace DungeonSlime.Scenes;

public class TitleScene : Scene
{

}
</code></pre></li>
</ol>
<h4 id="title-scene-fields">Title Scene Fields</h4>
<p>Add the following fields to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">private const string PRESS_ENTER = &quot;Press Enter To Start&quot;;

// The font to use to render normal text.
private SpriteFont _font;

// The sprite to draw for the stylized title
private Sprite _titleSprite;

// The position to draw the title sprite at.
private Vector2 _titlePos;

// The position to draw the press enter text at.
private Vector2 _pressEnterPos;

// The origin to set for the press enter text when drawing it.
private Vector2 _pressEnterOrigin;
</code></pre>
<ul>
<li>The <code>PRESS_ENTER</code> constant is the text we'll draw for the press enter prompt for the user.</li>
<li>The <code>_font</code> field stores a reference to the sprite font we'll load to render the press enter prompt with.</li>
<li>The <code>_titleSprite</code> field stores a reference the sprite we'll render for the stylized title from the texture atlas</li>
<li>The <code>_titlePos</code> and <code>_pressEnterPos</code> fields store the precalculated positions for the title sprite and the press enter prompt text when they are drawn.  Since they are stationary, we can just calculate the positions once and store it instead of calculating it each frame.</li>
<li>The <code>_pressEnterOrigin</code> field stores the precalculated origin for hte press enter prompt text when it is drawn.  Like with the position, we only need to calculate this once and store it instead of calculating it each frame.</li>
</ul>
<h4 id="title-scene-methods">Title Scene Methods</h4>
<p>The <code>TitleScene</code> class will override the various methods from the base <code>Scene</code> class that it derives from to provide the initialization, content loading, update, and drawing logic.</p>
<h5 id="title-scene-initialize">Title Scene Initialize</h5>
<p>Add the following override for the <code>Initialize</code> method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">public override void Initialize()
{
    // LoadContent is called during base.Initialize().
    base.Initialize();

    // While on the title screen, we can enable exit on escape so the player
    // can close the game by pressing the escape key.
    Core.ExitOnEscape = true;

    // Get the bounds of the screen for position calculations
    Rectangle screenBounds = Core.GraphicsDevice.PresentationParameters.Bounds;

    // Precalculate the positions and origins for texts and the slime sprite
    // so we're not calculating it every draw frame.
    _titlePos = new Vector2(
        screenBounds.Width * 0.5f,
        80 + _titleSprite.Height * 0.5f);

    // Center the origin of the title sprite.
    _titleSprite.CenterOrigin();

    // Precalculate the position of for the press enter text so that it is
    // centered horizontally and place 100 pixels above the bottom of the
    // screen.
    _pressEnterPos = new Vector2(
        screenBounds.Width * 0.5f,
        screenBounds.Height - 100
    );

    // Precalculate the center origin of the press enter text.
    Vector2 pressEnterSize = _font.MeasureString(PRESS_ENTER);
    _pressEnterOrigin = pressEnterSize * 0.5f;
}
</code></pre>
<ul>
<li>We set the <code>Core.ExitOnEscape</code> to true to allow players to exit the game when on the title screen by pressing the escape key.</li>
<li>The bounds of the screen is captures by using the <code>Core.GraphicsDevice.PresentationParameters.Bounds</code> value.</li>
<li>The position to draw the title sprite is precalculated so that it will be centered horizontally and 80px down from the top of the screen.  The origin is set to center.</li>
<li>The position to draw the press enter prompt is precalculated so that it will be centered horizontally and 100 px above the bottom of the screen.  The string is measured and used to center the origin for the text.</li>
</ul>
<h5 id="title-scene-loadcontent">Title Scene LoadContent</h5>
<p>Add the following override for the <code>LoadContent</code> method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">public override void LoadContent()
{
    // Load the font for the standard txt.
    _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/gameFont&quot;);

    // Create a texture atlas from the XML configuration file.
    TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);

    _titleSprite = atlas.CreateSprite(&quot;title-card&quot;);
}
</code></pre>
<ul>
<li>The font used to draw the press enter prompt is loaded.</li>
<li>The texture atlas is loaded using the XML configuration file.</li>
<li>The <code>_titleSprite</code> is generated from the <code>&quot;title-card&quot;</code> region in the atlas.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Recall from <a href="../05_content_pipeline/index.html#contentmanager-methods">Chapter 05</a> that when a <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> loads an asset for the first time, it caches it internally and the subsequent calls to load that asset will return the cached one instead of performing another disk read.</p>
<p>By using a global content manager here to load assets that are used in multiple scenes, when they loaded in a different scene later, the cached version is returned instead of having to do another disk read, making the content loading more efficient.</p>
</div>
<h5 id="title-scene-update">Title Scene Update</h5>
<p>Add the following override for the <code>Update</code> method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">public override void Update(GameTime gameTime)
{
    // If the user presses enter, switch to the game scene.
    if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Enter))
    {
        Core.ChangeScene(new GameScene());
    }
}
</code></pre>
<ul>
<li>A check is made to see if the enter key is pressed, and if so, the <code>Core</code> is told to change to the game scene.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>Your editor might show an error here since we haven't created the <code>GameScene</code> class yet.  We'll create it in a moment after finishing the title scene.</p>
</div>
<h5 id="title-scene-draw">Title Scene Draw</h5>
<p>Add the following override for the <code>Draw</code> method to the <code>TitleScene</code> class:</p>
<pre><code class="lang-csharp">public override void Draw(GameTime gameTime)
{
    Core.GraphicsDevice.Clear(new Color(32, 40, 78, 255));

    // Begin the sprite batch to prepare for rendering.
    Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

    // Draw that title sprite
    _titleSprite.Draw(Core.SpriteBatch, _titlePos);

    // Draw the press enter text
    Core.SpriteBatch.DrawString(_font, PRESS_ENTER, _pressEnterPos, Color.White, 0.0f, _pressEnterOrigin, 1.0f, SpriteEffects.None, 0.0f);

    // Always end the sprite batch when finished.
    Core.SpriteBatch.End();
}
</code></pre>
<ul>
<li>The back buffer is cleared.</li>
<li>The title sprite is drawn at its precalculated position.</li>
<li>The press enter prompt is drawn at its precalculated position.</li>
</ul>
<h3 id="the-game-scene">The Game Scene</h3>
<p>The Game Scene will contain our actual gameplay logic. This scene will handle updating and rendering the slime that the player controls, the bat the slime can eat, collision detection, score tracking, and input handling. Most of this logic has already been implemented in our <code>Game1</code> class in previous chapters, but now we'll move it into a dedicated scene class. In the <em>Scenes</em> directory:</p>
<ol>
<li><p>Add a new class file named <em>GameScene.cs</em>.</p>
</li>
<li><p>Add the following code as the initial structure for the class:</p>
<pre><code class="lang-csharp">using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;
using MonoGameLibrary.Input;
using MonoGameLibrary.Scenes;

namespace DungeonSlime.Scenes;

public class GameScene : Scene
{

}
</code></pre></li>
</ol>
<h4 id="game-scene-fields">Game Scene Fields</h4>
<p>Add the following fields to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">// Defines the slime animated sprite.
private AnimatedSprite _slime;

// Defines the bat animated sprite.
private AnimatedSprite _bat;

// Tracks the position of the slime.
private Vector2 _slimePosition;

// Speed multiplier when moving.
private const float MOVEMENT_SPEED = 5.0f;

// Tracks the position of the bat.
private Vector2 _batPosition;

// Tracks the velocity of the bat.
private Vector2 _batVelocity;

// Defines the tilemap to draw.
private Tilemap _tilemap;

// Defines the bounds of the room that the slime and bat are contained within.
private Rectangle _roomBounds;

// The sound effect to play when the bat bounces off the edge of the screen.
private SoundEffect _bounceSoundEffect;

// The sound effect to play when the slime eats a bat.
private SoundEffect _collectSoundEffect;

// The SpriteFont Description used to draw text
private SpriteFont _font;

// Tracks the players score.
private int _score;

// Defines the position to draw the score text at.
private Vector2 _scoreTextPosition;

// Defines the origin used when drawing the score text.
private Vector2 _scoreTextOrigin;
</code></pre>
<ul>
<li>The <code>_slime</code> and <code>_bat</code> fields store the animated sprites for the player controlled slime and the bat.</li>
<li>The <code>_slimePosition</code> and <code>_batPosition</code> fields track the current position of the slime and bat.</li>
<li>The <code>MOVEMENT_SPEED</code> constant defines the base movement speed for both the slime and bat.</li>
<li>The <code>_batVelocity</code> field tracks the current velocity of the bat as it moves around the screen.</li>
<li>The <code>_tilemap</code> field stores the tilemap that we'll load and draw for the level background environment.</li>
<li>The <code>_roomBounds</code> field defines a rectangular boundary that represents the boundary of the room that the slime and bat stays within.</li>
<li>The <code>_bounceSoundEffect</code> and <code>_collectSoundEffect</code> fields store the sound effects to play when the bat bounces off a screen edge or is eaten by the slime.</li>
<li>The <code>_font</code> field stores the font used to display the player's score.</li>
<li>The <code>_score</code> field tracks the player's current score, which increases when the slime eats a bat.</li>
<li>The <code>_scoreTextPosition</code> and <code>_scoreTextOrigin</code> defines the position and origin to use when drawing the score text.</li>
</ul>
<h4 id="game-scene-methods">Game Scene Methods</h4>
<p>The <code>GameScene</code> class will override the various methods from the base <code>Scene</code> class that it derives from to provide the initialization, content loading, update, and drawing logic.</p>
<h5 id="game-scene-initialize">Game Scene Initialize</h5>
<p>Add the following override for the <code>Initialize</code> method to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">public override void Initialize()
{
    // LoadContent is called during base.Initialize().
    base.Initialize();

    // During the game scene, we want to disable exit on escape. Instead,
    // the escape key will be used to return back to the title screen
    Core.ExitOnEscape = false;

    Rectangle screenBounds = Core.GraphicsDevice.PresentationParameters.Bounds;

    _roomBounds = new Rectangle(
        _tilemap.TileSize,
        _tilemap.TileSize,
        screenBounds.Width - _tilemap.TileSize * 2,
        screenBounds.Height - _tilemap.TileSize * 2
    );

    // Initial slime position will be the center tile of the tile map.
    int centerRow = _tilemap.Rows / 2;
    int centerColumn = _tilemap.Columns / 2;
    _slimePosition = new Vector2(centerColumn, centerRow) * _tilemap.TileSize;

    // Initial bat position will the in the top left corner of the room
    _batPosition = new Vector2(_roomBounds.Left, _roomBounds.Top);

    // Set the position of the score text to align to the left edge of the
    // room bounds, and to vertically be at the center of the first tile.
    _scoreTextPosition = new Vector2(_roomBounds.Left, _tilemap.TileSize * 0.5f);

    // Set the origin of the text so it's left-centered.
    float scoreTextYOrigin = _font.MeasureString(&quot;Score&quot;).Y * 0.5f;
    _scoreTextOrigin = new Vector2(0, scoreTextYOrigin);

    // Assign the initial random velocity to the bat.
    AssignRandomBatVelocity();
}
</code></pre>
<ul>
<li>We set <code>Core.ExitOnEscape</code> to false because in the gameplay scene, we want to handle the escape key differently; instead of exiting the game, it will return to the title screen.</li>
<li>The room bounds is calculated using the bounds of the screen and adjusting that so that it shrinks by one tile width and height on each edge, which will match with the tilemap wall boundary.</li>
<li>The slime's initial position is set to be the center tile by calculating the center row and column.</li>
<li>The bat's initial position is placed at the top left of the room bounds.</li>
<li>The position and origin of the score text is precalculated.  The height of the text is measured to properly calculate the center origin for vertical positioning.</li>
<li>The <code>AssignRandomBatVelocity</code> method is called to give the bat its initial velocity.</li>
</ul>
<h5 id="game-scene-loadcontent">Game Scene LoadContent</h5>
<p>Add the following override for the <code>LoadContent</code> method to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">public override void LoadContent()
{
    // Create the texture atlas from the XML configuration file
    TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);

    // Create the slime animated sprite from the atlas.
    _slime = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);

    // Create the bat animated sprite from the atlas.
    _bat = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);

    // Load the tilemap from the XML configuration file.
    _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);

    // Load the bounce sound effect
    _bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

    // Load the collect sound effect
    _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

    // Load the font
    _font = Core.Content.Load&lt;SpriteFont&gt;(&quot;fonts/gameFont&quot;);
}
</code></pre>
<ul>
<li>The texture atlas is loaded using the global content manager, and the slime and bat animated sprites are created from it.</li>
<li>The tilemap is loaded using the scene's content manager since they are specific to the gameplay scene.</li>
<li>The sound effects are loaded using the scene's content manager since they are specific to the gameplay scene.</li>
<li>The font is loaded using the global content manager since it is used in multiple scenes.</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>Notice how we're following a consistent pattern across scenes: global assets are loaded with <code>Core.Instance.Content</code> while scene-specific assets are loaded with the scene's <code>Content</code> property.</p>
</div>
<h5 id="game-scene-update">Game Scene Update</h5>
<p>Add the following override for the <code>Update</code> method to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">public override void Update(GameTime gameTime)
{
    // Update the slime animated sprite.
    _slime.Update(gameTime);

    // Update the bat animated sprite.
    _bat.Update(gameTime);

    // Check for keyboard input and handle it.
    CheckKeyboardInput();

    // Check for gamepad input and handle it.
    CheckGamePadInput();

    // Creating a bounding circle for the slime
    Circle slimeBounds = new Circle(
        (int)(_slimePosition.X + (_slime.Width * 0.5f)),
        (int)(_slimePosition.Y + (_slime.Height * 0.5f)),
        (int)(_slime.Width * 0.5f)
    );

    // Use distance based checks to determine if the slime is within the
    // bounds of the game screen, and if it's outside that screen edge,
    // move it back inside.
    if (slimeBounds.Left &lt; _roomBounds.Left)
    {
        _slimePosition.X = _roomBounds.Left;
    }
    else if (slimeBounds.Right &gt; _roomBounds.Right)
    {
        _slimePosition.X = _roomBounds.Right - _slime.Width;
    }

    if (slimeBounds.Top &lt; _roomBounds.Top)
    {
        _slimePosition.Y = _roomBounds.Top;
    }
    else if (slimeBounds.Bottom &gt; _roomBounds.Bottom)
    {
        _slimePosition.Y = _roomBounds.Bottom - _slime.Height;
    }

    // Calculate the new position of the bat based on the velocity
    Vector2 newBatPosition = _batPosition + _batVelocity;

    // Create a bounding circle for the bat
    Circle batBounds = new Circle(
        (int)(newBatPosition.X + (_bat.Width * 0.5f)),
        (int)(newBatPosition.Y + (_bat.Height * 0.5f)),
        (int)(_bat.Width * 0.5f)
    );

    Vector2 normal = Vector2.Zero;

    // Use distance based checks to determine if the bat is within the
    // bounds of the game screen, and if it's outside that screen edge,
    // reflect it about the screen edge normal
    if (batBounds.Left &lt; _roomBounds.Left)
    {
        normal.X = Vector2.UnitX.X;
        newBatPosition.X = _roomBounds.Left;
    }
    else if (batBounds.Right &gt; _roomBounds.Right)
    {
        normal.X = -Vector2.UnitX.X;
        newBatPosition.X = _roomBounds.Right - _bat.Width;
    }

    if (batBounds.Top &lt; _roomBounds.Top)
    {
        normal.Y = Vector2.UnitY.Y;
        newBatPosition.Y = _roomBounds.Top;
    }
    else if (batBounds.Bottom &gt; _roomBounds.Bottom)
    {
        normal.Y = -Vector2.UnitY.Y;
        newBatPosition.Y = _roomBounds.Bottom - _bat.Height;
    }

    // If the normal is anything but Vector2.Zero, this means the bat had
    // moved outside the screen edge so we should reflect it about the
    // normal.
    if (normal != Vector2.Zero)
    {
        _batVelocity = Vector2.Reflect(_batVelocity, normal);

        // Play the bounce sound effect
        Core.Audio.PlaySoundEffect(_bounceSoundEffect);
    }

    _batPosition = newBatPosition;

    if (slimeBounds.Intersects(batBounds))
    {
        // Choose a random row and column based on the total number of each
        int column = Random.Shared.Next(1, _tilemap.Columns - 1);
        int row = Random.Shared.Next(1, _tilemap.Rows - 1);

        // Change the bat position by setting the x and y values equal to
        // the column and row multiplied by the width and height.
        _batPosition = new Vector2(column * _bat.Width, row * _bat.Height);

        // Assign a new random velocity to the bat
        AssignRandomBatVelocity();

        // Play the collect sound effect
        Core.Audio.PlaySoundEffect(_collectSoundEffect);

        // Increase the player's score.
        _score += 100;
    }
}
</code></pre>
<ul>
<li>The animated sprites for the slime and bat are updated.</li>
<li>Input from keyboard and gamepad is checked with dedicated methods <code>CheckKeyboardInput</code> and <code>CheckGamePadInput</code>.</li>
<li>Collision detection is performed to:
<ul>
<li>Keep the slime within the room bounds.</li>
<li>Make the bat bounce off edges of the room bounds.</li>
<li>Detect when the slime eats the bat.</li>
</ul>
</li>
<li>When the slime eats the bat, the bat respawns in a random location within the room bounds, given a new velocity, the collect sound is played, and the score is increased.</li>
</ul>
<h5 id="game-scene-helper-methods">Game Scene Helper Methods</h5>
<p>Add these helper methods to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">private void AssignRandomBatVelocity()
{
    // Generate a random angle
    float angle = (float)(Random.Shared.NextDouble() * Math.PI * 2);

    // Convert angle to a direction vector
    float x = (float)Math.Cos(angle);
    float y = (float)Math.Sin(angle);
    Vector2 direction = new Vector2(x, y);

    // Multiply the direction vector by the movement speed
    _batVelocity = direction * MOVEMENT_SPEED;
}

private void CheckKeyboardInput()
{
    // Get a reference to the keyboard inof
    KeyboardInfo keyboard = Core.Input.Keyboard;

    // If the escape key is pressed, return to the title screen
    if (Core.Input.Keyboard.WasKeyJustPressed(Keys.Escape))
    {
        Core.ChangeScene(new TitleScene());
    }

    // If the space key is held down, the movement speed increases by 1.5
    float speed = MOVEMENT_SPEED;
    if (keyboard.IsKeyDown(Keys.Space))
    {
        speed *= 1.5f;
    }

    // If the W or Up keys are down, move the slime up on the screen.
    if (keyboard.IsKeyDown(Keys.W) || keyboard.IsKeyDown(Keys.Up))
    {
        _slimePosition.Y -= speed;
    }

    // if the S or Down keys are down, move the slime down on the screen.
    if (keyboard.IsKeyDown(Keys.S) || keyboard.IsKeyDown(Keys.Down))
    {
        _slimePosition.Y += speed;
    }

    // If the A or Left keys are down, move the slime left on the screen.
    if (keyboard.IsKeyDown(Keys.A) || keyboard.IsKeyDown(Keys.Left))
    {
        _slimePosition.X -= speed;
    }

    // If the D or Right keys are down, move the slime right on the screen.
    if (keyboard.IsKeyDown(Keys.D) || keyboard.IsKeyDown(Keys.Right))
    {
        _slimePosition.X += speed;
    }

    // If the M key is pressed, toggle mute state for audio.
    if (keyboard.WasKeyJustPressed(Keys.M))
    {
        Core.Audio.ToggleMute();
    }

    // If the + button is pressed, increase the volume.
    if (keyboard.WasKeyJustPressed(Keys.OemPlus))
    {
        Core.Audio.IncreaseVolume(0.1f);
    }

    // If the - button was pressed, decrease the volume.
    if (keyboard.WasKeyJustPressed(Keys.OemMinus))
    {
        Core.Audio.DecreaseVolume(0.1f);
    }
}

private void CheckGamePadInput()
{
    // Get the gamepad info for gamepad one.
    GamePadInfo gamePadOne = Core.Input.GamePads[(int)PlayerIndex.One];

    // If the A button is held down, the movement speed increases by 1.5
    // and the gamepad vibrates as feedback to the player.
    float speed = MOVEMENT_SPEED;
    if (gamePadOne.IsButtonDown(Buttons.A))
    {
        speed *= 1.5f;
        GamePad.SetVibration(PlayerIndex.One, 1.0f, 1.0f);
    }
    else
    {
        GamePad.SetVibration(PlayerIndex.One, 0.0f, 0.0f);
    }

    // Check thumbstick first since it has priority over which gamepad input
    // is movement.  It has priority since the thumbstick values provide a
    // more granular analog value that can be used for movement.
    if (gamePadOne.LeftThumbStick != Vector2.Zero)
    {
        _slimePosition.X += gamePadOne.LeftThumbStick.X * speed;
        _slimePosition.Y -= gamePadOne.LeftThumbStick.Y * speed;
    }
    else
    {
        // If DPadUp is down, move the slime up on the screen.
        if (gamePadOne.IsButtonDown(Buttons.DPadUp))
        {
            _slimePosition.Y -= speed;
        }

        // If DPadDown is down, move the slime down on the screen.
        if (gamePadOne.IsButtonDown(Buttons.DPadDown))
        {
            _slimePosition.Y += speed;
        }

        // If DPapLeft is down, move the slime left on the screen.
        if (gamePadOne.IsButtonDown(Buttons.DPadLeft))
        {
            _slimePosition.X -= speed;
        }

        // If DPadRight is down, move the slime right on the screen.
        if (gamePadOne.IsButtonDown(Buttons.DPadRight))
        {
            _slimePosition.X += speed;
        }
    }
}
</code></pre>
<ul>
<li><code>AssignRandomBatVelocity</code>: Calculates a random direction and applies it to the bat's velocity.</li>
<li><code>CheckKeyboardInput</code>: Handles keyboard controls for moving the slime, toggling audio settings, and returning to the title screen.</li>
<li><code>CheckGamePadInput</code>: Handles gamepad controls for moving the slime.</li>
</ul>
<h5 id="game-scene-draw">Game Scene Draw</h5>
<p>Add the following override for the <code>Draw</code> method to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">public override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    Core.GraphicsDevice.Clear(Color.CornflowerBlue);

    // Begin the sprite batch to prepare for rendering.
    Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

    // Draw the tilemap
    _tilemap.Draw(Core.SpriteBatch);

    // Draw the slime sprite.
    _slime.Draw(Core.SpriteBatch, _slimePosition);

    // Draw the bat sprite.
    _bat.Draw(Core.SpriteBatch, _batPosition);

    // Draw the score
    Core.SpriteBatch.DrawString(
        _font,              // spriteFont
        $&quot;Score: {_score}&quot;, // text
        _scoreTextPosition, // position
        Color.White,        // color
        0.0f,               // rotation
        _scoreTextOrigin,   // origin
        1.0f,               // scale
        SpriteEffects.None, // effects
        0.0f                // layerDepth
    );

    // Always end the sprite batch when finished.
    Core.SpriteBatch.End();
}
</code></pre>
<ul>
<li>The back buffer is cleared.</li>
<li>The tilemap is drawn.</li>
<li>The slime and bat animated sprites are drawn at their current positions.</li>
<li>The player's score is drawn at using its precalculated position and origin so that it is in the top left of the room bounds centered on the wall sprite.</li>
</ul>
<h3 id="updating-the-game1-class">Updating the Game1 Class</h3>
<p>With our scene system and scene classes in place, we can now simplify our main <code>Game1</code> class to just initialize the game and start with the title scene. Open the <em>Game1.cs</em> file and update it to the following:</p>
<pre><code class="lang-csharp">using DungeonSlime.Scenes;
using Microsoft.Xna.Framework.Media;
using MonoGameLibrary;

namespace DungeonSlime;

public class Game1 : Core
{
    // The background theme song
    private Song _themeSong;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        base.Initialize();

        // Start playing the background music
        Audio.PlaySong(_themeSong);

        // Start the game with the title scene.
        ChangeScene(new TitleScene());
    }

    protected override void LoadContent()
    {
        base.LoadContent();

        // Load the background theme music
        _themeSong = Content.Load&lt;Song&gt;(&quot;audio/theme&quot;);
    }
}
</code></pre>
<p>The <code>Game1</code> class is now much simpler as most of the game logic has been moved to the appropriate scene classes. It:</p>
<ol>
<li>Inherits from our <code>Core</code> class instead of the MonoGame Game class.</li>
<li>Sets up the game window with the constructor parameters.</li>
<li>Overrides the <code>Initialize</code> method to set the title scene as the starting scene.</li>
<li>Overrides the <code>LoadContent</code> method to load the background theme song and start playing it.</li>
</ol>
<p>Running the game now, we can see that once the game screen comes up, the title scene is displayed with the animated slime and the press enter prompt.  The background music starts playing on this scene as well.  Pressing enter from here will switch to the game scene where the game starts and we can play the game implemented thus far.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><video width="500" height="281" controls=""><source type="video/webm" src="videos/gameplay.webm"></video></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 17-2: The game launching with the title screen first, then transitioning to the game play screen when enter is pressed</strong></td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, you accomplished the following:</p>
<ul>
<li>Learned about scene management and why it is important for organizing game code.</li>
<li>Created an abstract <code>Scene</code> base class that provides a consistent lifecycle similar to the MonoGame <a href="xref:Microsoft.Xna.Framework.Game"><strong>Game</strong></a> class.</li>
<li>Implemented the <code>IDisposable</code> interface to properly handle resource cleanup.</li>
<li>Extended the <code>Core</code> class to handle scene transitions and management.</li>
<li>Created a <code>TitleScene</code> for the main menu with text prompts and animations.</li>
<li>Created a <code>GameScene</code> that encapsulates the gameplay mechanics.</li>
<li>Refactored the main <code>Game1</code> class to be much simpler by using the scene system.</li>
</ul>
<p>The approach we've taken follows a common pattern in game development, where each scene has control over its own lifecycle and resources. This pattern simplify state management by isolating different game states from one another.  As your game grows in complexity, you could easily extend this system to include additional scenes like a pause menu or a game over screen.</p>
<p>In the next chapter, we'll explore <a href="xref:Microsoft.Xna.Framework.Graphics.RenderTarget2D"><strong>RenderTarget2D</strong></a> and how we can use it to add different types of transitions when switching scenes.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What are the main benefits of implementing a scene management system in a game?</p>
<div class="question-answer"><p>The main benefits include:</p>
<ul>
<li>Improved organization by separating different parts of the game into self-contained modules.</li>
<li>Better memory management by loading assets only when needed and unloading them when leaving a scene.</li>
<li>Simplified state handling as each scene maintains its own state without affecting others.</li>
<li>Increased code reusability through the ability to create reusable scene templates.</li>
</ul>
</div>
</li>
<li><p>How does the scene lifecycle in our implementation mirror the MonoGame Game class lifecycle?</p>
<div class="question-answer"><p>The scene lifecycle mirrors the MonoGame Game class lifecycle by implementing similar methods in the same order:</p>
<ul>
<li><code>Initialize</code> is called once when the scene becomes active.</li>
<li><code>LoadContent</code> is called at the end of the <code>Initialize</code> method.</li>
<li><code>Update</code> is called every frame to update game logic.</li>
<li><code>Draw</code> is called every frame to render the scene.</li>
<li><code>UnloadContent</code> is called when transitioning away from the scene.</li>
</ul>
</div>
</li>
<li><p>What is the purpose of having a separate <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> for each scene?</p>
<div class="question-answer"><p>Having a separate <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a> for each scene:</p>
<ul>
<li>Allows scene-specific content to be automatically unloaded when the scene is disposed.</li>
<li>Provides better organization of which assets belong to which scenes.</li>
<li>Improves memory efficiency by only loading assets that are currently needed.</li>
<li>Makes it clear which assets are meant to be used globally versus locally to a scene.</li>
</ul>
</div>
</li>
<li><p>When implementing scene transitions, why do we use a two-step process with <code>_nextScene</code> and <code>_activeScene</code>?</p>
<div class="question-answer"><p>The two-step process with <code>_nextScene</code> and <code>_activeScene</code> is used because:</p>
<ul>
<li>It allows the current scene to complete its update/draw cycle before the transition occurs.</li>
<li>It provides a clean way to handle the disposal of the current scene before initializing the new one.</li>
<li>It ensures that scene transitions happen at a safe point in the game loop.</li>
<li>It prevents potential issues that could occur from immediately changing scenes in the middle of an update or draw operation.</li>
</ul>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
