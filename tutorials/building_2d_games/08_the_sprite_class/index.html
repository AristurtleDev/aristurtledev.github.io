<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-08-the-sprite-class">Chapter 08: The Sprite Class</h1>
<p class="text-secondary">Explore creating a reusable Sprite class to efficiently sprites and their rendering properties, including position, rotation, scale, and more.</p>
<p>In <a href="../07_optimizing_texture_rendering/index.html">Chapter 07</a>, you learned how to use texture atlases to optimize rendering performance. While this solved the issue of texture swapping, managing individual sprites and their properties becomes increasingly complex as your game grows. Even in our simple example with just a slime and a bat, we would eventually need to track various properties for each sprite:</p>
<ul>
<li>Color mask for tinting.</li>
<li>Origin for rotation and scale.</li>
<li>Scale for size adjustments.</li>
<li>Rotation for orientation.</li>
<li>Sprite effects to flip horizontally and/or vertically.</li>
<li>Layer depth for draw order layering.</li>
</ul>
<p>Imagine scaling this up to dozens of sprites, each with multiple instances on screen.  Tracking all these properties through individual variables quickly becomes unmanageable. In this chapter, we'll solve this by creating a class that encapsulates sprite information and handles rendering.</p>
<h2 id="the-sprite-class">The Sprite Class</h2>
<p>A sprite in our game represents a visual object created from a texture region along with its rendering properties. While multiple sprites might use the same texture region (like multiple enemies of the same type), each sprite can have unique properties that control how it appears on screen; its position, rotation, scale, and other visual characteristics.</p>
<p>By creating a <code>Sprite</code> class, we can encapsulate both the texture region and its rendering parameters into a single, reusable component. This not only makes our code more organized but also makes it easier to manage multiple instances of the same type of sprite.</p>
<p>In the <em>Graphics</em> folder within the <em>MonoGameLibrary</em> project, add a new file named <em>Sprite.cs</em>.  Add the following code for the foundation of the <code>Sprite</code> class to the <em>Sprite.cs</em> file:</p>
<pre><code class="lang-csharp">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace MonoGameLibrary.Graphics;

public class Sprite { }
</code></pre><h3 id="properties">Properties</h3>
<p>The <code>Sprite</code> class will utilize properties that mirror the parameters used in <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> so the rendering parameter for each sprite is self contained.  Add the following properties:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Gets or Sets the source texture region represented by this sprite.
/// &lt;/summary&gt;
public TextureRegion Region { get; set; }

/// &lt;summary&gt;
/// Gets or Sets the color mask to apply when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is Color.White
/// &lt;/remarks&gt;
public Color Color { get; set; } = Color.White;

/// &lt;summary&gt;
/// Gets or Sets the amount of rotation, in radians, to apply when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is 0.0f
/// &lt;/remarks&gt;
public float Rotation { get; set; } = 0.0f;

/// &lt;summary&gt;
/// Gets or Sets the scale factor to apply to the x- and y-axes when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is Vector2.One
/// &lt;/remarks&gt;
public Vector2 Scale { get; set; } = Vector2.One;

/// &lt;summary&gt;
/// Gets or Sets the xy-coordinate origin point, relative to the top-left corner, of this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is Vector2.Zero
/// &lt;/remarks&gt;
public Vector2 Origin { get; set; } = Vector2.Zero;

/// &lt;summary&gt;
/// Gets or Sets the sprite effects to apply when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is SpriteEffects.None
/// &lt;/remarks&gt;
public SpriteEffects Effects { get; set; } = SpriteEffects.None;

/// &lt;summary&gt;
/// Gets or Sets the layer depth to apply when rendering this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Default value is 0.0f
/// &lt;/remarks&gt;
public float LayerDepth { get; set; } = 0.0f;

/// &lt;summary&gt;
/// Gets the width, in pixels, of this sprite. 
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Width is calculated by multiplying the width of the source texture region by the x-axis scale factor.
/// &lt;/remarks&gt;
public float Width =&gt; Region.Width * Scale.X;

/// &lt;summary&gt;
/// Gets the height, in pixels, of this sprite.
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// Height is calculated by multiplying the height of the source texture region by the y-axis scale factor.
/// &lt;/remarks&gt;
public float Height =&gt; Region.Height * Scale.Y;
</code></pre>
<p>The <code>TextureRegion</code> property works to provide the texture and source rectangle when rendering the sprite. Other properties directly correspond to <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> parameters with the same default values, making it easy to understand how each property affects the sprite's appearance.</p>
<div class="TIP">
<h5>Tip</h5>
<p>The calculated <code>Width</code> and <code>Height</code> properties make it easier to position sprites relative to each other without manually applying scale factors.</p>
</div>
<h3 id="constructors">Constructors</h3>
<p>The <code>Sprite</code> class will provide two ways to create a new sprite.  Add the following constructors:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new sprite.
/// &lt;/summary&gt;
public Sprite() { }

/// &lt;summary&gt;
/// Creates a new sprite using the specified source texture region.
/// &lt;/summary&gt;
/// &lt;param name=&quot;region&quot;&gt;The texture region to use as the source texture region for this sprite.&lt;/param&gt;
public Sprite(TextureRegion region)
{
    Region = region;
}
</code></pre>
<p>The default constructor creates an empty sprite that can be configured later, while the parameterized constructor allows you to specify the source texture region for the sprite.</p>
<h3 id="methods">Methods</h3>
<p>Finally, the <code>Sprite</code> class provides the following two methods:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Sets the origin of this sprite to the center
/// &lt;/summary&gt;
public void CenterOrigin()
{
    Origin = new Vector2(Region.Width, Region.Height) * 0.5f;
}

/// &lt;summary&gt;
/// Submit this sprite for drawing to the current batch.
/// &lt;/summary&gt;
/// &lt;param name=&quot;spriteBatch&quot;&gt;The SpriteBatch instance used for batching draw calls.&lt;/param&gt;
/// &lt;param name=&quot;position&quot;&gt;The xy-coordinate position to render this sprite at.&lt;/param&gt;
public void Draw(SpriteBatch spriteBatch, Vector2 position)
{
    Region.Draw(spriteBatch, position, Color, Rotation, Origin, Scale, Effects, LayerDepth);
}
</code></pre>
<ul>
<li><p><code>CenterOrigin</code>: Sets the origin point of the sprite to its center.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The origin needs to be set based on the width and height of the source texture region itself, regardless of the scale the sprite is rendered at.</p>
</div>
</li>
<li><p><code>Draw</code>: Uses the <code>TextureRegion</code> property to submit the sprite for rendering using the properties of the sprite itself.</p>
</li>
</ul>
<h2 id="create-sprites-with-the-textureatlas-class">Create Sprites With The TextureAtlas Class</h2>
<p>While the <code>GetRegion</code> method of the <code>TextureAtlas</code> class we created in <a href="../07_optimizing_texture_rendering/index.html#the-textureatlas-class">Chapter 07</a> works well for retrieving regions, creating sprites requires multiple steps:</p>
<ol>
<li>Get the region by name.</li>
<li>Store it in a variable.</li>
<li>Create a new sprite with that region.</li>
</ol>
<p>We can simplify this process by adding a sprite creation method to the <code>TextureAtlas</code> class. Open <em>TextureAtlas.cs</em> and add the following method:</p>
<pre><code class="lang-csharp">/// &lt;summary&gt;
/// Creates a new sprite using the region from this texture atlas with the specified name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;regionName&quot;&gt;The name of the region to create the sprite with.&lt;/param&gt;
/// &lt;returns&gt;A new Sprite using the texture region with the specified name.&lt;/returns&gt;
public Sprite CreateSprite(string regionName)
{
    TextureRegion region = GetRegion(regionName);
    return new Sprite(region);
}
</code></pre><h2 id="using-the-sprite-class">Using the Sprite Class</h2>
<p>Let's adjust our game now to use the <code>Sprite</code> class instead of just the texture regions.  Replace the contents of <em>Game1.cs</em> with the following:</p>
<pre><code class="lang-csharp" highlight-lines="11-15,34-40,63-67">using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace DungeonSlime;

public class Game1 : Core
{
    // Defines the slime sprite.
    private Sprite _slime;

    // Defines the bat sprite.
    private Sprite _bat;

    public Game1() : base(&quot;Dungeon Slime&quot;, 1280, 720, false)
    {

    }

    protected override void Initialize()
    {
        // TODO: Add your initialization logic here

        base.Initialize();
    }

    protected override void LoadContent()
    {
        // Create the texture atlas from the XML configuration file
        TextureAtlas atlas = TextureAtlas.FromFile(Content, &quot;images/atlas-definition.xml&quot;);

        // Create the slime sprite from the atlas.
        _slime = atlas.CreateSprite(&quot;slime&quot;);
        _slime.Scale = new Vector2(4.0f, 4.0f);

        // Create the bat sprite from the atlas.
        _bat = atlas.CreateSprite(&quot;bat&quot;);
        _bat.Scale = new Vector2(4.0f, 4.0f);

        base.LoadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
            Exit();

        // TODO: Add your update logic here

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        // Clear the back buffer.
        GraphicsDevice.Clear(Color.CornflowerBlue);

        // Begin the sprite batch to prepare for rendering.
        SpriteBatch.Begin(samplerState: SamplerState.PointClamp);

        // Draw the slime sprite.
        _slime.Draw(SpriteBatch, Vector2.One);

        // Draw the bat sprite 10px to the right of the slime.
        _bat.Draw(SpriteBatch, new Vector2(_slime.Width + 10, 0));

        // Always end the sprite batch when finished.
        SpriteBatch.End();

        base.Draw(gameTime);
    }
}
</code></pre>
<p>The key changes in this implementation are:</p>
<ul>
<li>The <code>_slime</code> and <code>_bat</code> members were changed from <code>TextureRegion</code>  to <code>Sprite</code>.</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a>
<ul>
<li>The <code>_slime</code> and <code>_bat</code> sprites are now created using the new <code>TextureAtlas.CreateSprite</code> method.</li>
<li>Both the <code>_slime</code> and <code>_bat</code> sprites are given a scale of 4.0f.</li>
</ul>
</li>
<li>In <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a>, the draw calls were updated to use the <code>Sprite.Draw</code> method.</li>
</ul>
<p>Running the game now will produce the same result as in the previous chapter.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/slime-and-bat-rendered.png" alt="Figure 8-1: The slime and bat sprites being rendered in the upper-left corner of the game window"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 8-1: The slime and bat sprites being rendered in the upper-left corner of the game window</strong></td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>Notice how even though we increased the scale of both sprites, the bat sprite is still only 10px to the right of the bat.  This is because the <code>Width</code> property we created for the <code>Sprite</code> class takes into account the scale factor of the sprite as well.</p>
</div>
<p>Try adjusting the various properties available for the slime and the bat sprites to see how they affect the rendering.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this chapter, we created a reusable <code>Sprite</code> class that encapsulates the properties for each sprite that we would render.  The <code>TextureAtlas</code> class was updated to simplify sprite creation based on the <code>Sprite</code> class we created.</p>
<p>In the next chapter, we'll build upon the <code>Sprite</code> class to create an <code>AnimatedSprite</code> class that will allow us to bring our sprites to life through animation.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is the benefit of using a Sprite class instead of managing texture regions directly?</p>
<div class="question-answer"><p>The <code>Sprite</code> class encapsulates all rendering properties (position, rotation, scale, etc.) into a single, reusable component. This makes it easier to manage multiple instances of the same type of sprite without having to track properties through individual variables.</p>
</div>
</li>
<li><p>Why do the <code>Width</code> and <code>Height</code> properties of a Sprite take the Scale property into account?</p>
<div class="question-answer"><p>The <code>Width</code> and <code>Height</code> properties account for scaling to make it easier to position sprites relative to each other without having to manually calculate the scaled dimensions. This is particularly useful when sprites are rendered at different scales.</p>
</div>
</li>
<li><p>When using the <code>CenterOrigin</code> method, why is the origin calculated using the region's dimensions rather than the sprite's scaled dimensions?</p>
<div class="question-answer"><p>The origin needs to be set based on the texture region's actual dimensions because it represents the point around which scaling and rotation are applied. Using the scaled dimensions would result in incorrect positioning since the origin would change based on the current scale factor.</p>
</div>
</li>
<li><p>What advantage does the <code>TextureAtlas.CreateSprite</code> method provide over using <code>GetRegion</code>?</p>
<div class="question-answer"><p>The <code>CreateSprite</code> method simplifies sprite creation by combining multiple steps (getting the region, storing it, creating a sprite) into a single method call. This reduces code repetition and makes sprite creation more straightforward.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
