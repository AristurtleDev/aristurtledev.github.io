<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.json">
      <meta name="docfx:tocrel" content="../toc.json">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="chapter-12-soundeffects-and-music">Chapter 12: SoundEffects and Music</h1>
<p class="text-secondary">Learn how to load and play sound effects and background music in MonoGame including managing audio volume, looping, and handling multiple sound effects at once.</p>
<p>In <a href="../11_collision_detection/index.html">Chapter 11</a>, we implemented collision detection to enable interactions between game objects; the slime can now &quot;eat&quot; the bat, which respawns in a random location, while the bat bounces off screen edges. While these mechanics work visually, our game lacks an important element of player feedback: audio.</p>
<p>Audio plays a crucial role in game development by providing immediate feedback for player actions and creating atmosphere. Sound effects alert players when events occur (like collisions or collecting items), while background music helps establish mood and atmosphere.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Learn how MonoGame handles different types of audio content.</li>
<li>Learn how to load and play sound effects and music using the content pipeline.</li>
<li>Implement sound effects for collision events.</li>
<li>Add background music to enhance atmosphere.</li>
<li>Control audio playback including volume and looping.</li>
</ul>
<p>Let's start by understanding how MonoGame approaches audio content.</p>
<h2 id="understanding-audio-in-monogame">Understanding Audio in MonoGame</h2>
<p>Recall from <a href="../01_what_is_monogame/index.html">Chapter 01</a> that MonoGame is an implementation of the XNA API. When Microsoft originally released XNA, there were two methods for implementing audio in your game: the <em>Microsoft Cross-Platform Audio Creation Tool</em> (XACT) and the simplified sound API. XACT is a mini audio engineering studio where you can easily edit the audio for your game like editing volume, pitch, looping, applying effects, and other properties without having to do it in code. At that time, XACT for XNA games was akin to what FMOD Studio is today for game audio.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/xact-editor.png" alt="Figure 12-1: Microsoft Cross-Platform Audio Creation Tool"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 12-1: Microsoft Cross-Platform Audio Creation Tool</strong></td>
</tr>
</tbody>
</table>
<p>While XACT projects are still fully supported in MonoGame, it remains a Windows-only tool that hasn't been updated since Microsoft discontinued the original XNA, nor has its source code been made open source. Though it's possible to install XACT on modern Windows, the process can be complex. For these reasons, this tutorial will focus on the simplified sound API, which provides all the core functionality needed for most games while remaining cross-platform compatible.</p>
<p>The simplified sound API approaches audio management through two distinct paths, each optimized for different use cases in games. When adding audio to your game, you need to consider how different types of sounds should be handled. A short sound effect, like the bounce of a ball, needs to play immediately and might need to play multiple times simultaneously. In contrast, background music needs to play continuously but doesn't require the same immediate response.</p>
<p>MonoGame addresses these different needs through two main classes:</p>
<h3 id="sound-effects">Sound Effects</h3>
<p>The <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect"><strong>SoundEffect</strong></a> class handles short audio clips like:</p>
<ul>
<li>Collision sounds.</li>
<li>Player action feedback (jumping, shooting, etc.).</li>
<li>UI interactions (button clicks, menu navigation).</li>
<li>Environmental effects (footsteps, ambient sounds).</li>
</ul>
<p>The key characteristics of sound effects are:</p>
<ul>
<li>Loaded entirely into memory for quick access</li>
<li>Can play multiple instances simultaneously</li>
<li>Lower latency playback (ideal for immediate feedback)</li>
<li>Individual volume control per instance</li>
</ul>
<p>When you play a <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect"><strong>SoundEffect</strong></a>, it returns a <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffectInstance"><strong>SoundEffectInstance</strong></a> that can be used to control that specific playback:</p>
<pre><code class="lang-cs">// Load the sound effect
SoundEffect soundEffect = Content.Load&lt;SoundEffect&gt;(&quot;sound effect&quot;);

// Create an instance we can control
SoundEffectInstance soundEffectInstance = soundEffect.CreateInstance();
soundEffectInstance.Volume = 0.5f;
soundEffectInstance.Play();

// Or play it directly if we don't need to control it
soundEffectInstance.Play();
</code></pre>
<h3 id="music">Music</h3>
<p>The <a href="xref:Microsoft.Xna.Framework.Audio.Song"><strong>Song</strong></a> class handles longer audio pieces like background music.  The key characteristics of songs are:</p>
<ul>
<li>Streamed from storage rather than loaded into memory.</li>
<li>Only one song can be played at a time.</li>
<li>Higher latency, but lower memory usage.</li>
</ul>
<p>Songs are played through the <a href="xref:Microsoft.Xna.Framework.Media.MediaPlayer"><strong>MediaPlayer</strong></a> class:</p>
<pre><code class="lang-cs">// Load the song
Song backgroundMusic = Content.Load&lt;Song&gt;(&quot;theme&quot;);

// Play the song, optionally looping
MediaPlayer.IsRepeating = true;
MediaPlayer.Play(backgroundMusic);
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>While <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect"><strong>SoundEffect</strong></a> instances can be played simultaneously, trying to play a new <a href="xref:Microsoft.Xna.Framework.Audio.Song"><strong>Song</strong></a> while another is playing will automatically stop the current song. This is why <a href="xref:Microsoft.Xna.Framework.Audio.Song"><strong>Song</strong></a> is ideal for background music where you typically only want one track playing at a time.</p>
</div>
<p>Throughout this chapter, we'll use both classes to add audio feedback to our game; sound effects for the bat bouncing and being eaten by the slime, and background music to create atmosphere.</p>
<h2 id="loading-audio-content">Loading Audio Content</h2>
<p>Just like textures, audio content in MonoGame can be loaded through the content pipeline, optimizing the format for your target platform.</p>
<h3 id="supported-audio-formats">Supported Audio Formats</h3>
<p>MonoGame supports several audio file formats for both sound effects and music:</p>
<ul>
<li><code>.wav</code>: Uncompressed audio, ideal for short sound effects</li>
<li><code>.mp3</code>: Compressed audio, better for music and longer sounds</li>
<li><code>.ogg</code>: Open source compressed format, supported on all platforms</li>
<li><code>.wma</code>: Windows Media Audio format (not recommended for cross-platform games)</li>
</ul>
<div class="TIP">
<h5>Tip</h5>
<p>For sound effects, <code>.wav</code> files provide the best loading and playback performance since they don't need to be decompressed. For music, <code>.mp3</code> or <code>.ogg</code> files are better choices as they reduce file size while maintaining good quality.</p>
</div>
<h3 id="adding-audio-files">Adding Audio Files</h3>
<p>Before we can add audio to our game, we need some sound files to work with. Download the following audio files:</p>
<ul>
<li><a href="files/bounce.wav">bounce.wav</a> - For when the bat bounces off screen edges</li>
<li><a href="files/collect.wav">collect.wav</a> - For when the slime eats the bat</li>
<li><a href="files/theme.mp3">theme.mp3</a> - Background music</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<ul>
<li><em>bounce.wav</em> is &quot;Retro Impact Punch 07&quot; by Davit Masia (<a href="https://kronbits.itch.io/retrosfx">https://kronbits.itch.io/retrosfx</a>).</li>
<li><em>collect.wav</em> is &quot;Retro Jump Classic 08&quot; by Davit Masia (<a href="https://kronbits.itch.io/retrosfx">https://kronbits.itch.io/retrosfx</a>).</li>
<li><em>theme.mp3</em> is &quot;8bit Dungeon Level&quot; by Kevin MacLeod (incompetech.com), Licensed under Creative Commons: By Attribution 4.0 License <a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></li>
</ul>
</div>
<p>Add these files to your content project using the MGCB Editor:</p>
<ol>
<li><p>Open the <em>Content.mgcb</em> file in the MGCB Editor.</p>
</li>
<li><p>Create a new directory called <code>audio</code> (right-click <em>Content</em> &gt; <em>Add</em> &gt; <em>New Folder</em>).</p>
</li>
<li><p>Right-click the new <em>audio</em> directory and choose <em>Add</em> &gt; <em>Existing Item...</em>.</p>
</li>
<li><p>Navigate to and select the audio files you downloaded.</p>
</li>
<li><p>For each file that's added, check its properties in the Properties panel:</p>
<ul>
<li>For <code>.wav</code> files, ensure <em>Build Action</em> is set to <code>Build</code> and <em>Content Processor</em> is set to <code>Sound Effect</code>.</li>
<li>For <code>.mp3</code> files, ensure <em>Build Action</em> is set to <code>Build</code> and <em>Content Processor</em> is set to <code>Song</code>.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: center;"><img src="images/sound-effect-properties.png" alt="Figure 12-2: MGCB Editor properties panel showing Sound Effect content processor settings for .wav files** | **Figure 12-3: MGCB Editor properties panel showing Song content processor settings for .mp3 files"></th>
<th style="text-align: center;"><img src="images/song-properties.png" alt="Figure 12-3: MGCB Editor properties panel showing Song content processor settings for .mp3 files"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>Figure 12-2: MGCB Editor properties panel showing Sound Effect content processor settings for .wav files</strong></td>
<td style="text-align: center;"><strong>Figure 12-3: MGCB Editor properties panel showing Song content processor settings for .mp3 files</strong></td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="loading-sound-effects">Loading Sound Effects</h3>
<p>To load a sound effect, we use <a href="xref:Microsoft.Xna.Framework.Content.ContentManager.Load%60%601(System.String)"><strong>ContentManager.Load</strong></a> with the <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect"><strong>SoundEffect</strong></a> type.  Open then <em>Game1.cs</em> and perform the following:</p>
<ol>
<li><p>First, add the following fields to store the sound effects that are loaded:</p>
<pre><code class="lang-cs">private SoundEffect _bounceSound;
private SoundEffect _collectSound;
</code></pre>
</li>
<li><p>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent">LoadContent</a> add the following to load the sound effects:</p>
<pre><code class="lang-cs">_bounceSound = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);
_collectSound = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);
</code></pre>
</li>
</ol>
<h3 id="loading-music">Loading Music</h3>
<p>Loading music is similar, only we specify the <a href="xref:Microsoft.Xna.Framework.Audio.Song"><strong>Song</strong></a> type instead.  Perform the following:</p>
<ol>
<li><p>First, add the following field to track the song:</p>
<pre><code class="lang-cs">private Song _backgroundMusic;
</code></pre>
</li>
<li><p>In <a href="xref:Microsoft.Xna.Framework.Game.LoadContent">LoadContent</a> add the following to load the song:</p>
<pre><code class="lang-cs">_backgroundMusic = Content.Load&lt;Song&gt;(&quot;audio/theme&quot;);
</code></pre>
</li>
</ol>
<h2 id="playing-audio">Playing Audio</h2>
<p>Now that we have our audio content loaded, we can implement sound playback in our game. Let's start by understanding how to play sound effects and music, then we'll add them to our game's collision events.</p>
<h3 id="playing-sound-effects">Playing Sound Effects</h3>
<p>The <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect"><strong>SoundEffect</strong></a> class provides two ways to play sounds:</p>
<ol>
<li><p>Direct playback using <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect.Play"><strong>SoundEffect.Play</strong></a>:</p>
<pre><code class="lang-cs">// Play the sound effect with default settings
_bounceSound.Play();
</code></pre>
</li>
<li><p>Creating an instance using <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect.CreateInstance"><strong>SoundEffect.CreateInstance</strong></a>:</p>
<pre><code class="lang-cs">// Create an instance we can control
SoundEffectInstance bounceInstance = _bounceSound.CreateInstance();
bounceInstance.Volume = 0.5f;
bounceInstance.Play();
</code></pre>
</li>
</ol>
<p>The first method is simpler but provides no control over the playback. The second method returns a <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffectInstance"><strong>SoundEffectInstance</strong></a> that can be controlled through several properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Audio.SoundEffectInstance.IsLooped"><strong>IsLooped</strong></a></td>
<td><code>bool</code></td>
<td>Whether the sound should loop when it reaches the end.</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Audio.SoundEffectInstance.Pan"><strong>Pan</strong></a></td>
<td><code>float</code></td>
<td>Stereo panning between -1.0f (full left) and 1.0f (full right).</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Audio.SoundEffectInstance.Pitch"><strong>Pitch</strong></a></td>
<td><code>float</code></td>
<td>Pitch adjustment between -1.0f (down one octave) and 1.0f (up one octave).</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Audio.SoundEffectInstance.State"><strong>State</strong></a></td>
<td><a href="xref:Microsoft.Xna.Framework.Audio.SoundState"><strong>SoundState</strong></a></td>
<td>Current playback state (Playing, Paused, or Stopped).</td>
</tr>
<tr>
<td><a href="xref:Microsoft.Xna.Framework.Audio.SoundEffectInstance.Volume"><strong>Volume</strong></a></td>
<td><code>float</code></td>
<td>Volume level between 0.0f (silent) and 1.0f (full volume).</td>
</tr>
</tbody>
</table>
<h3 id="playing-music">Playing Music</h3>
<p>Unlike sound effects, music is played through the <a href="xref:Microsoft.Xna.Framework.Media.MediaPlayer"><strong>MediaPlayer</strong></a> class. This static class manages playback of <a href="xref:Microsoft.Xna.Framework.Media.Song"><strong>Song</strong></a> instances and provides global control over music playback:</p>
<pre><code class="lang-cs">// Set whether the song should repeat when finished
MediaPlayer.IsRepeating = true;

// Adjust the volume (0.0f to 1.0f)
MediaPlayer.Volume = 0.5f;

// Start playing the background music
MediaPlayer.Play(_backgroundMusic);
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Only one song can play at a time. Starting a new song will automatically stop any currently playing song.</p>
</div>
<h3 id="adding-audio-to-our-game">Adding Audio to Our Game</h3>
<p>Let's update our game to play audio at appropriate times.  We'll play:</p>
<ul>
<li>Background music when the game first loads.</li>
<li>The bounce sound when the bat hits screen edges.</li>
<li>The collect sound when the slime eats the bat.</li>
</ul>
<p>Open <em>Game1.cs</em> and make the following changes:</p>
<ol>
<li><p>First, let's add background music playback. In <a href="xref:Microsoft.Xna.Framework.Game.Initialize">Initialize</a>, after the call to <code>base.Initialize()</code>, add:</p>
<pre><code class="lang-cs">// Ensure the song is looping
MediaPlayer.IsRepeating = true;

// PLay the song
MediaPlayer.Play(_backgroundMusic);
</code></pre>
</li>
<li><p>Next, update the <code>UpdateBatMovement</code> method to play the bounce sound when the bat hits screen edges.  Add the following as part of the collision response:</p>
<pre><code class="lang-cs">// Play bounce sound
_bounceSound.Play();
</code></pre>
</li>
<li><p>Finally, in <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a>, add the collect sound during the collision response when the slime eats the bat:</p>
<pre><code class="lang-cs">// Play collect sound
_collectSound.Play();
</code></pre>
</li>
</ol>
<p>Running the game now, you'll hear:</p>
<ul>
<li>Background music playing continuously.</li>
<li>A bounce sound whenever the bat hits screen edges.</li>
<li>A collect sound whenever the slime eats the bat.</li>
</ul>
<h2 id="audio-management">Audio Management</h2>
<p>While playing sounds and music is straightforward, a complete game needs to handle various audio states and cleanup. An audio manager that will:</p>
<ul>
<li>Track and manage sound effects and songs</li>
<li>Handle volume control</li>
<li>Manage audio state (pause/resume, mute/unmute)</li>
<li>Clean up resources properly</li>
</ul>
<p>To get started, create a new directory called <em>Audio</em> in the <em>MonoGameLibrary</em> project.</p>
<h3 id="the-audiomanager-class">The AudioManager Class</h3>
<p>To effectively manage audio in our games, we'll create an <code>AudioManager</code> class that handles loading, playing, and controlling both sound effects and music. This manager will be implemented as a <a href="xref:Microsoft.Xna.Framework.GameComponent"><strong>GameComponent</strong></a>, allowing it to receive automatic updates and cleanup.</p>
<p>In the <em>Audio</em> directory of the <em>MonoGameLibrary</em> project, add a new file named <em>AudioManager.cs</em> with this initial structure:</p>
<pre><code class="lang-cs">using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Media;

namespace MonoGameLibrary.Audio;

public class AudioManager : GameComponent
{

}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>The <code>AudioManager</code> class inherits from <a href="xref:Microsoft.Xna.Framework.GameComponent"><strong>GameComponent</strong></a>, which allows it to be added to a game's component collection and automatically receive updates.</p>
</div>
<h4 id="audiomanager-members">AudioManager Members</h4>
<p>The <code>AudioManager</code> class needs to track various audio resources and states. Add these private fields:</p>
<pre><code class="lang-cs">private readonly Dictionary&lt;string, SoundEffect&gt; _soundEffects;
private readonly Dictionary&lt;string, Song&gt; _songs;
private readonly List&lt;SoundEffectInstance&gt; _activeSoundEffectInstances;
private float _previousMusicVolume;
private float _previousSoundEffectVolume;
</code></pre>
<p>These fields serve different purposes:</p>
<ul>
<li><code>_soundEffects</code>: Stores loaded sound effects by their asset name.</li>
<li><code>_songs</code>: Stores loaded songs by their asset name.</li>
<li><code>_activeSoundEffectInstances</code>: Tracks currently playing sound effects.</li>
<li><code>_previousMusicVolume</code> and <code>_previousSoundEffectVolume</code>: Store volume levels for mute/unmute functionality.</li>
</ul>
<h3 id="audiomanager-properties">AudioManager Properties</h3>
<p>The AudioManager provides a property to track its mute state.  Add the following property:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Gets a value that indicates if audio is muted.
/// &lt;/summary&gt;
public bool IsMuted { get; private set; }
</code></pre>
<h3 id="audiomanager-constructor">AudioManager Constructor</h3>
<p>The constructor initializes our collections and sets up the component.  Add the following constructor:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Creates a new AudioManager instance.
/// &lt;/summary&gt;
/// &lt;param name=&quot;game&quot;&gt;The game this audio manager will belong too..&lt;/param&gt;
public AudioManager(Game game)
    : base(game)
{
    _soundEffects = new Dictionary&lt;string, SoundEffect&gt;();
    _songs = new Dictionary&lt;string, Song&gt;();
    _activeSoundEffectInstances = new List&lt;SoundEffectInstance&gt;();
}
</code></pre>
<h3 id="audiomanager-methods">AudioManager Methods</h3>
<p>The <code>AudioManager</code> class provides several categories of methods to handle different aspects of audio management.  Each group of methods serves a specific purpose in managing game audio, from basic playback to more complex state management.</p>
<h4 id="game-component-methods">Game Component Methods</h4>
<p>Add the following methods to the manager which override key methods from <a href="xref:Microsoft.Xna.Framework.GameComponent"><strong>GameComponent</strong></a>:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Initializes this Audio manager.
/// &lt;/summary&gt;
public override void Initialize()
{
    _previousMusicVolume = MediaPlayer.Volume = 1.0f;
    _previousSoundEffectVolume = SoundEffect.MasterVolume = 1.0f;
    base.Initialize();
}

/// &lt;summary&gt;
/// Updates this Audio manager
/// &lt;/summary&gt;
/// &lt;param name=&quot;gameTime&quot;&gt;A snapshot of the current timing values for the game.&lt;/param&gt;
public override void Update(GameTime gameTime)
{
    int index = 0;

    while (index &lt; _activeSoundEffectInstances.Count)
    {
        SoundEffectInstance instance = _activeSoundEffectInstances[index];

        if (instance.State == SoundState.Stopped &amp;&amp; !instance.IsDisposed)
        {
            instance.Dispose();
        }

        _activeSoundEffectInstances.RemoveAt(index);
    }

    base.Update(gameTime);
}

/// &lt;summary&gt;
/// Disposes this Audio manager and cleans up resources.
/// &lt;/summary&gt;
/// &lt;param name=&quot;disposing&quot;&gt;Indicates whether managed resources should be disposed.&lt;/param&gt;
protected override void Dispose(bool disposing)
{
    if (disposing)
    {
        foreach (SoundEffect soundEffect in _soundEffects.Values)
        {
            soundEffect.Dispose();
        }

        foreach (Song song in _songs.Values)
        {
            song.Dispose();
        }

        _soundEffects.Clear();
        _songs.Clear();
        _activeSoundEffectInstances.Clear();
    }

    base.Dispose(disposing);
}
</code></pre>
<ul>
<li><code>Initialize</code>: Sets up initial audio states by setting the default volume levels for both music and sound effects to full volume (1.0f). These values are also stored as the previous volumes for use when unmuting.</li>
<li><code>Update</code>: Handles cleanup of completed sound effects. Each frame, it checks for any sound effect instances that have finished playing (reached the Stopped state) and disposes of them to free up resources.</li>
<li><code>Dispose</code>: Ensures proper cleanup of audio resources when the game closes. All sound effects and songs are disposed of, and the collections tracking them are cleared.</li>
</ul>
<h4 id="content-management-methods">Content Management Methods</h4>
<p>Add the following methods to handle handle loading audio content into the manager:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Adds the sound effect with the specified asset name to this audio manager.
/// &lt;/summary&gt;
/// &lt;param name=&quot;assetName&quot;&gt;The asset name of the sound effect to add.&lt;/param&gt;
public void AddSoundEffect(string assetName)
{
    SoundEffect soundEffect = Game.Content.Load&lt;SoundEffect&gt;(assetName);
    _soundEffects.Add(assetName, soundEffect);
}

/// &lt;summary&gt;
/// Adds the song with the specified asset name to this audio manager.
/// &lt;/summary&gt;
/// &lt;param name=&quot;assetName&quot;&gt;The asset name of the song to add.&lt;/param&gt;
public void AddSong(string assetName)
{
    Song song = Game.Content.Load&lt;Song&gt;(assetName);
    _songs.Add(assetName, song);
}    
</code></pre>
<ul>
<li><code>AddSoundEffect</code>: Loads a sound effect from the content pipeline using the provided asset name and stores it in the <code>_soundEffects</code> dictionary for later use.</li>
<li><code>AddSong</code>: Similar to <code>AddSoundEffect</code>, this loads a song from the content pipeline and stores it in the <code>_songs</code> dictionary.</li>
</ul>
<h4 id="playback-methods">Playback Methods</h4>
<p>Add the following methods to control audio playback:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Plays the sound effect with the specified asset name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;assetName&quot;&gt;The asset name of the sound effect to play.&lt;/param&gt;
/// &lt;param name=&quot;volume&quot;&gt;The volume, ranging from 0.0 (silence) to 1.0 (full volume).&lt;/param&gt;
/// &lt;param name=&quot;pitch&quot;&gt;The pitch adjustment, ranging from -1.0 (down an octave) to 0.0 (no change) to 1.0 (up an octave).&lt;/param&gt;
/// &lt;param name=&quot;pan&quot;&gt;The panning, ranging from -1.0 (left speaker) to 0.0 (centered), 1.0 (right speaker).&lt;/param&gt;
/// &lt;param name=&quot;isLooped&quot;&gt;Whether the the sound effect should loop after playback.&lt;/param&gt;
/// &lt;returns&gt;The sound effect instance created by playing the sound effect.&lt;/returns&gt;
public SoundEffectInstance PlaySoundEffect(string assetName, float volume = 1.0f, float pitch = 0.0f, float pan = 0.0f, bool isLooped = false)
{
    SoundEffect soundEffect = _soundEffects[assetName];

    SoundEffectInstance soundEffectInstance = soundEffect.CreateInstance();
    soundEffectInstance.Volume = volume;
    soundEffectInstance.Pitch = pitch;
    soundEffectInstance.Pan = pan;
    soundEffectInstance.IsLooped = isLooped;

    soundEffectInstance.Play();

    return soundEffectInstance;
}

/// &lt;summary&gt;
/// Plays the song with the specified asset name.
/// &lt;/summary&gt;
/// &lt;param name=&quot;assetName&quot;&gt;The asset name of the song to play.&lt;/param&gt;
public void PlaySong(string assetName)
{
    Song song = _songs[assetName];
    MediaPlayer.Play(song);
}
</code></pre>
<ul>
<li><code>PlaySoundEffect</code>: Creates and plays an instance of a sound effect with customizable properties like volume, pitch, panning, and looping. Returns the instance for further control if needed.</li>
<li><code>PlaySong</code>: Starts playing a song through the MediaPlayer. Since only one song can play at a time, this will automatically stop any currently playing song.</li>
</ul>
<h4 id="state-control-methods">State Control Methods</h4>
<p>Add the following methods to manage the overall state of audio playback:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Pauses all audio.
/// &lt;/summary&gt;
public void PauseAudio()
{
    // Pause any active songs playing
    MediaPlayer.Pause();

    // Pause any active sound effects
    foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances)
    {
        soundEffectInstance.Pause();
    }
}

/// &lt;summary&gt;
/// Resumes play of all previous paused audio.
/// &lt;/summary&gt;
public void ResumeAudio()
{
    // Resume paused music
    MediaPlayer.Resume();

    // Resume any active sound effects
    foreach (SoundEffectInstance soundEffectInstance in _activeSoundEffectInstances)
    {
        soundEffectInstance.Resume();
    }
}

/// &lt;summary&gt;
/// Mutes all audio.
/// &lt;/summary&gt;
public void MuteAudio()
{
    // Store the volume so they can be restored during ResumeAudio
    _previousMusicVolume = MediaPlayer.Volume;
    _previousSoundEffectVolume = SoundEffect.MasterVolume;

    // Set all volumes to 0
    MediaPlayer.Volume = 0.0f;
    SoundEffect.MasterVolume = 0.0f;

    IsMuted = true;
}

/// &lt;summary&gt;
/// Unmutes all audio to the volume level prior to muting.
/// &lt;/summary&gt;
public void UnmuteAudio()
{
    // Restore the previous volume values
    MediaPlayer.Volume = _previousMusicVolume;
    SoundEffect.MasterVolume = _previousSoundEffectVolume;

    IsMuted = false;
}

/// &lt;summary&gt;
/// Toggles the current audio mute state.
/// &lt;/summary&gt;
public void ToggleMute()
{
    if (IsMuted)
    {
        UnmuteAudio();
    }
    else
    {
        MuteAudio();
    }
}
</code></pre>
<ul>
<li><code>PauseAudio</code>: Pauses all currently playing audio including both the active song and any playing sound effects.</li>
<li><code>ResumeAudio</code>: Resumes playback of previously paused audio, both for the song and sound effects.</li>
<li><code>MuteAudio</code>: Silences all audio by setting volumes to zero while storing previous volumes.</li>
<li><code>UnmuteAudio</code>: Restores audio to the volume levels that were active before muting.</li>
<li><code>ToggleMute</code>: Provides a convenient way to switch between muted and unmuted states.</li>
</ul>
<h4 id="volume-control-methods">Volume Control Methods</h4>
<p>Finally, add the following methods to adjusting the volume of all audio:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Increases volume of all audio by the specified amount.
/// &lt;/summary&gt;
/// &lt;param name=&quot;amount&quot;&gt;The amount to increase the audio by.&lt;/param&gt;
public void IncreaseVolume(float amount)
{
    if (!IsMuted)
    {
        MediaPlayer.Volume = Math.Min(MediaPlayer.Volume + amount, 1.0f);
        SoundEffect.MasterVolume = Math.Min(SoundEffect.MasterVolume + amount, 1.0f);
    }
}

/// &lt;summary&gt;
/// Decreases the volume of all audio by the specified amount.
/// &lt;/summary&gt;
/// &lt;param name=&quot;amount&quot;&gt;The amount to decrease the audio by.&lt;/param&gt;
public void DecreaseVolume(float amount)
{
    if (!IsMuted)
    {
        MediaPlayer.Volume = Math.Max(MediaPlayer.Volume - amount, 0.0f);
        SoundEffect.MasterVolume = Math.Max(SoundEffect.MasterVolume - amount, 0.0f);
    }
}
</code></pre>
<ul>
<li><code>IncreaseVolume</code>: Raises the volume of both music and sound effects by the specified amount, ensuring it doesn't exceed the maximum (1.0f).</li>
<li><code>DecreaseVolume</code>: Lowers the volume of both music and sound effects by the specified amount, ensuring it doesn't go below zero.</li>
</ul>
<h3 id="using-the-audiomanager">Using the AudioManager</h3>
<p>Now that we have our <code>AudioManager</code> class to handle audio, let's update our game to use it instead of managing audio directly. We'll remove the individual audio fields and update our collision response code to use the manager.</p>
<p>Open <em>Game1.cs</em> and make the following changes to use the new audio manager:</p>
<ol>
<li><p>First, remove the individual audio fields <code>_bounceSound</code>, <code>_collectSound</code>, and <code>_backgroundMusic</code> and add an <code>AudioManger</code> field:</p>
<pre><code class="lang-cs">private AudioManager _audioManager;
</code></pre>
</li>
<li><p>In the constructor, create the manager and add it as a game component:</p>
<pre><code class="lang-cs">// Create and add the audio manager
_audioManager = new AudioManager(this);
Components.Add(_audioManager);
</code></pre>
</li>
<li><p>Update <a href="xref:Microsoft.Xna.Framework.Game.Initialize"><strong>Initialize</strong></a> to play the background music through the audio manager instead of the <a href="xref:Microsoft.Xna.Framework.Media.MediaPlayer"><strong>MediaPlayer</strong></a>:</p>
<pre><code class="lang-cs">// Start playing background music
_audioManager.PlaySong(&quot;audio/theme&quot;);
</code></pre>
</li>
<li><p>Update <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> to load audio through the manager:</p>
<pre><code class="lang-cs">// Load audio content
_audioManager.AddSoundEffect(&quot;audio/bounce&quot;);
_audioManager.AddSoundEffect(&quot;audio/collect&quot;);
_audioManager.AddSong(&quot;audio/theme&quot;);

// Start playing background music
_audioManager.PlaySong(&quot;audio/theme&quot;);
</code></pre>
</li>
<li><p>Update <code>HandleKeyboardInput</code> to use the manager for audio controls:</p>
<pre><code class="lang-cs">if (InputManager.Keyboard.WasKeyJustPressed(Keys.M))
{
    _audioManager.ToggleMute();
}

if (InputManager.Keyboard.WasKeyJustPressed(Keys.OemPlus))
{
    _audioManager.IncreaseVolume(0.1f);
}

if (InputManager.Keyboard.WasKeyJustPressed(Keys.OemMinus))
{
    _audioManager.DecreaseVolume(0.1f);
}
</code></pre>
</li>
<li><p>Update the collision response in <code>UpdateBatMovement</code> to play the bounce sound effect using the manager:</p>
<pre><code class="lang-cs">// Play bounce sound through the manager
_audioManager.PlaySoundEffect(&quot;audio/bounce&quot;);
</code></pre>
</li>
<li><p>Update the collision response in <a href="xref:Microsoft.Xna.Framework.Game.Update(Microsoft.Xna.Framework.GameTime)"><strong>Update</strong></a> to play the collect sound effect using the manager:</p>
<pre><code class="lang-cs">// Play collect sound through the manager
_audioManager.PlaySoundEffect(&quot;audio/collect&quot;);
</code></pre>
</li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>Since we added the <code>AudioManager</code> as a game component, we don't need to worry about updating or disposing of audio resources - the component system handles this automatically.</p>
</div>
<p>Running the game now, you'll have the same audio feedback as before, but with better management of audio resources and additional features like volume control and muting. Try using the following controls:</p>
<ul>
<li>M key to toggle mute/unmute.</li>
<li>Plus (+) key to increase volume.</li>
<li>Minus (-) key to decrease volume.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Let's review what you accomplished in this chapter:</p>
<ul>
<li>Learned about MonoGame's audio system including sound effects and music.</li>
<li>Added sound effects to our game for:
<ul>
<li>Bat bouncing off screen edges.</li>
<li>Slime collecting the bat.</li>
</ul>
</li>
<li>Implemented background music.</li>
<li>Created a reusable <code>AudioManager</code> class that:
<ul>
<li>Manages loading and playback of audio content.</li>
<li>Handles volume control and muting.</li>
<li>Automatically cleans up audio resources.</li>
<li>Integrates with the game component system.</li>
</ul>
</li>
</ul>
<p>In the next chapter, we'll explore scene management to handle different game screens like a title screen and a gameplay screen.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What are the two main classes MonoGame provides for audio playback and how do they differ?</p>
<details>
<summary>Question 1 Answer</summary>
<blockquote>
<p>MonoGame provides <a href="xref:Microsoft.Xna.Framework.Audio.SoundEffect"><strong>SoundEffect</strong></a> for short audio clips (loaded entirely into memory, multiple can play at once) and <a href="xref:Microsoft.Xna.Framework.Media.Song"><strong>Song</strong></a> for longer audio like music (streamed from storage, only one can play at a time).</p>
</blockquote>
</details><br>
</li>
<li><p>What is the advantage of using the content pipeline for loading audio files?</p>
<details>
<summary>Question 2 Answer</summary>
<blockquote>
<p>The content pipeline processes audio files into an optimized format for your target platform, manages asset copying to the output directory, and provides a consistent way to load content at runtime through the <a href="xref:Microsoft.Xna.Framework.Content.ContentManager"><strong>ContentManager</strong></a>.</p>
</blockquote>
</details><br>
</li>
<li><p>Why did we create the <code>AudioManager</code> as a game component?</p>
<details>
<summary>Question 3 Answer</summary>
<blockquote>
<p>By inheriting from <a href="xref:Microsoft.Xna.Framework.GameComponent"><strong>GameComponent</strong></a>, the <code>AudioManager</code> receives automatic updates and cleanup through the game's component system.</p>
</blockquote>
</details><br>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
  </body>
</html>
