<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Aristurtle | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Aristurtle | Aristurtle </title>
    <meta name="description" content="Official site of all Aristurtle related things">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Aristurtle | Aristurtle ">
    <meta name="og:description" content="Official site of all Aristurtle related things">
    <meta name="og:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/.html">
    <meta name="twitter:title" content="Aristurtle | Aristurtle ">
    <meta name="twitter:description" content="Official site of all Aristurtle related things">
    <meta name="twitter:image" content="https://aristurtle.net/images/aristurtle.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="../../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="introduction-to-shaders">Introduction to Shaders</h1>
<p class="text-secondary">Learn how to create custom visual effects using shaders in MonoGame</p>
<p>In the previous chapters, we've built a complete snake-style game with animations, collision detection, audio, and scene management. While our game is fully functional, we can enhance the visual experience by implementing special effects to provide additional feedback to players. One powerful way to create these effects is through shaders.</p>
<p>In this chapter, you will:</p>
<ul>
<li>Understand what shaders are and how they function in MonoGame.</li>
<li>Learn about different types of shaders including vertex and pixel shaders.</li>
<li>Explore shader models and cross-platform considerations.</li>
<li>Analyze the default shader template used in MonoGame.</li>
<li>Create a custom grayscale shader for visual feedback.</li>
</ul>
<div class="IMPORTANT">
<h5>Important</h5>
<p>This chapter is an introduction to shaders in MonoGame and will focus on the basic foundation of understanding how to create shader effect (.fx) files, loading them through the content pipeline, and using them in your game.</p>
<p>It is out of scope for this tutorial series to go into depth about the syntax and many built in functions for the shader language itself.  If you would like to dive deeper into learning the language itself, a good place to start would be the <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl">Microsoft Learn: High-level shader language (HLSL)</a> documentation.</p>
</div>
<p>Let's start by understanding what shaders are and how they work in MonoGame.</p>
<h2 id="understanding-shaders">Understanding Shaders</h2>
<p>Shaders are small programs that run directly on your graphics card (GPU) instead of your computer's main processor (CPU). While traditional game code runs on the CPU and handles things like game logic and physics, shaders run on the GPU and focus specifically on how things are drawn to the screen. This separation allows for efficient processing and enables visual effects that would be too performance-intensive to calculate on the CPU.</p>
<p>Think of shaders as special instructions that tell your GPU exactly how to display each pixel or transform each vertex in your game. By customizing these instructions, you can create a wide variety of visual effects without having to change your original artwork.</p>
<h3 id="types-of-shaders">Types of Shaders</h3>
<p>There are two main types of shaders that you'll work with in MonoGame:</p>
<h4 id="vertex-shaders">Vertex Shaders</h4>
<p>Vertex shaders process the corners (vertices) of the shapes that make up your game objects. They determine where these points should be positioned on the screen and can manipulate their positions to create effects like:</p>
<ul>
<li>Waves or ripples in water</li>
<li>Swaying grass or trees</li>
<li>Character deformation for animations</li>
</ul>
<p>Vertex shaders are especially important in 3D games, but they can also be used in 2D games for special effects that involve moving or distorting sprite positions.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Even in 2D games like ours, MonoGame actually draws sprites by mapping textures onto simple 3D shapes called quads (rectangles made of two triangles). Each quad has four vertices, one at each corner. While we don't normally think about these vertices in 2D development, they're still there behind the scenes, and vertex shaders process them before rendering.</p>
</div>
<h4 id="pixel-shaders">Pixel Shaders</h4>
<p>Pixel shaders (also sometimes called fragment shaders) determine the actual color of each pixel that gets drawn to the screen. After the GPU figures out which pixels need to be drawn based on your geometry, the pixel shader calculates the final color for each of those pixels.</p>
<p>Pixel shaders are useful in 2D games for creating effects like:</p>
<ul>
<li>Color adjustments (brightness, contrast, saturation)</li>
<li>Visual filters (grayscale, sepia, negative)</li>
<li>Special transitions (fades, dissolves, color shifts)</li>
<li>Dynamic lighting effects</li>
</ul>
<p>For our Dungeon Slime game, we'll focus primarily on pixel shaders since we want to create a color effect for our game over state.</p>
<h3 id="shader-languages-and-cross-platform-considerations">Shader Languages and Cross-Platform Considerations</h3>
<p>MonoGame uses High-Level Shader Language (HLSL) for writing shader effects. HLSL is a C-like programming language developed by Microsoft for DirectX. However, since MonoGame supports multiple platforms, including those that use OpenGL instead of DirectX, it needs a way to make shaders work everywhere.</p>
<p>This is where MojoShader comes in. MojoShader is a library that automatically translates your HLSL shader code into whatever format the target platform requires (like GLSL for OpenGL platforms). This translation happens during the content build process when you compile your game.</p>
<h3 id="shader-models-and-compatibility">Shader Models and Compatibility</h3>
<p>Different platforms support different shader capabilities, known as &quot;shader models.&quot; When writing shaders for MonoGame, you need to consider compatibility across platforms. MonoGame supports the following shader models when targeting DirectX platforms:</p>
<table>
<thead>
<tr>
<th>Vertex Shader Model</th>
<th>Pixel Shader Model</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vs_4_0_level_9_1</code></td>
<td><code>ps_4_0_level_9_1</code></td>
</tr>
<tr>
<td><code>vs_4_0_level_9_3</code></td>
<td><code>ps_4_0_level_9_3</code></td>
</tr>
<tr>
<td><code>vs_4_0</code></td>
<td><code>ps_4_0</code></td>
</tr>
<tr>
<td><code>vs_4_1</code></td>
<td><code>ps_4_1</code></td>
</tr>
<tr>
<td><code>vs_5_0</code></td>
<td><code>ps_5_0</code></td>
</tr>
</tbody>
</table>
<p>When targeting OpenGL platforms, MonoGame supports:</p>
<table>
<thead>
<tr>
<th>Vertex Shader Model</th>
<th>Pixel Shader Model</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vs_2_0</code></td>
<td><code>ps_2_0</code></td>
</tr>
<tr>
<td><code>vs_3_0</code></td>
<td><code>ps_3_0</code></td>
</tr>
</tbody>
</table>
<p>For maximum compatibility, it's best to target the lower shader models:</p>
<ul>
<li>For DirectX platforms: <code>vs_4_0_level_9_1</code> (vertex) and <code>ps_4_0_level_9_1</code> (pixel)</li>
<li>For OpenGL platforms: <code>vs_2_0</code> (vertex) and <code>ps_2_0</code> (pixel)</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>In shader model notation, &quot;vs&quot; stands for &quot;vertex shader&quot; and &quot;ps&quot; stands for &quot;pixel shader&quot;. The numbers represent the version and feature level of the shader model, with higher numbers indicating more advanced capabilities.</p>
</div>
<h2 id="understanding-the-default-shader-template">Understanding the Default Shader Template</h2>
<p>When you create a new Sprite Effect (.fx) file in MonoGame using the MGCB Editor, it generates a default template file.  Let's example this template to understand the foundation we'll build upon:</p>
<pre><code class="lang-c">#if OPENGL
    #define SV_POSITION POSITION
    #define VS_SHADERMODEL vs_3_0
    #define PS_SHADERMODEL ps_3_0
#else
    #define VS_SHADERMODEL vs_4_0_level_9_1
    #define PS_SHADERMODEL ps_4_0_level_9_1
#endif

Texture2D SpriteTexture;

sampler2D SpriteTextureSampler = sampler_state
{
    Texture = &lt;SpriteTexture&gt;;
};

struct VertexShaderOutput
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR0;
    float2 TextureCoordinates : TEXCOORD0;
};

float4 MainPS(VertexShaderOutput input) : COLOR
{
    return tex2D(SpriteTextureSampler,input.TextureCoordinates) * input.Color;
}

technique SpriteDrawing
{
    pass P0
    {
        PixelShader = compile PS_SHADERMODEL MainPS();
    }
};
</code></pre>
<p>Let's break down what each section of this template is:</p>
<ol>
<li><p><strong>Platform compatibility defines</strong>: The first block created defines for different shader model versions based on the target platform the shader gets compiled for (OpenGL vs DirectX).</p>
<pre><code class="lang-c">#if OPENGL
    #define SV_POSITION POSITION
    #define VS_SHADERMODEL vs_3_0
    #define PS_SHADERMODEL ps_3_0
#else
    #define VS_SHADERMODEL vs_4_0_level_9_1
    #define PS_SHADERMODEL ps_4_0_level_9_1
#endif
</code></pre></li>
<li><p><strong>Texture declaration</strong>: This declares a <code>Texture2D</code> variable called <code>SpriteTexture</code> that will receive the texture being drawn by the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>.</p>
<pre><code class="lang-c">Texture2D SpriteTexture;
</code></pre></li>
<li><p><strong>Sampler state</strong>: This creates a <code>sampler2D</code> called <code>SpriteTextureSampler</code> that is used sample the texture received from the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>.  Think of this as similar to the <a href="xref:Microsoft.Xna.Framework.Graphics.SamplerState"><strong>SamplerState</strong></a> we discussed in <a href="../18_texture_sampling/index.html">Chapter 18</a>.</p>
<pre><code class="lang-c">sampler2D SpriteTextureSampler = sampler_state
{
    Texture = &lt;SpriteTexture&gt;;
};
</code></pre></li>
<li><p><strong>Vertex shader output structure</strong>: This defines a struct called <code>VertexShaderOutput</code> with three fields; <code>Position</code>, <code>Color</code>, and <code>TextureCoordinates</code>.  This struct represents the data that is passed from the <strong>Vertex Shader</strong> function to the <strong>Pixel Shader</strong> function.</p>
<pre><code class="lang-c">struct VertexShaderOutput
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR0;
    float2 TextureCoordinates : TEXCOORD0;
};
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>Notice the unusual syntax like <code>float4 Position : SV_POSITION</code> where there's a colon followed by something after each variable declaration.  These are called <em>semantics</em> in HLSL and they're special labels that define how the data should be used by the graphics hardware or passed between shader stages (like from vertex shader to pixel shader).</p>
<p>For example, <code>SV_POSITION</code> tells the system &quot;this contains the final screen position,&quot; <code>COLOR0</code> means &quot;this contains color data,&quot; and <code>TEXCOORD0</code> means &quot;this contains texture coordinates.&quot;</p>
<p>Semantics are required in HLSL to connect your shader variables with the graphics pipeline.  Without them, the GPU would not know what each piece of data represents or how to use it correctly.</p>
</div>
</li>
<li><p><strong>Pixel shader function</strong>: <code>MainPS</code> is the main <strong>Pixel Shader</strong> function that determines the color of each pixel.  The default implementation simply samples the texture at the current texture coordinates and multiplies it by the vertex color, which is the color value supplied in the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> method call.</p>
<pre><code class="lang-c">float4 MainPS(VertexShaderOutput input) : COLOR
{
    return tex2D(SpriteTextureSampler,input.TextureCoordinates) * input.Color;
}
</code></pre></li>
<li><p><strong>Technique and pass</strong>: This block defines a technique called <code>SpriteDrawing</code> with a single pass called <code>P0</code>.  The pass itself defines which shader functions to use.</p>
<pre><code class="lang-c">technique SpriteDrawing
{
    pass P0
    {
        PixelShader = compile PS_SHADERMODEL MainPS();
    }
};
</code></pre></li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>You may have noticed that the default shader does not define a vertex shader method that would execute and return back the <code>VertexShaderOutput</code> value that is used as the input for the <strong>Pixel Shader</strong> function.</p>
<p>When you're using <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>, MonoGame uses a built-in vertex shader under the hood that executes and creates this value to pass to the pixel shader function.</p>
</div>
<h3 id="understanding-techniques-and-passes">Understanding Techniques and Passes</h3>
<p>The <code>technique</code> and <code>pass</code> sections might seem a bit confusing at first, but they're actually quite straightforward:</p>
<ul>
<li>A <strong>technique</strong> is like a recipe for rendering something.  Each technique has a name (in this case <code>SpriteDrawing</code>) and contains one or more passes.</li>
<li>A <strong>pass</strong> is a single step in that recipe.  For simple effects, you often need just one pass (which is why the template only has <code>P0</code>), but more complex effects might use multiple passes to build up a final result.</li>
</ul>
<p>Think of it like baking a cake:</p>
<ul>
<li>The technique is the overall cake recipe.</li>
<li>Each pass is a step in that recipe (mix ingredients, bake, add frosting, etc).</li>
</ul>
<p>In simple shaders, such as a grayscale shader, you would only need one technique with one pass.  For more complex effects like blur, you might use multiple passes: one to blur horizontally and another to blur vertically.</p>
<p>The line <code>PixelShader = compile PS_SHADERMODEL MainPS();</code> simply tells the GPU which pixel shader function to use for this pass (in this case the <code>MainPS</code> function) and compiles it using the appropriate shader model defined earlier.</p>
<h2 id="loading-shader-effects">Loading Shader Effects</h2>
<p>Shader effects are loaded in MonoGame using the content manager, much like any other asset that is compiled using the content pipeline.  The type to use when loading a shader is <a href="xref:Microsoft.Xna.Framework.Graphics.Effect"><strong>Effect</strong></a>.</p>
<pre><code class="lang-cs">// Example of loading an effect
Effect exampleEffect = Content.Load&lt;Effect&gt;(&quot;exampleEffect&quot;);
</code></pre>
<p>You should typically load shader effects during your game's <a href="xref:Microsoft.Xna.Framework.Game.LoadContent"><strong>LoadContent</strong></a> method along with other game assets, and store them in class fields so they can be accessed during the <a href="xref:Microsoft.Xna.Framework.Game.Draw(Microsoft.Xna.Framework.GameTime)"><strong>Draw</strong></a> method.</p>
<h2 id="using-effects-with-spritebatch">Using Effects With SpriteBatch</h2>
<p>Once you've loaded a shader effect, applying it to your game's visuals requires integrating it with the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>. The effect is specified during the <code>Begin</code> call, but is actually applied during drawing operations or when <code>End</code> is called (depending on the SpriteSortMode).</p>
<pre><code class="lang-cs">// Specify the effect during Begin
spriteBatch.Begin(effect: exampleEffect);

// The effect will be applied when these draw calls are processed
spriteBatch.Draw(exampleTexture, texturePosition, Color.White);
spriteBatch.DrawString(exampleFont, &quot;Hello World&quot;, textPosition, Color.White);

// For most SpriteSortMode values, actual drawing with the effect happens here
spriteBatch.End();
</code></pre>
<h3 id="setting-effect-parameters">Setting Effect Parameters</h3>
<p>Most shader effects have parameters that you can adjust to control their behavior. For example, the shader we'll create for our game will have a Saturation parameter. You should set these parameters before the actual drawing occurs:</p>
<pre><code class="lang-cs">// Update the parameter value
exampleEffect.Parameters[&quot;Saturation&quot;].SetValue(0.5f);

// Specify the effect during Begin
spriteBatch.Begin(effect: exampleEffect);

// Draw calls will use the effect with Saturation = 0.5f when processed
</code></pre>
<h2 id="creating-a-grayscale-shader">Creating a Grayscale Shader</h2>
<p>Now that we understand the basics of shaders, we will create a simple grayscale effect that we can apply when the game is paused or there is a game over to provide visual feedback to the player that the game is inactive.</p>
<h3 id="creating-the-shader-file">Creating the Shader File</h3>
<p>First, we need to create a new shader effect file and add it to our content project.</p>
<ol>
<li>In the <em>DungeonSlime</em> project (your main game project), open the <em>/Content/Content.mgcb</em> content project file in the MGCB Editor.</li>
<li>In the MGCB Editor, right-click the <em>Content</em> now and choose <em>Add</em> &gt; <em>New Folder...</em>.</li>
<li>Give the new folder the name <em>effects</em> and click the &quot;Ok&quot; button.</li>
<li>Right-click on the new <em>effects</em> folder in the MGCB Editor and choose *Add &gt; <em>New Item...</em>.</li>
<li>Choose <em>Sprite Effect (.fx)</em> from the type list and name the file <em>grayscaleEffect</em>, then click the &quot;Ok&quot; button.</li>
<li>Save the changes in the MGCB Editor the close it.</li>
</ol>
<p>The steps above will create a new shader effect (<em>.fx</em>) file with the default template we discussed earlier.  Now, we need to modify this template to create our grayscale effect.</p>
<h3 id="writing-the-grayscale-shader">Writing the Grayscale Shader</h3>
<p>In the <em>DungeonSlime</em> project (your main game project), open the <em>Content/effects/grayscaleEffect.fx</em> file that we just created and modify it as follows:</p>
<pre><code class="lang-c" highlight-lines="12-14,30-44">#if OPENGL
    #define SV_POSITION POSITION
    #define VS_SHADERMODEL vs_3_0
    #define PS_SHADERMODEL ps_3_0
#else
    #define VS_SHADERMODEL vs_4_0_level_9_1
    #define PS_SHADERMODEL ps_4_0_level_9_1
#endif

Texture2D SpriteTexture;

// A value between 0 and 1 that controls the intensity of the grayscale effect.
// 0 = full color, 1 = full grayscale.
float Saturation = 1.0;

sampler2D SpriteTextureSampler = sampler_state
{
    Texture = &lt;SpriteTexture&gt;;
};

struct VertexShaderOutput
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR0;
    float2 TextureCoordinates : TEXCOORD0;
};

float4 MainPS(VertexShaderOutput input) : COLOR
{
    // Sample the texture
    float4 color = tex2D(SpriteTextureSampler, input.TextureCoordinates) * input.Color;

    // Calculate the grayscale value based on human perception of colors
    float grayscale = dot(color.rgb, float3(0.3, 0.59, 0.11));

    // create a grayscale color vector (same value for R, G, and B)
    float3 grayscaleColor = float3(grayscale, grayscale, grayscale);

    // Linear interpolation between he grayscale color and the original color's
    // rgb values based on the saturation parameter.
    float3 finalColor = lerp(grayscale, color.rgb, Saturation);

    // Return the final color with the original alpha value
    return float4(finalColor, color.a);
}

technique SpriteDrawing
{
    pass P0
    {
        PixelShader = compile PS_SHADERMODEL MainPS();
    }
};
</code></pre>
<p>The key modifications made to create this grayscale effect include:</p>
<ol>
<li><p><strong>Added a Parameter</strong>: A <code>Saturation</code> parameter was added that controls he intensity fo the grayscale effect.  When set to 0, the image will be fully grayscale.  When set to 1, the image will be its original color.  Values in between create a partial grayscale effect.</p>
</li>
<li><p><strong>Modified the Pixel Shader</strong>: The <code>MainPS</code> function has been updated to:</p>
<ul>
<li>Sample the original color from the texture.</li>
<li>Calculate a grayscale value by taking a weighted average of the RGB components.</li>
<li>Create a grayscale color vector from this single brightness value.</li>
<li>Use <code>lerp</code> (linear interpolation) to blend between the grayscale and original color's rgb values based on the <code>Saturation</code> parameter.</li>
<li>Preserve the original alpha (transparency) value.</li>
</ul>
</li>
</ol>
<h4 id="understanding-the-shader-code">Understanding the Shader Code</h4>
<p>The heart of the grayscale effect is this line</p>
<pre><code class="lang-c">#if OPENGL
    #define SV_POSITION POSITION
    #define VS_SHADERMODEL vs_3_0
    #define PS_SHADERMODEL ps_3_0
#else
    #define VS_SHADERMODEL vs_4_0_level_9_1
    #define PS_SHADERMODEL ps_4_0_level_9_1
#endif

Texture2D SpriteTexture;

// A value between 0 and 1 that controls the intensity of the grayscale effect.
// 0 = full color, 1 = full grayscale.
float Saturation = 1.0;

sampler2D SpriteTextureSampler = sampler_state
{
    Texture = &lt;SpriteTexture&gt;;
};

struct VertexShaderOutput
{
    float4 Position : SV_POSITION;
    float4 Color : COLOR0;
    float2 TextureCoordinates : TEXCOORD0;
};

float4 MainPS(VertexShaderOutput input) : COLOR
{
    // Sample the texture
    float4 color = tex2D(SpriteTextureSampler, input.TextureCoordinates) * input.Color;

    // Calculate the grayscale value based on human perception of colors
    float grayscale = dot(color.rgb, float3(0.3, 0.59, 0.11));

    // create a grayscale color vector (same value for R, G, and B)
    float3 grayscaleColor = float3(grayscale, grayscale, grayscale);

    // Linear interpolation between he grayscale color and the original color's
    // rgb values based on the saturation parameter.
    float3 finalColor = lerp(grayscale, color.rgb, Saturation);

    // Return the final color with the original alpha value
    return float4(finalColor, color.a);
}

technique SpriteDrawing
{
    pass P0
    {
        PixelShader = compile PS_SHADERMODEL MainPS();
    }
};
</code></pre>
<p>This uses the <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-dot"><code>dot</code></a> function to calculate the do product between the color's RGB values and the vector <span class="math">\((0.3, 0.59, 0.11)\)</span>.  This effectively calculates a weighted average where:</p>
<ul>
<li>Red contributes 30%.</li>
<li>Green contributes 59%.</li>
<li>Blue contributes 11%.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>These specific weights are based on how the human eye perceives brightness in different colors.  Green appears brighter to us than red, which appears brighter than blue.</p>
<p>The weighted values themselves are based on the formula that represents the luma component from the <a href="https://en.wikipedia.org/wiki/Rec._601">ITU-R BT.601</a> standard, which is commonly used for converting RGB images to grayscale based on human perception where:</p>
<p><span class="math">\(Y'_{601} = 0.299R' + 0.587G' + 0.114B'\)</span></p>
<p>By using these weights, we get a natural looking grayscale conversion.</p>
</div>
<p>Then, we use linear interpolation with the <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-lerp"><code>lerp</code></a> function to blend between this grayscale value and the original color's RGB values:</p>
<pre><code class="lang-c">// Linear interpolation between he grayscale color and the original color's
// rgb values based on the saturation parameter.
float3 finalColor = lerp(grayscale, color.rgb, Saturation);
</code></pre>
<p>The <code>lerp</code> function blends between the first two parameters based on the third parameter (<code>Saturation</code>).  When <code>Saturation</code> is 0, we get full grayscale.  When it is 1, we get the original color.</p>
<h3 id="implementing-the-grayscale-shader">Implementing the Grayscale Shader</h3>
<p>Now that we have our grayscale shader, we can implement it in our game when the game is paused or a game over state occurs.  In the <em>DungeonSlime</em> project (your main game project), open the <em>Scenes/GameScene.cs</em> file and perform the following:</p>
<ol>
<li><p>First, add these fields to the <code>GameScene</code> class:</p>
<pre><code class="lang-csharp">// The grayscale shader effect.
private Effect _grayscaleEffect;

// The amount of saturation to provide the grayscale shader effect
private float _saturation = 1.0f;

// The speed of the fade to grayscale effect.
private const float FADE_SPEED = 0.02f;
</code></pre></li>
<li><p>Next, update the <code>LoadContent</code> method to load the grayscale shader:</p>
<pre><code class="lang-csharp" highlight-lines="30-31">public override void LoadContent()
{
    // Create the texture atlas from the XML configuration file
    TextureAtlas atlas = TextureAtlas.FromFile(Core.Content, &quot;images/atlas-definition.xml&quot;);

    // Create the tilemap from the XML configuration file.
    _tilemap = Tilemap.FromFile(Content, &quot;images/tilemap-definition.xml&quot;);
    _tilemap.Scale = new Vector2(4.0f, 4.0f);

    // Create the animated sprite for the slime from the atlas.
    AnimatedSprite slimeAnimation = atlas.CreateAnimatedSprite(&quot;slime-animation&quot;);
    slimeAnimation.Scale = new Vector2(4.0f, 4.0f);

    // Create the slime
    _slime = new Slime(slimeAnimation);

    // Create the animated sprite for the bat from the atlas.
    AnimatedSprite batAnimation = atlas.CreateAnimatedSprite(&quot;bat-animation&quot;);
    batAnimation.Scale = new Vector2(4.0f, 4.0f);

    // Load the bounce sound effect for the bat
    SoundEffect bounceSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/bounce&quot;);

    // Create the bat
    _bat = new Bat(batAnimation, bounceSoundEffect);

    // Load the collect sound effect
    _collectSoundEffect = Content.Load&lt;SoundEffect&gt;(&quot;audio/collect&quot;);

    // Load the grayscale effect
    _grayscaleEffect = Content.Load&lt;Effect&gt;(&quot;effects/grayscaleEffect&quot;);
}
</code></pre></li>
<li><p>Next, update the <code>TogglePause</code> method so that when the game is paused, it sets the saturation value to 1.0f</p>
<pre><code class="lang-csharp" highlight-lines="19-20">private void TogglePause()
{
    if (_state == GameState.Paused)
    {
        // We're now unpausing the game, so hide the pause panel
        _ui.HidePausePanel();

        // And set the state back to playing
        _state = GameState.Playing;
    }
    else
    {
        // We're now pausing the game, so show the pause panel
        _ui.ShowPausePanel();

        // And set the state to paused
        _state = GameState.Paused;

        // Set the grayscale effect saturation to 1.0f;
        _saturation = 1.0f;
    }
}
</code></pre></li>
<li><p>We also need to update the <code>GameOver</code> method so that when a game over state occurs, it sets the saturation value to 1.0f:</p>
<pre><code class="lang-csharp" highlight-lines="9-10">private void GameOver()
{
    // Show the game over panel
    _ui.ShowGameOverPanel();

    // Set the game state to game over
    _state = GameState.GameOver;

    // Set the grayscale effect saturation to 1.0f;
    _saturation = 1.0f;
}
</code></pre></li>
<li><p>Next, modify the <code>Update</code> method to handle the grayscale transition:</p>
<pre><code class="lang-csharp" highlight-lines="6-17">public override void Update(GameTime gameTime)
{
    // Ensure the UI is always updated
    _ui.Update(gameTime);

    if (_state != GameState.Playing)
    {
        // The game is in either a paused or game over state, so
        // gradually decrease the saturation to create the fading grayscale.
        _saturation = Math.Max(0.0f, _saturation - FADE_SPEED);

        // If its just a game over state, return back
        if (_state == GameState.GameOver)
        {
            return;
        }
    }

    // If the pause button is pressed, toggle the pause state
    if (GameController.Pause())
    {
        TogglePause();
    }

    // At this point, if the game is paused, just return back early
    if (_state == GameState.Paused)
    {
        return;
    }

    // Update the slime;
    _slime.Update(gameTime);

    // Update the bat;
    _bat.Update(gameTime);

    // Perform collision checks
    CollisionChecks();
}
</code></pre></li>
<li><p>Finally, update the <code>Draw</code> method to apply the shader when the game is paused or in a game over state:</p>
<pre><code class="lang-csharp" highlight-lines="6-18">public override void Draw(GameTime gameTime)
{
    // Clear the back buffer.
    Core.GraphicsDevice.Clear(Color.CornflowerBlue);

    if (_state != GameState.Playing)
    {
        // We are in a game over state, so apply the saturation parameter.
        _grayscaleEffect.Parameters[&quot;Saturation&quot;].SetValue(_saturation);

        // And begin the sprite batch using the grayscale effect.
        Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp, effect: _grayscaleEffect);
    }
    else
    {
        // Otherwise, just begin the sprite batch as normal.
        Core.SpriteBatch.Begin(samplerState: SamplerState.PointClamp);
    }

    // Draw the tilemap
    _tilemap.Draw(Core.SpriteBatch);

    // Draw the slime.
    _slime.Draw();

    // Draw the bat.
    _bat.Draw();

    // Always end the sprite batch when finished.
    Core.SpriteBatch.End();

    // Draw the UI
    _ui.Draw();
}
</code></pre></li>
</ol>
<p>With these changes, when the game enters a paused or game over state, the screen will gradually fade to gray using the grayscale shader effect.  This provides a clear indication that the game is inactive during these states.</p>
<h2 id="important-considerations">Important Considerations</h2>
<p>When working with effects in <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>, there are some important points to keep in mind:</p>
<ol>
<li><p>Only one effect can be applied to a <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a>/<a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> at a time.  If you need to use multiple effects for different sprites, you'll need multiple <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a>/<a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> blocks.</p>
<pre><code class="lang-cs">// Begin sprite batch with effect.  All draw calls made within this begin/end block will have the effect applied.
spriteBatch.Begin(effect: exampleEffect1)
spriteBatch.Draw(texture, position, color);
spriteBatch.End();

// Begins sprite batch with a different effect.  All draw calls made within this begin/end block will have the specified effect applied.
spriteBatch.Begin(effect: exampleEffect2)
spriteBatch.DrawS(texture, position, color);
spriteBatch.End();
</code></pre>
</li>
<li><p>Along with #1 above, if you want to be selective and only have the effect apply to some sprites and not others, you'll need to use multiple <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a>/<a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> blocks</p>
<pre><code class="lang-cs">// Begin sprite batch with effect.  All draw calls made within this begin/end block will have the specified effect applied.
spriteBatch.Begin(effect: exampleEffect)
spriteBatch.Draw(texture, position, color);
spriteBatch.End();

// Begin sprite batch without effect so that draw calls made here have no effect applied.
spriteBatch.Begin();
spriteBatch.Draw(texture, position, color);
spriteBatch.End();

</code></pre>
</li>
<li><p>Even though the effect to use is specified during the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a> call, the actual effect is not applied until all batched items are processed when <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> is called.  This means if you adjust parameter values of the effect between draw calls, the last parameter value set is what is applied to all draw calls within the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Begin(Microsoft.Xna.Framework.Graphics.SpriteSortMode,Microsoft.Xna.Framework.Graphics.BlendState,Microsoft.Xna.Framework.Graphics.SamplerState,Microsoft.Xna.Framework.Graphics.DepthStencilState,Microsoft.Xna.Framework.Graphics.RasterizerState,Microsoft.Xna.Framework.Graphics.Effect,System.Nullable%7BMicrosoft.Xna.Framework.Matrix%7D)"><strong>SpriteBatch.Begin</strong></a>.</p>
<pre><code class="lang-cs">// Begin sprite batch with effect.
// Specifying the effect here is only specifying what effect to apply when batching ends
spriteBatch.Begin(effect: exampleEffect);

// Change a parameter and draw something
exampleEffect.Parameters[&quot;ExampleParameter&quot;].SetValue(1.0f);
spriteBatch.Draw(texture1, position, color);

// Change the parameter to a different value and draw something else.
exampleEffect.Parameters[&quot;ExampleParameter&quot;].SetValue(0.5f);
spriteBatch.Draw(texture2, position, color);

// The actual effect is applied to the draw calls here, when End is called.
// This means the value of the parameter that will be used in the effect
// is the last parameter value set (0.5f) which will be applied to both
// draw calls instead of each of them having different parameter values.
spriteBatch.End();
</code></pre>
</li>
<li><p>There is an exception to #2 above.  In <a href="../06_working_with_textures/index.html#layer-depth">Chapter 06: Working with Textures</a>, we discussed the different <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode"><strong>SpriteSortMode</strong></a> values that can be used when rendering.  From this chapter, we learned that when using <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode"><strong>SpriteSortMode.Immediate</strong></a> that when a draw call is made, it is immediately flushed to the GPU and rendered to the screen, ignoring batching.  This means that if you are using <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode"><strong>SpriteSortMode.Immediate</strong></a> then changing parameters between draw calls will apply the parameter change after it is made for the next draw call.  However, as mentioned in that chapter, <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode"><strong>SpriteSortMode.Immediate</strong></a> can cause performance issues and should only be used when absolutely necessary.</p>
<pre><code class="lang-cs">// Begins sprite batch with the effect AND intentionally specifying SpriteSortMode.Immediate
spriteBatch.Begin(effect: exampleEffect, sortMode: SpriteSortMode.Immediate);

// Change a parameter and draw something.  Since we're in immediate mode, the value of the parameter is used because the shader is immediately applied to the draw call.
exampleEffect.Parameters[&quot;ExampleParameter&quot;].SetValue(1.0f);
spriteBatch.Draw(texture1, position, color);

// Change the parameter to something else.  Since we're in immediate mode, teh new value of the parameter is used because the shader is immediately applied to the draw call.
exampleEffect.Parameters[&quot;ExampleParameter&quot;].SetValue(0.5f);
spriteBatch.Draw(texture2, position, color);

// Since immediate mode is used, batching is not performed so the effect was applied immediately on the draw calls above and not here during the end call.
spriteBatch.End();
</code></pre>
</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>This chapter explored the fundamentals of creating and adding a shader to MonoGame by implementing a grayscale shader effect.  We covered several important concepts:</p>
<ul>
<li>Shaders are specialized programs that run directly on the GPU, allowing for efficient visual effects that would be too performance-intensive to calculate on the CPU.</li>
<li>Effect parameters allow runtime control of shader behavior.</li>
<li>In Monogame, shaders are written in High-Level Shader Language (HLSL) and can be loaded through the content pipeline like other game assets.</li>
<li>Pixel shaders determine the color of each rendered pixel, making them ideal for effects like our grayscale shader.</li>
<li>The timing of the shader application depends on the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode">**SpriteSortMode</a> used with <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch"><strong>SpriteBatch</strong></a>, with most effects being applied during the <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a> call.</li>
</ul>
<p>While we only focused on a simple grayscale effect, the principles learned here can be used to start learning more about shaders and creating more complex visual effects.</p>
<h2 id="test-your-knowledge">Test Your Knowledge</h2>
<ol>
<li><p>What is the primary difference between pixel shaders and vertex shaders in the context of 2D games?</p>
<p>::question-answer
Pixel shaders determine the color of each pixel being rendered, making them ideal for visual effects like grayscale, color tinting, and image filters. Vertex shaders manipulate the position of vertices, which can be used for effects like distortion, waves, or character deformation. In 2D games, pixel shaders are more commonly used for visual effects while vertex shaders are less frequently needed.</p>
<div></div>
</li>
<li><p>What function is used in the shader to blend between grayscale and the original color, and how does it work?</p>
<div class="question-answer"><p>The <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-lerp"><code>lerp</code></a> function (linear interpolation) is used to blend between grayscale and original colors. It takes three parameters: the first is the grayscale color vector, the second is the original color's RGB values, and the third is the <code>Saturation</code> parameter (between 0 and 1). When Saturation is 0, the output is fully grayscale; when it's 1, the output is the original color; values in between create a partial blend of both.</p>
</div>
</li>
<li><p>Why can changing effect parameters between <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,System.Nullable%7BMicrosoft.Xna.Framework.Rectangle%7D,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)"><strong>SpriteBatch.Draw</strong></a> calls sometimes not work as expected, and what is the exception to this?</p>
<div class="question-answer"><p>Changing effect parameters between draw calls typically doesn't work as expected because the effect is actually applied during <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteBatch.End"><strong>SpriteBatch.End</strong></a>, not during the draw calls. The last parameter value set before end is applied to all draw calls in the batch. The exception is when using <a href="xref:Microsoft.Xna.Framework.Graphics.SpriteSortMode"><strong>SpriteSortMode.Immediate</strong></a>, which causes each draw call to be processed immediately rather than batched, allowing parameter changes to be applied between individual draw calls.</p>
</div>
</li>
</ol>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
    <script type="text/javascript" src="/public/questionAnswer.js"></script>
  </body>
</html>
