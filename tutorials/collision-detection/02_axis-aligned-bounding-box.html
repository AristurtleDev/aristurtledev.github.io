<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="title" content="Axis-Aligned Bounding Box | Collision Detection Tutorial Series | Aristurtle ">

    <!-- HTML Meta Tags -->
    <title>Axis-Aligned Bounding Box | Collision Detection Tutorial Series | Aristurtle </title>
    <meta name="description" content="Axis-Aligned Bounding Box collision detect, or AABB for short, is one of the simplest forms of collision detection">

    <!-- Facebook Meta Tags -->
    <meta name="og:url" content="https://aristurtle.net/tutorials/collision-detection/02_axis-aligned-bounding-box.html"><meta name="og:type" content="website">
    <meta name="og:title" content="Axis-Aligned Bounding Box | Collision Detection Tutorial Series | Aristurtle ">
    <meta name="og:description" content="Axis-Aligned Bounding Box collision detect, or AABB for short, is one of the simplest forms of collision detection">
    <meta name="og:image" content="https://aristurtle.net/images/tutorials/collision-detection/axis-aligned-boxes.png">

    <!-- Twtiter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="aristurtle.net">
    <meta property="twitter:url" content="https://aristurtle.net/tutorials/collision-detection/02_axis-aligned-bounding-box.html">
    <meta name="twitter:title" content="Axis-Aligned Bounding Box | Collision Detection Tutorial Series | Aristurtle ">
    <meta name="twitter:description" content="Axis-Aligned Bounding Box collision detect, or AABB for short, is one of the simplest forms of collision detection">
    <meta name="twitter:image" content="https://aristurtle.net/images/tutorials/collision-detection/axis-aligned-boxes.png">

    <!-- Discord Meta Tags -->
    <meta name="theme-color" content="#49c961">

      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

    <!-- Matomo -->
    <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
        var u="//matomo.aristurtle.net/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '1']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
    })();
    </script>
    <!-- End Matomo Code -->

  </head>

  <script type="module" src="./../../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/logo.svg" alt="Aristurtle">
            Aristurtle
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="axis-aligned-bounding-box">Axis-Aligned Bounding Box</h1>

<p><strong>Axis-Aligned Bounding Box</strong> collision detect, or AABB for short, is one of the simplest forms of collision detection.</p>
<ul>
<li><strong>Axis-Aligned</strong> means the bounding boxes of the objects being compared for collision are aligned on both their x- and y-axes.</li>
<li><strong>Bound Box</strong> part of the name refers to a rectangular structure that defines the surface area of an object.</li>
</ul>
<p>Take, for example, the following two bounding boxes in the image below:</p>
<p><img src="../../images/tutorials/collision-detection/axis-aligned-boxes.png" alt="Axis-Aligned Boxes"></p>
<p>The x- and y-axes of both boxes are aligned, which means we can use AABB collision detection to check for collision between them.  Conversely, the following to bounding boxes are <strong>not</strong> Axis-Aligned</p>
<p><img src="../../images/tutorials/collision-detection/not-axis-aligned-bounding-boxes.png" alt="Not Axis-Aligned Boxes"></p>
<p>Being that they are not <strong>Axis-Aligned</strong>, we cannot accurately detect collision between the two using AABB collision detection.</p>
<h2 id="detecting-a-collision">Detecting a Collision</h2>
<p>When using AABB collision detection, there are four conditions that must be true in order to say &quot;a collision has occurred&quot;.  Given Bounding Box <code>[A]</code> and Bounding Box <code>[B]</code></p>
<ol>
<li>The <strong>left edge</strong> (x-position) of <code>[A]</code> must be less than the <strong>right edge</strong> (x-position + width) of <code>[B]</code>.</li>
<li>The <strong>right edge</strong> (x-position + width) of <code>[A]</code> must be greater than the <strong>left edge</strong> (x-position) of <code>[B]</code>.</li>
<li>The <strong>top edge</strong> (y-position) of <code>[A]</code> must be less than the <strong>bottom edge</strong> (y-position + height) of <code>[B]</code>.</li>
<li>The <strong>bottom edge</strong> (y-position + height) of <code>[A]</code> must be greater than the <strong>top edge</strong> (y-position) of <code>[B]</code>.</li>
</ol>
<p>If any of these four conditions are <code>false</code> even just one, then no collision has occurred.</p>
<h2 id="the-code">The Code</h2>
<p>Now that we know the conditions for AABB collision detection, let's add the code for it to our game.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>Rectangle</code> struct in MonoGame has the <code>Rectangle.Intersects</code> method which compares two <code>Rectangle</code> structs for intersection using AABB.</p>
<p>While you can, and should, just use that, the remainder of this tutorial will show how to implement it yourself so you understand what's going on under-the-hood.</p>
</div>
<p>Create a new class file called <strong>CollisionChecks.cs</strong> in the MonoGame project and add the following code</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
///     Checks for collision between two rectangular structures using
///     Axis-Aligned Bounding Box collision detection.
/// &lt;/summary&gt;
/// &lt;param name=&quot;boxA&quot;&gt;
///     The bounding box of the first structure.
/// &lt;/param&gt;
/// &lt;param name=&quot;boxB&quot;&gt;
///     The bounding box of the second structure.
/// &lt;/param&gt;
/// &lt;returns&gt;
///     True if the two structures are colliding; otherwise, false.
/// &lt;/returns&gt;
public static bool AABB(Rectangle boxA, Rectangle boxB)
{
    return boxA.Left &lt; boxB.Right &amp;&amp;
            boxA.Right &gt; boxB.Left &amp;&amp;
            boxA.Top &lt; boxB.Bottom &amp;&amp;
            boxA.Bottom &gt; boxB.Top;
}
</code></pre>
<p>The method itself is pretty simple. It takes in two <code>Rectangle</code> values, then performs each fo the four checks for AABB collision detection.  If any single check in the logic is <code>false</code> then the method will return false.  It will only return <code>true</code> if all four checks pass.</p>
<h2 id="testing-for-collision">Testing For Collision</h2>
<p>Now that we have the code to check for AABB collision, let's test it out in our game project.  Open the <strong>Game1.cs</strong> class file in the project and add the following fields.</p>
<pre><code class="lang-cs">//  Represents bounding box [A]
private Rectangle _boxA;

//  Represents bounding box [B]
private Rectangle _boxB;

//  A value that indicates if the two bounding boxes are colliding.
private bool _areColliding;

//  A 1x1 white pixel texture we can use to render primitives.
private Texture2D _pixel;

//  The previous frame keyboard state.
private KeyboardState _prevKeyboardState;

//  The current frame keyboard state.
private KeyboardState _curKeyboardState;
</code></pre>
<ul>
<li><code>_boxA</code> and <code>_boxB</code> are just <code>Rectangle</code> values used to define the two bounding boxes we're going to test with.</li>
<li><code>_arColliding</code> is a <code>bool</code> field we can use to store a value indicating if the two rectangles are colliding</li>
<li><code>_pixel</code> is a <code>Texture2D</code> that we'll create in a moment that we can use to draw the rectangles to the screen.</li>
<li><code>_prevKeyboardState</code> and <code>_curKeyboardState</code> are used to track the state of keyboard input so we can move the rectangles around the screen.</li>
</ul>
<p>Next, let's define the initial values for <code>_boxA</code> and <code>_boxB</code>.   Locate the <code>Initialize()</code> method in the <code>Game1</code> class and change it to the following:</p>
<pre><code class="lang-cs">protected override void Initialize()
{
    base.Initialize();

    //  Define the x, y, width, and height of the two bounding boxes.
    _boxA = new Rectangle(100, 100, 50, 50);
    _boxB = new Rectangle(200, 200, 50, 50);
}
</code></pre>
<p>Now that we have the dimensions defined for the two rectangles, we need to create a 1x1 white pixel texture to render them with.  Locate the <code>LoadContent()</code> method in the <code>Game1</code> class and change it to the following:</p>
<pre><code class="lang-cs">protected override void LoadContent()
{
    _spriteBatch = new SpriteBatch(GraphicsDevice);

    //  Create the 1x1 pixel texture
    _pixel = new Texture2D(GraphicsDevice, 1, 1);
    _pixel.SetData&lt;Color&gt;(new Color[] { Color.White });
}
</code></pre>
<p>Next, we need to update the keyboard input states and check for input to move the rectangles around the screen.  Locate the <code>Update(GameTime)</code> method in the <code>Game1</code> class and change it to the following:</p>
<pre><code class="lang-cs">protected override void Update(GameTime gameTime)
{
    //  Update the input states.
    _prevKeyboardState = _curKeyboardState;
    _curKeyboardState = Keyboard.GetState();

    MoveBoxA();
    MoveBoxB();

    //  Check if _boxA and _boxB are colliding.
    _areColliding = CollisionChecks.AABB(_boxA, _boxB);

    base.Update(gameTime);
}
</code></pre>
<p>And add the following two methods to the <code>Game1</code> which perform the movement checks for <code>_boxA</code> and <code>_boxB</code></p>
<pre><code class="lang-cs">/// &lt;summary&gt;
///     Moves bounding box [A] based on keyboard input.
/// &lt;/summary&gt;
private void MoveBoxA()
{
    if(_curKeyboardState.IsKeyDown(Keys.W))
    {
        _boxA.Y--;
    }
    else if(_curKeyboardState.IsKeyDown(Keys.S))
    {
        _boxA.Y++;
    }

    if (_curKeyboardState.IsKeyDown(Keys.A))
    {
        _boxA.X--;
    }
    else if (_curKeyboardState.IsKeyDown(Keys.D))
    {
        _boxA.X++;
    }
}

/// &lt;summary&gt;
///     Moves bounding box [B] based on keyboard input
/// &lt;/summary&gt;
private void MoveBoxB()
{
    if (_curKeyboardState.IsKeyDown(Keys.Up))
    {
        _boxB.Y--;
    }
    else if (_curKeyboardState.IsKeyDown(Keys.Down))
    {
        _boxB.Y++;
    }

    if (_curKeyboardState.IsKeyDown(Keys.Left))
    {
        _boxB.X--;
    }
    else if (_curKeyboardState.IsKeyDown(Keys.Right))
    {
        _boxB.X++;
    }
}
</code></pre>
<p>To go over the changes we've just made for the <code>Update(GameTime)</code> method</p>
<ol>
<li>We update the values of the <code>_prevKeyboardState</code> and <code>_curKeyboardState</code>.</li>
<li><code>MoveBoxA()</code> is called which checks <strong>W</strong>, <strong>S</strong>, <strong>A</strong>, and <strong>D</strong> key presses to move <code>_boxA</code>.</li>
<li><code>MoveBoxB()</code> is called, which checks <strong>Up</strong>, <strong>Down</strong>, <strong>Left</strong>, and <strong>Right</strong> key presses to move <code>_boxB</code>.</li>
<li><code>CollisionChecks.AABB(Rectangle, Rectangle)</code> is called, giving it both <code>_boxA</code> and <code>_boxB</code> to check if they are colliding. The result <code>true</code> or <code>false</code> is returned back and stored in <code>_areColliding</code>.</li>
</ol>
<p>Finally, we need to draw the rectangles to the screen.  Locate the <code>Draw(GameTime)</code> method in the <code>Game1</code> class and change it to the following:</p>
<pre><code class="lang-cs">protected override void Draw(GameTime gameTime)
{
    GraphicsDevice.Clear(Color.Black);

    //  Draw the bounding boxes as white rectangles.
    Color color = Color.White;

    //  If the bounding boxes are colliding, make them red instead.
    if(_areColliding)
    {
        color = Color.Red;
    }

    _spriteBatch.Begin();
    _spriteBatch.Draw(_pixel, _boxA, color);
    _spriteBatch.Draw(_pixel, _boxB, color);
    _spriteBatch.End();
    base.Draw(gameTime);
}
</code></pre>
<p>Here we just creating a <code>Color</code> value defaulted to <code>Color.White</code>.  Then we check if <code>_areColliding</code> is <code>true</code>, and if so change the color value to <code>Color.Red</code>.  Finally we draw our two rectangles using the color value calculated based on if they are colliding.</p>
<p>If you run the game at this point, you should see two white rectangles on the screen.  Use <strong>W</strong>, <strong>S</strong>, <strong>A</strong>, and <strong>D</strong> keys to move the left rectangle, and <strong>Up</strong>, <strong>Down</strong>, <strong>Left</strong>, and <strong>Right</strong> keys to move the right rectangle.  If you make them collide, they will both turn red.  Moving them apart so they are no longer colliding will change them back to white.</p>
<div class="embeddedvideo"><iframe src="https://aristurtle.net/images/tutorials/collision-detection/aabb-collision-demo.mp4" frameborder="0" allowfullscreen="true"></iframe></div>
<h2 id="conclusion">Conclusion</h2>
<p>So far in this tutorial, we have discussed what <strong>Axis-Aligned Bounding Box</strong> means and how it can be used to detect collision between two rectangles.  We then implemented a demo of this into a new MonoGame game project.</p>
<p>Not all objects in our game are rectangles through.  Somteims we may have things like a ball that is circular.  On the next page of this tutorial series, we'll discuss how to test for collision between two circular objects.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

        <div id="modificationDate" class="my-5">
          <div class="row">
            <div class="col"></div>
            <div class="col text-end">
              <em><small>Last updated on 10/18/2023 by Christopher Whitley
            </small></em></div>
          </div>
        </div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2023 Christopher Whitley
        </div>
      </div>
    </footer>
  </body>
</html>
